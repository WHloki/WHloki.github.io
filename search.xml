<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pwn一些工具的使用</title>
      <link href="/2020/03/14/pwn/"/>
      <url>/2020/03/14/pwn/</url>
      
        <content type="html"><![CDATA[<p>我是一名CTF小白，初学不久，几乎刚入门，这篇博客就介绍一些常用的也是必须会的pwn工具；</p><a id="more"></a><h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><p>第一个需要学习的是pwntools，这个也是我刚开始入门就学的东西；</p><p>先来了解一下什么是pwntools：</p><h3 id="什么是pwntools？"><a href="#什么是pwntools？" class="headerlink" title="什么是pwntools？"></a>什么是pwntools？</h3><p>pwntools是一个二进制利用框架，是CTF框架和漏洞利用开发库，用Python开发，能够更快速的编写exp；</p><p>emm这样可能不好理解，简单来讲，就是Python的一个库；</p><h3 id="安装pwntools"><a href="#安装pwntools" class="headerlink" title="安装pwntools"></a>安装pwntools</h3><p>先来说说怎么安装吧：</p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>现在大多数人都是使用Windows或者Mac，但是pwntools需要安装在Linux环境中，这里推荐使用虚拟机；</p><p>虚拟机也有很多种，推荐使用VMware，我也给大家准备好了，点击这里下载<a href="https://pan.baidu.com/s/1t2psjlLidp00Cf1k3_-EQQ" target="_blank" rel="noopener">VMware15</a>  提取码：4nu6；当然肯</p><p>定需要镜像，点击这里下载<a href="https://pan.baidu.com/s/1DXDk2uRe4CprrkUqmWbeOA" target="_blank" rel="noopener">Ubuntu16.04</a>  提取码：az58；这个镜像是64位的，当然也可以去官网下载32位的，</p><p>看自己需要吧；       // 如果遇到问题，请联系我，首页有我的联系方式，嘿嘿嘿，随时可以call我；</p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>安装pwntools需要下面几个环境：</p><p><strong>python</strong></p><p><strong>pip</strong></p><p><strong>libssl-dev</strong></p><p><strong>libffi-dev</strong></p><h4 id="pwntools的安装"><a href="#pwntools的安装" class="headerlink" title="pwntools的安装"></a>pwntools的安装</h4><p>安装需要以下几步：</p><p><strong><em>sudo apt-get install libffi-dev</em></strong><br><strong><em>sudo apt-get install libssl-dev</em></strong><br><strong><em>sudo apt-get install python</em></strong><br><strong><em>sudo apt-get install python-pip</em></strong><br><strong><em>sudo pip install pwntools</em></strong><br>注：安装过程可能会有更新pip等的提示，按照提示一步一步走就没问题，有问题请联系我；</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>安装完后，打开终端，输入<strong>python</strong>进入<strong>python</strong>命令，然后输入<strong><u>from pwn import *</u></strong> ，不报错即成功；</p><h3 id="pwntools的简单使用"><a href="#pwntools的简单使用" class="headerlink" title="pwntools的简单使用"></a>pwntools的简单使用</h3><p>前面提到，pwntools是python的一个库，那么在写exp的时候，需要掌握以下几个基本语法：</p><pre><code class="python">remote("一个域名或者ip地址", 端口) #会连接到我们指定的地址及端口，然后该函数会返回remote对象remote #对象主要用来进行对远程主机的输入输出,它有如下几个方法：send(payload) #发送payloadsendline(payload) #发送payload并进行换行（末尾\n）sendafter(some_string, payload) #接收到some_string后,发送你的 payloadrecvn(N) #接受N(数字)字符recvline() #接收一行输出recvlines(N) #接收N(数字)行输出recvuntil(some_string) #接收到some_string为止c.sendline #将我们的payload发送到远程主机c.interactive() #允许我们在终端里将命令传送到远程服务器,pwntools会自动接收输出并回显;#p32()可以让我们转换整数到小端序格式.p32转换4字节,p64和p16则分别转换8 bit和2 bit数字</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF的wp</title>
      <link href="/2020/03/13/xctf/"/>
      <url>/2020/03/13/xctf/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML学习笔记</title>
      <link href="/2020/03/13/html/"/>
      <url>/2020/03/13/html/</url>
      
        <content type="html"><![CDATA[<p>到目前为止，今年入的两个坑，一个是CTF，这个暂且不说，另一个是Blog；</p><a id="more"></a><h3 id="前篇"><a href="#前篇" class="headerlink" title="前篇"></a>前篇</h3><p>Blog这东西前面的文章也说了，很烦人其实，尤其是配置文件的时候，老是出错；最近看Hexo主题的时候又看上</p><p>了一个主题——Matery；这款主题页面清晰，画风很好，功能很多，想着就换了，但是因为不会前端的内容，里</p><p>面的好多东西，比如 JS 和 CSS 文件看不懂，导致博客页面老是出现bug，于是乎，哈哈哈，就有接下来的学了；</p><p>前端三件套 = HTML + CSS + JS；这些是web开发需要学的东西，非常好玩；</p><p>这篇博客就整理我的学习历程，先开始的HTML，所以先整理HTML；</p><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p>有人会问，编写前端这些代码需要什么IDE，其实这个不需要太大的IDE就行；最简单的是记事本，哈哈哈，没想</p><p>到吧；想着也是，把后缀改成html就行了，还可以用Notepad++；我也在网上找了几款，比如说像Vscode，</p><p>jetbrains公司的webstorm等等，这些都可以用，我也问了几个朋友，挑来挑去，咦~，发现了一款非常好的软件</p><p>——HBuilderX；</p><p>先说说它的好处，这款软件内存特别小，下载就几十MB，非常方便，它可以直接生成一个端口（应该算是），就</p><p>可以浏览你写的网页的样式；最重要的一个优点是，他可以代码补全，对于初学者来说，真的不错；</p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>相信大家应该都看过网页源码，初学者可能会问html，总得有个框架吧？有的有的，下面来看：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="utf-8" /&gt;        &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>是不是看上去框架很复杂？yes/no ? 哈哈哈，这里就体现出HBuilderX的好处了，前面提到了，可以代码补全，当</p><p>然也可以直接把框架生成出来；</p><h3 id="简单编写"><a href="#简单编写" class="headerlink" title="简单编写"></a>简单编写</h3><p>先介绍一些最简单的用法吧；</p><pre><code class="html">&lt;title&gt;...&lt;/title&gt;   &lt;!-- 网页标题 --&gt;&lt;h1&gt;...&lt;/h1&gt;   &lt;!-- 1级标题 --&gt;&lt;h2&gt;...&lt;/h2&gt;   &lt;!-- 2级标题 --&gt;&lt;h3&gt;...&lt;/h3&gt;   &lt;!-- 3级标题 --&gt;&lt;h4&gt;...&lt;/h4&gt;   &lt;!-- 4级标题 --&gt;&lt;h5&gt;...&lt;/h5&gt;   &lt;!-- 5级标题 --&gt;&lt;h6&gt;...&lt;/h6&gt;   &lt;!-- 6级标题 --&gt;&lt;p&gt;...&lt;/p&gt;              &lt;!-- 段落标签，文字会独占一行 --&gt;&lt;i&gt;...&lt;/i&gt;                &lt;!-- 定义斜体字--&gt;&lt;b&gt;...&lt;/b&gt;              &lt;!-- 定义粗体字 --&gt;&lt;big&gt;...&lt;/big&gt;          &lt;!-- 定义大号字 --&gt;&lt;small&gt;...&lt;/small&gt;        &lt;!-- 定义小号字 --&gt;&lt;strong&gt;...&lt;/strong&gt;      &lt;!-- 定义加重字 --&gt;&lt;em&gt;...&lt;/em&gt;             &lt;!-- 定义着重字 --&gt;&lt;sub&gt;...&lt;/sub&gt;          &lt;!-- 定义下标字 --&gt;&lt;sup&gt;...&lt;/sup&gt;          &lt;!-- 定义上标字 --&gt;&lt;ins&gt;...&lt;/ins&gt;          &lt;!-- 定义下划线 --&gt;&lt;del&gt;...&lt;/del&gt;          &lt;!-- 定义删除字 --&gt;&lt;br /&gt;      &lt;!-- 换行 --&gt;&lt;hr /&gt;      &lt;!-- 水平线 --&gt;&amp;nbsp;      &lt;!-- 网页上显示一个空格 --&gt;</code></pre><p>看上去有点晕，那就来演示一遍</p><p>这是代码：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="utf-8" /&gt;        &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;        &lt;title&gt;Test&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p&gt;2020.3.14&lt;/p&gt;        &lt;hr /&gt;        &lt;p&gt;*测试标题效果*&lt;/p&gt;        &lt;h1&gt;Hello HTML!&lt;/h1&gt;        &lt;h2&gt;Hello HTML!&lt;/h2&gt;        &lt;h3&gt;Hello HTML!&lt;/h4&gt;        &lt;h4&gt;Hello HTML!&lt;/h4&gt;        &lt;h5&gt;Hello HTML!&lt;/h5&gt;        &lt;h6&gt;Hello HTML!&lt;/h6&gt;        &lt;p&gt;*测试字体效果*&lt;/p&gt;        &lt;p&gt;Hello&amp;nbsp;HTML!&lt;/p&gt;        &lt;i&gt;Hello HTML!&lt;/i&gt;&lt;br /&gt;        &lt;b&gt;Hello HTML!&lt;/b&gt;&lt;br /&gt;        &lt;big&gt;Hello HTML!&lt;/big&gt;&lt;br /&gt;        &lt;em&gt;Hello HTML!&lt;/em&gt;&lt;br /&gt;        &lt;small&gt;Hello HTML!&lt;/small&gt;&lt;br /&gt;        &lt;strong&gt;Hello HTML!&lt;/strong&gt;&lt;br /&gt;        Hello&lt;sub&gt; HTML!&lt;/sub&gt;&lt;br /&gt;        Hello&lt;sup&gt; HTML!&lt;/sup&gt;&lt;br /&gt;        &lt;ins&gt;Hello HTML!&lt;/ins&gt;&lt;br /&gt;        &lt;del&gt;Hello HTML!&lt;/del&gt;&lt;br /&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>看运行结果：</p><p><img src="/images/loading.gif" data-original="/images/2.jpg" alt="1"></p><p>怎么样，是不是很有趣，nice！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树—Tree</title>
      <link href="/2020/03/08/shu/"/>
      <url>/2020/03/08/shu/</url>
      
        <content type="html"><![CDATA[<p>早就对 ”树“ 有所耳闻了，今日一会，果然**；</p><a id="more"></a><p>树（Tree）是n（n≥0）个结点的有限集；n=0时称为空树；在任意一棵非空树中：</p><p>(1) 有且仅有一个特定的称为根（Root）的结点；</p><p>(2) 当n&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵</p><p>树，并且称为根的子树（SubTree）；</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm</title>
      <link href="/2020/03/05/algorithm/"/>
      <url>/2020/03/05/algorithm/</url>
      
        <content type="html"><![CDATA[<p>这篇博客很早就想整理了，一直没有时间，今天上课，课余时间真的不多，那就来整理一波；</p><a id="more"></a><p>先说明一下，blog这东西很离谱，老是出现毛病，这篇博客应该全部用C++来写，但是代码标注是C，因为标注</p><p>C++的时候，到了网页上面就是部分代码残缺，2333</p><h3 id="Unix时间戳"><a href="#Unix时间戳" class="headerlink" title="Unix时间戳"></a>Unix时间戳</h3><p>讲算法之前，先说一个实用的东西——Unix时间戳；</p><p>Unix时间戳是从1970年1月1日开始所经过的秒数，不考虑闰秒。</p><p>这个是柠檬大佬给我写的（自己太菜）；</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;time.h&gt;using namespace std;int main(){    time_t now;    int Time=time(&amp;now);    cout &lt;&lt; "现在的时间为" &lt;&lt; Time &lt;&lt; endl;}</code></pre><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>先来一个简单的sort吧；</p><p>sort() 是C++标准库里面的库函数，之前做编程练习题目的时候经常会用到，算是quicksort的另一种形式，因为时</p><p>间复杂度都为 O(log₂N)，完美地解决了所谓的TLE问题，直接上代码：</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){    int a[100],i,n;    cin &gt;&gt; n;        for(i=0;i&lt;n;i++)    {        cin &gt;&gt; a[i];    }    sort(a,a+n); //调用sort函数     for(i=0;i&lt;n;i++)    {        cout &lt;&lt; a[i] &lt;&lt; ' ';    }}</code></pre><p>这种是最简单的形式，默认从小到大，那从大到小呢？嘿嘿，别着急，来看：</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int cmp(int m,int n)  //自定义函数 {    return m&gt;n;} int main(){    int a[100],i,n;    cin &gt;&gt; n;        for(i=0;i&lt;n;i++)    {        cin &gt;&gt; a[i];    }    sort(a,a+n,cmp); //调用sort函数     for(i=0;i&lt;n;i++)    {        cout &lt;&lt; a[i] &lt;&lt; ' ';    }}</code></pre><p>这种是加一个自定义函数cmp，用于大小比较，从小到大时也可以自定义一个函数，但是没必要其实；</p><p>还有其他很多种形式，去about页面，有我的联系方式，给我发信息给你代码（嘻嘻嘻）；</p><p>可以去练习一下，请见<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1040" target="_blank" rel="noopener">杭电1040</a></p><h3 id="gcd-amp-lcm"><a href="#gcd-amp-lcm" class="headerlink" title="gcd &amp; lcm"></a>gcd &amp; lcm</h3><p>gcd模板其实已经写烂了，但是几个月没碰过编程了，难免会有些生疏，再来回顾一下；</p><p>lcm也很简单，两数乘积除以最大公约数；</p><h4 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h4><p>先看最原始的代码（我第一次写的代码）：</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int gcd(int a,int b){    int t;    while(b!=0)    {        t = a%b;         a = b;         b = t;    }    return a;}int main(){    int m,n;    cin &gt;&gt; m &gt;&gt; n;    cout &lt;&lt; gcd(m,n) &lt;&lt; endl;}</code></pre><p>三目运算法（这个超级简单）：</p><p>不会三目运算符的回C语言再学习一下哦~</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int gcd(int a,int b){    return !b?a:gcd(b,a%b); //三目运算符} int main(){    int m,n;    cin &gt;&gt; m &gt;&gt; n;    cout &lt;&lt; gcd(m,n) &lt;&lt; endl;}</code></pre><h4 id="lcm"><a href="#lcm" class="headerlink" title="lcm"></a>lcm</h4><p>lcm其实没啥好说的，用三目来说，直接看代码：</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int gcd(int a,int b){    return !b?a:gcd(b,a%b);}int lcm(int m,int n){    return (m*n)/gcd(m,n);} int main(){    int m,n;    cin &gt;&gt; m &gt;&gt; n;    cout &lt;&lt; lcm(m,n) &lt;&lt; endl;}</code></pre><p>是不是超级简单，那就去练习一下：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2504" target="_blank" rel="noopener">杭电2504</a></p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>排列组合也遇到过，解决“有多少种”这类问题经常遇见，只不过，这类问题都很简单，一学就会；概念高中已经学</p><p>过了，这里就不多说了；</p><h4 id="排列A"><a href="#排列A" class="headerlink" title="排列A"></a>排列A</h4><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int A(int m, int n){    int i,t,ans=1;    if(m&lt;n)    {        m=t;        t=n;        n=m;    }    for(i=m;i&gt;=m-n+1;i--)    {        ans *= i;    }    return ans;}int main(){    int m,n;    cin &gt;&gt; m &gt;&gt; n;    if(m&gt;n) cout &lt;&lt; A(m,n) &lt;&lt; endl;    else cout &lt;&lt; A(n,m) &lt;&lt; endl;}</code></pre><h4 id="组合C"><a href="#组合C" class="headerlink" title="组合C"></a>组合C</h4><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int C(int n,int k){    int ans=1;    int i;    for(i=n;i&gt;=n-k+1;i--)    {        ans*=i;    }    for(i=1;i&lt;=k;i++)    {        ans/=i;    }        return ans;}int main(){    int m,n;    cin &gt;&gt; m &gt;&gt; n;    if(m&gt;n) cout &lt;&lt; C(m,n) &lt;&lt; endl;    else cout &lt;&lt; C(n,m) &lt;&lt; endl;}</code></pre><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>快速幂这个算法可以用来计算那些次方很多数据很大的问题，有些问题会出现TLE，引入快速幂，很好得解决了这</p><p>个问题，它的时间复杂度为 O(log₂N)，上代码：</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;long long quick(long long x,long long y){    long long ans = 1,base = x;    while( y &gt; 0 )    {        if( y % 2 )        {            ans *= base;        }        base *= base;        y /= 2;    }    return ans;}int main(){    long long m,n;    cin &gt;&gt; m &gt;&gt; n;    cout &lt;&lt; quick(m,n) &lt;&lt; endl;} </code></pre><p>这个可以计算到2的62次方左右，因为long long的范围有限；</p><h3 id="大数相加（模拟）"><a href="#大数相加（模拟）" class="headerlink" title="大数相加（模拟）"></a>大数相加（模拟）</h3><p>这个挺有意思的题目，上大学之前刷题的时候就有人说，初学者做不出来“A+B”，当时我还笑了，“A+B”有什么难</p><p>的，一个输入一个输出不就完事，后来有人说，那你计算111….(100个1) + 222….(100个2)的值，我一想，不行</p><p>啊，int不够，long long不够，int64页不够，我就放弃了；再后来….咳，请看代码：</p><pre><code class="c">//大数相加#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int main(){    int m=1,n=1,i,j,L1,L2,k;    char a[1002],b[1002];    int num1[1002],num2[1002];    memset(num1,0,sizeof(num1));            //数组清零     memset(num2,0,sizeof(num2));            //数组清零    cin &gt;&gt; a &gt;&gt; b;                              //输入数组     L1 = strlen(a);                  //计算数组a的长度     L2 = strlen(b);                 //计算数组b的长度     for(i=L1-1;i&gt;=0;i--)    {        num1[m] = a[i] - '0';           m++;                   //字符--&gt;数字     }    for(i=L2-1;i&gt;=0;i--)    {        num2[n] = b[i] - '0';            n++;                  //字符--&gt;数字     }    for(i=1;i&lt;1002;i++)    {        k = i;        num1[i] += num2[i];        // num1数组当成一个新的数组，重新赋值         if(num1[i]&gt;9)        {            num1[i] = num1[i]%10;    //判断是否超过10 超过进位             num1[++k] ++;            //下一位进 1         }    }    for(i=1001;i&gt;0;i--)    {        if(num1[i]!=0)             //判断什么时候不为 0         {            for(j=i;j&gt;0;j--)            {                cout &lt;&lt; num1[j];            }            break;        }    }}</code></pre><p>原来啊，把数字转换成字符串的形式，这样的话，就很容易了；</p><p>学会了吗，去练习一下吧：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1002" target="_blank" rel="noopener">杭电1002</a></p><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>这个算法是过双创中心面试之后第一个讲解的算法，其实现在还是懵懵的；</p><p>二分查找法，其实是一种有序的查找方法，也称折半查找，如果是无序的则要先进行排序操作；</p><p>基本思想是：目标值通过与中间元素比较，可分为三种情况：</p><p>1、目标值与中间元素相等，查找结束；</p><p>2、目标值比中间元素大，则把后半部分的中间元素与目标值比较；</p><p>3、目标值比中间元素小，则把前半部分的中间元素与目标值比较；</p><p>这三步一直循环，直到找到答案为止；</p><p>适用情况：求最大值中的最小值、求最小值中的最大值；（听着很别扭，其实就是这样）</p><p>类似于数学里面的二分，思想差不多；</p><p>以一道题来举例：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4004" target="_blank" rel="noopener">杭电4004</a></p><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int a[500200];int L,n,m;int check(int x) //二分函数{    int i,cnt=0,t=0;    for(i=1;i&lt;=n;i++)    {        if(a[i]-a[i-1]&gt;x)        {            return 0;        }        if(a[i]-t&gt;x)        {            cnt++;            t=a[i-1];        }    }    if(cnt+1&lt;=m)        return 1;    else        return 0;}int main(){    int mid,i;    while(cin&gt;&gt;L&gt;&gt;n&gt;&gt;m)    {        for(i=1;i&lt;=n;i++)        {            cin &gt;&gt; a[i];        }        a[0]=0,a[++n]=L;        sort(a,a+n+1);        int l=0,r=L,res;        while(l&lt;=r) //这里的小于等于千万不能忘记等于        {            mid=(l+r)/2; //分半            if(check(mid)) //取左            {                res=mid;                r=mid-1;            }            else //取右            {                l=mid+1;             }        }        cout &lt;&lt; res &lt;&lt;endl;    }    return 0;}</code></pre><p>这题是不是太难了呀，不要紧，在给你一道简单的：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2199" target="_blank" rel="noopener">杭电2199</a></p><p>这题算是很简单的二分了，要是不会的话，回来看代码：</p><p>注意啊，这段代码里面的cin和cout要改成C语言的scanf和printf，不知为什么cin和cout过不去，可能因为保留的</p><p>小数位数吧，就很离谱；</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;iomanip&gt;using namespace std;double f(double x){    return (8*x*x*x*x+7*x*x*x+2*x*x+3*x+6);}int main(){    int t;    double l,r,m,n,mid;    cin &gt;&gt; t;    while(t--)    {        cin &gt;&gt; m;        l=0,r=100;        if(f(0)&gt;m||f(100)&lt;m)        {            cout &lt;&lt; "No solution!" &lt;&lt; endl;        }        else        {            while(r-l &gt; 0.000001)            {                   mid = (l+r)/2;                   if((f(mid)-m) &gt; 0)                {                       r = mid;                }                else                 {                    l = mid;                }             }            cout &lt;&lt; setprecision(5) &lt;&lt; r &lt;&lt; endl;        }        }}</code></pre><h3 id="Dfs-amp-Bfs"><a href="#Dfs-amp-Bfs" class="headerlink" title="Dfs &amp; Bfs"></a>Dfs &amp; Bfs</h3><p>相信打过acm比赛的人都知道这两种算法，一种叫做dfs（深度优先搜索），一种叫做bfs（广度优先搜索）；</p><p>怎么说呢，折两种算法早就想学了，就是没找到机会，现在正好学习算法，就简单学学吧；</p><h4 id="Dfs"><a href="#Dfs" class="headerlink" title="Dfs"></a>Dfs</h4><p>深度优先搜索算法（Depth First Search，简称DFS）：一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树</p><p>的节点，尽可能深的搜索树的分支，当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到</p><p>发现节点v的那条边的起始节点，整个进程反复进行直到所有节点都被访问为止；</p><h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><pre><code class="c">int check(参数){    if(满足条件)    {        return 1;    }    else    {        return 0;    }}void dfs(int step){        判断边界        {            ...操作        }        尝试每一种可能        {               满足check条件               标记               继续下一步dfs(step+1)               恢复初始状态（回溯的时候要用到）        }}</code></pre><p>模板也是根据实际情况来改，下面通过一个实例来了解一下：</p><h5 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h5><p>问题描述：1~n , n个数字，能组成多少个不同的数字？</p><p>例如：n=3，则能组成的数字有：123 , 132 , 213 , 231 , 312 , 321</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt; using namespace std;int a[10], book[10], n,num=0;int dfs(int step){    int i;    if (step == n + 1) //判断边界    {        for (i = 1; i &lt;= n; i++)        {            cout &lt;&lt; a[i];num++;        }        cout &lt;&lt; endl;    }    for (i = 1; i &lt;= n; i++) //遍历    {        if (book[i] == 0) //满足check        {            a[step] = i;            book[i] = 1;  //标记            dfs(step + 1); //继续搜索            book[i] = 0; //恢复初始状态        }    }    return num;}int main(){    cin &gt;&gt; n;    dfs(1); //从第一个开始    cout &lt;&lt; "共有" &lt;&lt; num/n &lt;&lt; "个";    return 0;}</code></pre><h4 id="Bfs"><a href="#Bfs" class="headerlink" title="Bfs"></a>Bfs</h4><p>广度优先算法（Breadth-First-Search，简称BFS），是一种图形搜索演算法。简单的说，BFS是从根节点开始，沿</p><p>着树的宽度遍历树的节点，如果发现目标，则演算终止；</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串—String</title>
      <link href="/2020/03/01/chuan/"/>
      <url>/2020/03/01/chuan/</url>
      
        <content type="html"><![CDATA[<p>学完了栈与队列，应该都会了吧，今天来聊聊串；</p><a id="more"></a><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>串是由零个或多个字符组成的有限序列，又名叫字符串；</p><p>串中的字符数目n称为串的长度；</p><p>零个字符的串称为空串，可以用两双引号””表示，也可以用希腊字母Ø表示；</p><p>字符串，大家都不陌生对吧，学习C语言的时候就讲过了，编程题中常常遇到，这里就不多说了；</p><h3 id="串的比较"><a href="#串的比较" class="headerlink" title="串的比较"></a>串的比较</h3><p>这里串的比较在C语言也学过了，strcmp()函数，一会会讲到，就不多说；</p><h3 id="串的抽象数据类型"><a href="#串的抽象数据类型" class="headerlink" title="串的抽象数据类型"></a>串的抽象数据类型</h3><pre><code class="c">1、StrAssign(S, *chars) //生成一个值等于chars的串S2、StrCopy(S,T) //串T复制得串S3、StrLength(S) //串S的长度，即S中的元素个数4、StrCat(S,T) //串T连接在串S后面5、SubString(Sub,S,pos,len) //用Sub返回串S的第pos个字符起长度为len的子串6、StrIndex(S,T) //若串S中存在与串T相同的子串，则返回它在串S中第一次出现的位置，否则返回代表错误的值7、StrInsert(S,pos,T) //在串S的第pos个字符插入串T8、StrDelete(S,pos,len) //从串S中删除第pos个字符起长度为len的子串9、StrReplace(S,T,V) //用串V替换串S中出现得到所有与T相等的不重叠子串10、StrEmpty(S) //若串S为空串，则返回1，否则返回011、StrCompare(S,T) //若S&gt;T，则返回值&gt;0,若S=T，则返回值=0,若S&lt;T，则返回值&lt;012、StrClear(S) //将串S清空13、DispStr(S) //显示串S的所有字符</code></pre><h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><p>串的存储结构也是分为顺序存储结构和链式存储结构，重点讲顺序存储结构，即定长顺序串；</p><h4 id="结构代码"><a href="#结构代码" class="headerlink" title="结构代码"></a>结构代码</h4><pre><code class="c">#define MAXSIZE 100typedef struct{    char ch[MAXSIZE];    int Len;}String;</code></pre><h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h4><pre><code class="c">int StrLength(String* S) //求字符串S长度{    int i = 0;    while (S-&gt;ch[i] != '\0')    {        i++;    }    S-&gt;Len = i;    return (S-&gt;Len);}</code></pre><h4 id="建立新串"><a href="#建立新串" class="headerlink" title="建立新串"></a>建立新串</h4><pre><code class="c">void CreateStr(String* S) //建立一个新串{    gets(S-&gt;ch);    S-&gt;Len = StrLength(S);}</code></pre><h4 id="求子串函数"><a href="#求子串函数" class="headerlink" title="求子串函数"></a>求子串函数</h4><pre><code class="c">int SubString(String* S, String* Sub, int pos, int len) //求子串函数，用Sub返回串S的第pos个字符起长度为len的子串{    int j;    if (pos&lt;1 || pos&gt;S-&gt;Len || len&lt;1 || len&gt;S-&gt;Len - pos + 1) //范围错误    {        Sub-&gt;Len = 0;        printf("ERROR\n");        return 0;    }    else    {        for (j = 0; j &lt; len; j++)        {            Sub-&gt;ch[j] = S-&gt;ch[pos + j - 1]; //新串Sub赋值        }        Sub-&gt;ch[j] = '\0'; //新串尾部加上字符串结束标志        Sub-&gt;Len = len; //规定长度        return 1;    }}</code></pre><h4 id="删除子串"><a href="#删除子串" class="headerlink" title="删除子串"></a>删除子串</h4><pre><code class="c">int StrDelete(String* S, int i, int l) //删除子串，在S中删除第i开始连续l个字符{    int k;    if (i + l - 1 &gt; S-&gt;Len)    {        printf("子串超界")        return 0;    }    else    {        for (k = i + l - 1; k &lt; S-&gt;Len; k++, i++) //从第i位开始删除长度为l个字符        {            S-&gt;ch[i - 1] = S-&gt;ch[k];        }        S-&gt;Len = S-&gt;Len - l; //长度-l        S-&gt;ch[S-&gt;Len] = '\0'; //新串尾部加上字符串结束标志        return 1;    }}</code></pre><h4 id="插入子串"><a href="#插入子串" class="headerlink" title="插入子串"></a>插入子串</h4><pre><code class="c">int StrInsert(String *S,String *T,int i) //串S中第i个字符插入子串T{    int k;    if (i &gt; S-&gt;Len + 1)    {        printf("插入位置错误")；        return 0;    }    else if(S-&gt;Len+T-&gt;Len&gt;MAXSIZE)    {        printf("两串长度超过存储空间长度")        return 0；    }    else    {        for (k = S-&gt;Len - 1; k &gt;= i - 1; k--) //将第i位开始的字符各向后移动T串长度        {            S-&gt;ch[T-&gt;Len + k] = S-&gt;ch[k];        }        for (k = 0; k &lt; T-&gt;Len; k++) //将子串T插入到串S的第i位处        {            S-&gt;ch[i + k - 1] = T-&gt;ch[k];        }        S-&gt;Len = S-&gt;Len + T-&gt;Len; //修改串S的长度        S-&gt;ch[S-&gt;Len] = '\0'; //新串S尾部加上字符串结束标志        return 1;    }}</code></pre><h4 id="定位子串"><a href="#定位子串" class="headerlink" title="定位子串"></a>定位子串</h4><pre><code class="c">int StrIndex(String* S, String* T) //串的定位函数，若串S中存在与串T相同的子串，则返回它在串S中第一次出现的位置(第几个字符，不是下标){    int i = 0, j = 0, k;    while (i &lt; S-&gt;Len &amp;&amp; j &lt; T-&gt;Len) //当两串指针没指向该串尾时进行比较    {        if (S-&gt;ch[i] == T-&gt;ch[j])        {            i++;            j++;        }        else        {            i = i - j + 1;            j = 0;        }    }    if (j &gt;= T-&gt;Len) //串S中有串T    {        k = i - T-&gt;Len + 1;    }    else    {        k = -1;    }    return k;}</code></pre><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><pre><code class="c">int StrCompare(String* S1, String* S2)//判断两个串是否相等{    int i = 0, flag = 0;    while (S1-&gt;ch[i] != '\0' &amp;&amp; S2-&gt;ch[i] != '\0') //当两串没到串尾部时    {        if (S1-&gt;ch[i] != S2-&gt;ch[i]) //两串对应位置的字符是否相同        {            flag = 1; //标志置为1            break; //结束循环        }        else        {            i++; //计数        }    }    if (flag == 0 &amp;&amp; S1-&gt;Len == S2-&gt;Len) //两串长度相同且所有字符都相同，两串相等    {        return 0;    }    else    {        return S1-&gt;ch[i] - S2-&gt;ch[i]; //返回对应第一个不相同位置字符ASCII码差值    }}</code></pre><h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><pre><code class="c">int StrCat(String* S, String* T) //连接函数{    int i, flag;    if (S-&gt;Len + T-&gt;Len &lt;= MAXSIZE) //连接后串长小于MAXSIZE    {        for (i = S-&gt;Len; i &lt; S-&gt;Len + T-&gt;Len; i++)        {            S-&gt;ch[i] = T-&gt;ch[i - S-&gt;Len]; //赋值连接        }        S-&gt;ch[i] = '\0';        S-&gt;Len += T-&gt;Len; //长度相加        flag = 1;    }    else if (S-&gt;Len &lt; MAXSIZE) //连接后串长大于MAXSIZE，但串S长度小于MAXSIZE，连接后串T部分字符序列被舍弃    {        for (i = S-&gt;Len; i &lt; MAXSIZE; i++)        {            S-&gt;ch[i] = T-&gt;ch[i - S-&gt;Len];        }        S-&gt;Len = MAXSIZE;        flag = 0;    }    else //串S的长度等于MAXSIZE，串T不被连接    {        flag = 0;    }    return flag;}</code></pre><h4 id="子串替换"><a href="#子串替换" class="headerlink" title="子串替换"></a>子串替换</h4><pre><code class="c">void StrReplace(String* S, String* T, String* V) //子串替换，用串V替换串S中出现得到所有与T相等的不重叠子串{    int i, m, n, p, q;    n = S-&gt;Len;    m = T-&gt;Len;    q = V-&gt;Len;    p = 1;    do {        i = StrIndex(S, T); //调用定位函数得到子串T在子串S的位置        if (i != -1) //当主串S有该子串T时        {            StrDelete(S, i, m); //删除子串T            StrInsert(S, V, i); //插入子串V            p = i + q;            S-&gt;Len = S-&gt;Len + q - m; //修改主串S的长度            n = S-&gt;Len;+        }    } while ((p &lt;= n - m + 1) &amp;&amp; (i != -1));}</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>串这部分内容呢比较简单，后面还有广义表和KMP算法，这里先不讲了；</p><p>下周直接学树；</p><p>Bye Bye~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2月29日的深更半夜</title>
      <link href="/2020/02/29/2-yue-29-ri/"/>
      <url>/2020/02/29/2-yue-29-ri/</url>
      
        <content type="html"><![CDATA[<p>这篇博客呢就闲聊一点吧，反正今天也是一个特殊的日子；</p><a id="more"></a><p>​        寒假到今天为止50天了，因为疫情原因，大把好时光就这么浪费了，真是难过又觉得可惜，先自我作个总结吧：</p><p>​        从寒假第一天开始，玩了一个多星期的王者荣耀（自己很不务正业），想着自己还有任务，赶紧学习，还来得及其实，但是吧，我这人，虽说自觉性很高，但是吧，想耐住性子学习还真不容易；</p><p>​        况且，我们任务学习汇编和PHP。这种底层语言真的是很无聊，学着就想吐；刚开始接触PHP的时候感觉很好玩，但是学了一段时间，发现，它的语法还有格式对我这种强迫症来讲，算了算了吧，实在是驾驭不了；</p><p>​        我就重点学习汇编，汇编说实话，更麻烦，枯燥无味，很繁琐，可能受C，C++的影响，底层语言真的是无话可说，顿时感觉高级语言好玩；</p><p>​        讲真的，想过放弃，但是某一天，堆堆给了我XCTF的链接，我一进去，哇塞，好酷的页面，瞬间又有了学习的动力，我就注册账号，发现题目不是想象的那样，太难了；但是没关系，谁能一开始就觉得简单呢，我就边玩边学，耐得住性子，坐在写字桌前面看书看视频，开头难但是还得学好。。。</p><p>​        第一次做出来一道CTF的题目的时候，我那心情，别提有多高兴，题目考验的不仅仅是思维能力，还有计算能力，使用工具的能力，印象最深的是一道P二维码的题目，为了做它，新学了一点PS基础，P了一个晚上还没出来，心态没了；</p><p>​        再后来，老师收集学习进度说还得整blog（一提到blog我就来气），看着教程做都做不出来，多亏了柠檬大佬，才有了今天在这里写似日记非日记的东西（嘻嘻嘻）；</p><p>​        最近，又得学习Python，还得装虚拟机，虚拟机更是麻烦，所有的错误情况我都遇见了估计，没有比我还倒霉的啦，现在还没装，没心情了，想着尽快把Python基础学完才行，才能进行下一个学习计划；</p><p>、</p><p>、</p><p>、</p><p>长路漫漫，为了拿offer，为了将来，加油干<del>~</del></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> NUL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NUL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列—Stack &amp; Queue</title>
      <link href="/2020/02/26/zhan-yu-dui-lie/"/>
      <url>/2020/02/26/zhan-yu-dui-lie/</url>
      
        <content type="html"><![CDATA[<p>学习完线性表，今天开始学习栈与队列；</p><a id="more"></a><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>栈是限定仅在表尾进行插入和删除操作的线性表；</p><p>允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈，栈又称为后进先出线性表，</p><p>简称LIFO结构；</p><h3 id="栈的抽象数据类型——基本操作-入栈-出栈"><a href="#栈的抽象数据类型——基本操作-入栈-出栈" class="headerlink" title="栈的抽象数据类型——基本操作( 入栈 出栈 )"></a>栈的抽象数据类型——基本操作( 入栈 出栈 )</h3><pre><code class="c">1、InitStack(*S) //初始化操作，建立一个空栈2、DestroyStack(*S) //若栈存在，则销毁它3、ClearStack(*S) //将栈清空4、StackEmpty(*S) //若栈为空，返回true，否则返回false5、GetTop(S, *e) //若栈存在且非空，用e返回S的栈顶元素6、Push(*S, e) //若栈S存在，插入新元素e到栈S中并成为栈顶元素7、Pop(*S, *e) //删除栈S中栈顶元素，并用e返回其值8、StackLength(S) //返回栈S的元素个数</code></pre><h3 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h3><h4 id="结构代码"><a href="#结构代码" class="headerlink" title="结构代码"></a>结构代码</h4><pre><code class="c">#define MAXSIZE 1000typedef int DataType;typedef struct{    DataType data[MAXSIZE]; //栈的元素最大个数    int top; //用于栈顶指针}SqStack;</code></pre><h4 id="初始化栈"><a href="#初始化栈" class="headerlink" title="初始化栈"></a>初始化栈</h4><pre><code class="c">void InitStack(SqStack* S) //初始化栈{    S-&gt;top = -1; //初始化栈为空}</code></pre><h4 id="判断栈是否已满"><a href="#判断栈是否已满" class="headerlink" title="判断栈是否已满"></a>判断栈是否已满</h4><pre><code class="c">int StackFull(SqStack* S) //判断栈是否已满{    if (S-&gt;top == MaxSIZE - 1)        return 1;    else        return 0;}</code></pre><h4 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h4><pre><code class="c">int StackEmpty(SqStack* S) //判断栈是否为空{    if (S-&gt;top == -1)        return 1    else        return 0;}</code></pre><h4 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h4><pre><code class="c">int Push(SqStack* S, DataType e) //进栈操作 插入元素e为新的栈顶元素{    if (StackFull(S)) //栈满    {        return 0;    }    S-&gt;top++; //栈顶指针增加1    S-&gt;data[S-&gt;top] = e; //新插入元素赋值给栈顶空间    return 1;}</code></pre><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><pre><code class="c">int Pop(SqStack* S, DataType* e) //出栈操作 若栈不为空，则删除栈顶元素，用e返回其值{    if (StackEmpty(S)) //栈空    {        return 0;    }    *e = S-&gt;data[S-&gt;top]; //将要删除的元素赋值给e    S-&gt;top--; //栈顶指针减少1    return 1;}</code></pre><h3 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h3><h4 id="结构代码-1"><a href="#结构代码-1" class="headerlink" title="结构代码"></a>结构代码</h4><pre><code class="c">#define MAXSIZE 100typedef struct StackNode{    DataType data;    struct StackNode* next;}LinkStack;</code></pre><h4 id="初始化栈-1"><a href="#初始化栈-1" class="headerlink" title="初始化栈"></a>初始化栈</h4><pre><code class="c">LinkStack* InitStack(){    LinkStack* S;    S = NULL; //初始化栈为空    return S;}</code></pre><h4 id="判断栈是否为空-1"><a href="#判断栈是否为空-1" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h4><pre><code class="c">int EmptyStack(LinkStack* S){    if (S == NULL)        return 1;    else        return 0;}</code></pre><h4 id="进栈-1"><a href="#进栈-1" class="headerlink" title="进栈"></a>进栈</h4><pre><code class="c">int Push(LinkStack* S, DataType e){    LinkStack* p = (LinkStack)malloc(sizeof(LinkStack));    p-&gt;data = e; //e放入新节点的数据域    p-&gt;next = S; //新节点插入链表表头之前    S = p; //新节点作为栈顶    return 1; }</code></pre><h4 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h4><pre><code class="c">int Pop(LinkStack* S, DataType* e){    LinkStack* p;    if (EmptyStack(S))    {        return 0;    }    *e = S-&gt;data; //栈顶元素赋值给e    p = S; //p节点指向原栈顶S    S = S-&gt;next; //原栈顶S指向其下一个节点    free(p); //释放原栈顶空间    return 1;}</code></pre><h4 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><pre><code class="c">int GetTop(LinkStack* S, DataType* e){    if (EmptyStack(S)) //栈为空    {        return 0;    }    *e = S-&gt;data; //栈顶元素赋给变量e    return 1;}</code></pre><h4 id="遍历栈"><a href="#遍历栈" class="headerlink" title="遍历栈"></a>遍历栈</h4><pre><code class="c">void ShowStack(LinkStack* S){    LinkStack* p = S;    if (p == NULL)    {        printf("栈为空\n");        return;    }    while (p != NULL)    {        printf("%d", p-&gt;data);        p = p-&gt;next;    }}</code></pre><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表；</p><p>队列是一种先进先出的线性表，简称FIFO；允许插入的一端称为队尾，允许删除的一端称为队头；</p><h3 id="队列的抽象数据类型——基本操作"><a href="#队列的抽象数据类型——基本操作" class="headerlink" title="队列的抽象数据类型——基本操作"></a>队列的抽象数据类型——基本操作</h3><pre><code class="c">1、InitQueue(*Q) //初始化操作，建立一个空队列2、DestroyQueue(*Q) //若队列Q存在，则销毁3、ClearQueue(*Q) //将队列Q清空4、QueueEmpty(Q) //若队列为空，返回true，否则返回false5、GetHead(Q,*e) //若队列存在且非空，用e返回Q的队头元素6、EnQueu(*Q,e) //若队列存在，则插入e于Q，并成为队尾元素7、DeQueue(*Q,*e) // 删除队列Q中队头元素，并用e返回其值8、QueueLength(Q) //返回队列Q中元素个数</code></pre><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><h4 id="队列顺序存储的不足"><a href="#队列顺序存储的不足" class="headerlink" title="队列顺序存储的不足"></a>队列顺序存储的不足</h4><p>与栈不同的是，队列的出列是在队头，那就意味着，队列的所有元素都得移动，以保证下标为0的位置不为空，此</p><p>时间复杂度为O(n);</p><p>为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，</p><p>rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列；</p><p>假溢出：说白了就是数组末尾元素已满，再向后加就越界，而队列前面还有空位的现象（0,1,2….空着）；</p><h4 id="循环队列定义"><a href="#循环队列定义" class="headerlink" title="循环队列定义"></a>循环队列定义</h4><p>头尾相接顺序存储结构称为循环队列；</p><p>设队列最大长度为QueueSize，那么：</p><p>队列满的条件为(rear+1) % QueueSize == front ;</p><p>队空条件为front == rear ;</p><p>队列长度计算公式为(rear-front+QueueSize) % QueueSize ; (自己推导式子很简单)</p><h4 id="循环队列顺序存储结构"><a href="#循环队列顺序存储结构" class="headerlink" title="循环队列顺序存储结构"></a>循环队列顺序存储结构</h4><pre><code class="c">#define MAXSIZE 100typedef int DataType;typedef struct{    DataType data[MAXSIZE];    int front; //头指针    int rear; //尾指针，若队列不变，指向队列尾元素的下一个位置}SqQueue;</code></pre><h4 id="队列初始化"><a href="#队列初始化" class="headerlink" title="队列初始化"></a>队列初始化</h4><pre><code class="c">int InitQueue(SqQueue *Q) //初始化一个对列{    Q-&gt;front = 0;    Q-&gt;rear = 0;    return 1;}</code></pre><h4 id="队列长度"><a href="#队列长度" class="headerlink" title="队列长度"></a>队列长度</h4><pre><code class="c">int QueueLength(SqQueue Q) //求队列长度{    return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;}</code></pre><h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><pre><code class="c">int EnQueue(SqQueue* Q, DataType e) //若队列未满则e入列{    if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front) //队列已满    {        return 0;    }    Q-&gt;data[Q-&gt;rear] = e; //e赋值给队尾    Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE; //rear指针后移一个位置，若到最后则转到数组头部    return 1;}</code></pre><h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><pre><code class="c">int DeQueue(SqQueue* Q, DataType* e) //若队列不空则删除队头，并用e返回其值{    if (Q-&gt;front == Q-&gt;near) //队列为空    {        return 0;    }    *e = Q-&gt;data[Q-&gt;front]; //将队头元素赋值给e    Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE; //front指针向后移一位置，若到最后则转到数组头部    return 1;}</code></pre><h3 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h3><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列；</p><h4 id="链式队列存储结构"><a href="#链式队列存储结构" class="headerlink" title="链式队列存储结构"></a>链式队列存储结构</h4><pre><code class="c">typedef int DataType;typedef struct qnode{    DataType data; //节点的数据域    struct qnode* next; //节点的指针域}LinkListQ;typedef struct{    LinkListQ* front, * rear; //队列的队头和队尾指针}LinkQueue;</code></pre><h4 id="队列初始化-1"><a href="#队列初始化-1" class="headerlink" title="队列初始化"></a>队列初始化</h4><pre><code class="c">LinkQueue* InitQueue() //队列初始化{    LinkQueue* Q;    LinkListQ* p;    Q = (LinkQueue*)malloc(sizeof(LinkQueue)); //头指针所指节点    p = (LinkListQ*)malloc(sizeof(LinkListQ)); //头节点    Q-&gt;front = p; //Q指针所指的front指针指向p    Q-&gt;rear = p; //Q指针所指的rear指针指向p    return Q;}</code></pre><h4 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h4><pre><code class="c">int EnQueue(LinkQueue* Q, DataType e) //插入e于队尾{    LinkListQ* s;    s = (LinkListQ)malloc(sizeof(LinkListQ)); //分配内存空间    s-&gt;data = e; //将e存入新节点的数据域    s-&gt;next = NULL;    Q-&gt;rear-&gt;next = s; //将新节点插入链队之后    Q-&gt;rear = s; //队尾指针指向队尾元素    return 1;}</code></pre><h4 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h4><pre><code class="c">int DeQueue(LinkQueue* Q, DataType* e) //删除队头，用e返回其值{    LinkListQ* p;    if (Q-&gt;front == Q-&gt;rear) //队空    {        return 0;    }    p = Q-&gt;front-&gt;next; //p指向队头元素    *e = p-&gt;data; //队头元素的值赋给e    Q-&gt;front-&gt;next = p-&gt;next; //原队头节点后继p-&gt;next赋给头节点后继    if (Q-&gt;rear == p)/*p-&gt;next==NULL*/ //队头等于队尾，删除后将rear指向头节点    {        Q-&gt;rear = Q-&gt;front; //此时队空    }    free(p);    return 1;}</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于循环队列和链队列的比较，可以从两方面，从时间上看，它们基本操作都是常数时间，都为O(1)，从空间看，</p><p>循环队列必须有一个固定的长度，就有了存储元素个数和空间资源浪费的问题，而链队列不存在这个问题；尽管需</p><p>要一个指针域，需要空间，但是可以接受，所以空间上链队列更加灵活；</p><p>总的来说，在可以确定队列长度最大值的情况下，建议使用循环队列，无法估计队列长度时则用链队列；</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表—Linear List</title>
      <link href="/2020/02/18/xian-xing-biao/"/>
      <url>/2020/02/18/xian-xing-biao/</url>
      
        <content type="html"><![CDATA[<p>今天开始学习线性表，这也算是进入数据结构的世界了；</p><a id="more"></a><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>1、定义：n(n≥0)个数据元素的有限序列；</p><p>2、线性表是一种最常用且最简单的数据结构，含有n个元素的线性表是一个数据结构；</p><p>3、List = (D,R)  ——&gt;  D是data数据，R是relation关系；</p><h3 id="前驱后继"><a href="#前驱后继" class="headerlink" title="前驱后继"></a>前驱后继</h3><p>若将线性表记为a1,a2,a3……ai-1,ai,ai+1……an,则称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当</p><p>i=1,2,3…n-1时，ai有且仅有一个直接后继，当i=2,3,4…n时，ai有且仅有一个直接前驱；</p><p>所以，线性表的元素的个数n(n≥0)定义为线性表的长度，当n=0时，称为空表；</p><h3 id="线性表的抽象数据类型——基本操作-增-删-查-取-空-长"><a href="#线性表的抽象数据类型——基本操作-增-删-查-取-空-长" class="headerlink" title="线性表的抽象数据类型——基本操作( 增 删 查 取 空 长 )"></a>线性表的抽象数据类型——基本操作( 增 删 查 取 空 长 )</h3><pre><code class="c">1、InitList(*L) //初始化,建立一个新的线性表L；2、ListEmpty(L) //线性表为空，返回true，否则返回false；3、ListLength(L) //求长度，返回线性表中元素的个数；4、GetElem(L,i,*e) //将线性表L中第i个数据元素赋值给e；5、LocateElem(L,e) //在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功，否则，返回0表示失败；6、ListInsert(*L,i,e) //在线性表L中第i个位置插入新的数据e，表长+1；7、ListDelete(*L,i,e) //删除线性表L中第i个数据元素，e返回其值，表长-1；8、ClearList(*L) //将线性表清空；</code></pre><h2 id="线性表的顺序存储结构——顺序表"><a href="#线性表的顺序存储结构——顺序表" class="headerlink" title="线性表的顺序存储结构——顺序表"></a>线性表的顺序存储结构——顺序表</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>线性表的顺序存储结构，指的是用一段地址连续的储存单元依次储存线性表的数据元素；</p><h3 id="顺序储存方式"><a href="#顺序储存方式" class="headerlink" title="顺序储存方式"></a>顺序储存方式</h3><p>先来看看结构代码</p><pre><code class="c">#define MaxSize 20  //储存空间初始分配量typedef int ElemType;typedef struct{    ElemType data[MaxSize];    int length;  //线性表当前长度}SqList;</code></pre><h3 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><pre><code class="c">int GetElem(SqList L, int i, ElemType* e) //获得元素——&gt;e返回L中第i个数据元素的值{    if (L.length == 0 || i&lt;1 || i&gt;L.length)    {        return 0;    }    *e = L.data[i - 1];    return 1;}</code></pre><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><pre><code class="c">int ListInsert(SqList* L, int i, ElemType e) //插入操作——&gt;在L中第i个位置之前插入新的数据元素e，L的长度加1{    int k;    if (L-&gt;length == MaxSize) //线性表已满    {        return 0;    }    if (i&lt;1 || i&gt;L-&gt;length + 1) //i不在范围内    {        return 0;    }    if (i &lt;= L-&gt;length) //插入的元素不在表尾    {        for (k = L-&gt;length - 1; k &gt;= i - 1; i--)        {            L-&gt;data[k + 1] = L-&gt;data[k];        }    }    L-&gt;data[i - 1] = e; //新元素插入    L-&gt;length++;    return 1;}</code></pre><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><pre><code class="c">int ListDelete(SqList* L, int i, ElemType e) //删除操作{    int k;    if (L-&gt;length == 0) //线性表为空    {        return 0;    }    if (i&lt;1 || i&gt;L-&gt;length) //删除位置不正确    {        return 0;    }    *e = L-&gt;data[i - 1];    if (i &lt; L-&gt;length) //删除不是最后位置    {        for (k = i; k &lt; L-&gt;length; k++) //删除位置后继元素前移        {            L-&gt;data[k - 1] = L-&gt;data[k];        }    }    L-&gt;length--;    return 1;}</code></pre><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>1、优点：</p><p>①无需为表中元素之间的逻辑关系增加额外的储存空间；</p><p>②可以快速的存取表中任意位置的元素；</p><p>2、缺点：</p><p>①插入和删除操作需要移动大量元素；</p><p>②当线性表长度变化较大时，难以确定储存空间的容量；</p><p>③造成储存空间的“碎片”；</p><h2 id="线性表的链式储存结构——链表"><a href="#线性表的链式储存结构——链表" class="headerlink" title="线性表的链式储存结构——链表"></a>线性表的链式储存结构——链表</h2><p>链表在之前的博客里面已经整理了一部分，在这里再整理一遍吧；</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>先定义一个结构体</p><pre><code class="c">typedef struct Node{    ElemType data;    struct Node *next;}Node;typedef struct Node* LinkList; //定义LinkList</code></pre><h4 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h4><pre><code class="c">int GetElem(LinkList L, int i, ElemType* e) //用e返回L中第i个数据元素的值{    int j;    LinkList p;   //声明指针p    p = L-&gt;next;  //p指向链表L的第一个节点    j = 1;    //j为计数器    while (p &amp;&amp; j &lt; i) //p不为空且计数器j还没有等于i时，循环继续    {        p = p-&gt;next; //p指向下一个节点        ++j;    }    if (!p || j &gt; i)    {        return 0;  //第i个节点不存在    }    *e = p-&gt;data;  //取第i个节点的数据    return 1;}</code></pre><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><pre><code class="c">int ListInsert(LinkList* L, int i, ElemType e) //在L的第i个节点之前插入元素e，L的长度加1{    int j;    LinkList p,s;    p = *L;    j = 1;    while (p &amp;&amp; j &lt; i) //寻找第i-1个节点    {        p = p-&gt;next;        ++j;    }    if (!p || j &lt; i)    {        return 0;  //第i个节点不存在    }    s = (LinkList)malloc(sizeof(Node)); //生成新节点    s-&gt;data = e;    s-&gt;next = p-&gt;next;  //将p的后继节点赋值给s的后继    p-&gt;next = s;  //将s赋值给p的后继    return 1;}</code></pre><h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><pre><code class="c">int LinkDelete(LinkList* L, int i, ElemType* e) //删除L中的第i个节点，并用e返回其值，L的长度减1{    int j;    LinkList p, q;    p = *L;    j = i;    while (p-&gt;next &amp;&amp; j &lt; i) //遍历寻找第i-1个节点    {        p = p-&gt;next;        ++j;    }    if (!(p-&gt;next) || j &gt; i)    {        return 0;  //第i个节点不存在    }    q = p-&gt;next;    p-&gt;next = q-&gt;next; //将q的后继赋值给p的后继    *e = q-&gt;data;   //将q节点中的数据给e    free(q);    return 1;}</code></pre><h4 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h4><h5 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h5><pre><code class="c">void CreateListHead(LinkList* L, int n) //随机产生n个元素的值，建立带表头节点的单链线性表L（头插法）{    LinkList o;    int i;    srand(time(0));  //初始化随机种子    *L = (LinkList)malloc(sizeof(Node));    (*L)-&gt;next = NULL;   //先建立一个带头结点的单链表    for (i = 0; i &lt; n; i++)    {        p = (LinkList)malloc(sizeof(Node)); //生成新节点        p-&gt;data = rand() % 100 + 1;  //随机生成100以内的数字        p-&gt;next = (*L)-&gt;next;        (*L)-&gt;next = p;   //插入到表头    }}</code></pre><h5 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h5><pre><code class="c">void CreateListTail(LinkList* L, int n)//随机产生n个元素的值，建立带表头节点的单链线性表L（尾插法）{    LinkList p, r;    int i;    srand(time(0));    *L = (LinkList)malloc(sizeof(Node));    r = *L;    for (i = 0; i &lt; n; i++)    {        p = (Node*)malloc(sizeof(Node));  //生成新节点        p-&gt;data = rand() % 100 + 1;        r-&gt;next = p;  //将表尾终端节点的指针指向新节点        r = p;  //将当前的新节点定义为表尾终端节点    }    r-&gt;next = NULL;  //表示当前链表结束}</code></pre><h4 id="清空链表"><a href="#清空链表" class="headerlink" title="清空链表"></a>清空链表</h4><pre><code class="c">int ClearList(LinkList* L) //单链表的整表删除，将L置为空表{    LinkList p, q;    p = (*L)-&gt;next; //p指向第一个节点    while (p)  //没到表尾    {        q = p-&gt;next;        free(p);        p = q;    }    (*L)-&gt;next = NULL;  //头结点指针域为空    return 1;}</code></pre><h4 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h4><p>1、存储分配方式</p><p>​        ①顺序存储结构一般用一段连续的存储单元依次存储线性表的数据元素</p><p>​        ②单链表采用链式存储结构，用一组任意的存储大单元存放线性表的元素</p><p>2、时间性能</p><p>①查找</p><p>ⅰ顺序存储结构O(1)</p><p>ⅱ单链表O(n)</p><p>②插入和删除</p><p>​        ⅰ顺序存储结构需要平均移动表长一半的元素，时间为o(n)</p><p>​        ⅱ单链表在线出某位置的指针后，插入和删除时间仅为o(1)</p><p>③空间性能</p><p>​        ⅰ顺序存储结构需要预分配存储空间，分大了，浪费，分小了，易发生上溢</p><p>​        ⅱ单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制</p><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>用数组描述的链表叫做静态链表 ；</p><p>具体描述：首先让数组的两个元素都是由两个数据域组成，data和cur；也就是说，数组的每个下标都对应一个</p><p>data和cur；数据域data，用来存放数据元素,也就是通常我们要处理的数据；而cur相当于链表中的next指针，存</p><p>放该元素的后继在数组中的下标，我们把cur叫做游标；</p><p>小注：这里我理解的游标就是next那根链，元素的游标指向下一个数值的下标；;</p><h4 id="静态链表存储结构"><a href="#静态链表存储结构" class="headerlink" title="静态链表存储结构"></a>静态链表存储结构</h4><pre><code class="c">#define MAXSIZE 1000 // 假设链表最大长度是1ktypedef struct{    ElemType data;    int cur; //游标，为0时表示无指向}StaticLinkList[MAXSIZE];</code></pre><h4 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h4><p>0-998游标从1-999，最后一个游标为0</p><pre><code class="c">int InitLink(StaticLinkList space) //将一位数组space中各分量链成一备用链表，space[0].cur为头指针，"0"表示空指针{    int i;    for (i = 0; i &lt; MAXSIZE - 1; i++)    {        space[i].cur = i + 1;    }    space[MAXSIZE - 1].cur = 0; //目前静态链表为空，最后一个元素的cur为0    return 1;}</code></pre><p>注：</p><p>​    我们通常把未使用的数组元素成为备用链表；</p><p>​    数组的第一个元素，即下标为0的那个元素的cur就存放备用链表的第一个节点的下标；</p><p>​    数组的最后一个元素，即下标为MAXSIZE-1的cur则存放第一个有数值的元素的下标，相当于头节点的作用；</p><h4 id="获取链表中元素的个数"><a href="#获取链表中元素的个数" class="headerlink" title="获取链表中元素的个数"></a>获取链表中元素的个数</h4><pre><code class="c">int ListLength(StaticLinkList L){    int j = 0;    int i = L[MAXSIZE - 1].cur; //最后一个元素的游标，从头循环计数    while (i) //循环计数，找到空闲分量即停止循环    {        i = L[i].cur;         j++;  //计数    }    return j;}</code></pre><h4 id="静态链表的插入操作"><a href="#静态链表的插入操作" class="headerlink" title="静态链表的插入操作"></a>静态链表的插入操作</h4><h5 id="获得空闲分量的下标"><a href="#获得空闲分量的下标" class="headerlink" title="获得空闲分量的下标"></a>获得空闲分量的下标</h5><pre><code class="c">int Malloc_SSL(StaticLinkList space) //若备用空间链表为空，则返回分配的节点下标，否则返回0{    int i = space[0].cur; //当前数组第一个元素cur存的值，就是要返回的第一个备用空闲的下标    if (space[0].cur)    {        space[0].cur = space[i].cur; // 由于要拿出一个分量来使用，所以我们就得把它的下一个分量用来做备用    }    return i;}</code></pre><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><pre><code class="c">int ListInsert(StaticLinkList L, int i, ElemType e) // 在L中第i个元素之前插入新的数据元素e{    int j, k, l;    k = MAXSIZE - 1;  //k是最后一个元素的下标    if (i&lt;1 || i&gt;Listlength(L) + 1)    {        return 0;    }    j = Malloc_SSL(L);  //获得空闲分量的下标    if (j)    {        L[j].data = e; //将数值赋值给此分量的data        for (l = 1; l &lt;= i - 1; l++)  //找到第i个元素之前的位置        {            k = L[k].cur;        }        L[j].cur = L[k].cur;  //把第i个元素之前的cur赋值给新元素的cur        L[k].cur = j;  //把新元素的下标赋值给第i个元素之前元素的cur        return 1;    }    return 0;}</code></pre><h4 id="静态链表的删除操作"><a href="#静态链表的删除操作" class="headerlink" title="静态链表的删除操作"></a>静态链表的删除操作</h4><h5 id="回收节点"><a href="#回收节点" class="headerlink" title="回收节点"></a>回收节点</h5><pre><code class="c">void Free_SSL(StaticLinkList space,int k)//将下标为k的空闲节点回收到备用链表{    space[k].cur = space[0].cur; //把第一个元素cur值赋给要删除的分量cur    space[0].cur = k; //把要删除的分量下标赋给第一个元素的cur}</code></pre><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><pre><code class="c">int ListDelete(StaticLinkList L, int i) // 删除L中第i个元素e{    int j, k;    if (i&lt;1 || i&gt;ListLength(L))    {        return 0    }    k = MAXSIZE - 1;    for (j = 1; j &lt;= i - 1; j++)    {        k = L[k].cur;    }    // j &gt; k    j = L[k].cur;  //L[k].cur指向删除元素的下标，赋值给j    L[k].cur = L[j].cur;  //被删除元素的游标赋值给前一个元素的游标，实现连接    Free_SSL(L, j); //回收    return 1;}</code></pre><h4 id="静态链表优缺点"><a href="#静态链表优缺点" class="headerlink" title="静态链表优缺点"></a>静态链表优缺点</h4><p>1、优点：</p><p>​        ●在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作</p><p>需要移动大量元素的缺点</p><p>2、缺点：</p><p>​        ●没有解决连续存储分配带来的表长难以确定的问题</p><p>​        ●失去了顺序存储结构随机存取的特性</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>循环链表——首尾相连的链表；</p><p>将单链表中终端节点的指针端由空指针改为指向头节点，就使整个单链表形成一个环。这种头尾相接的单链表称为</p><p>单循环链表，简称循环链表；</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>循环链表中，从任一节点出发都可以访问到表中所有节点，在单链表中，必须从头指针开始，否则无法访问到该节</p><p>点之前的其他节点；</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>双向链表是在单链表的每个节点中，再设置一个指向其前驱节点的指针域，前驱后继方向都能遍历；</p><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><pre><code class="c">typedef struct DulNode{    ElemType data;    struct DulNode* prior;  //直接前驱指针    struct DulNode* next;  //直接后继指针};</code></pre><p>显然，与单链表相比，多了一个直接前驱；</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一章节是线性表，线性表对于以后学习的数据结构会有很大作用；</p><p>选择使用哪种线性表，结合情况再定，各有利弊；</p><p>下一章学习栈与队列，不见不散；</p><p>Bye~~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度</title>
      <link href="/2020/02/18/shi-jian-fu-za-du/"/>
      <url>/2020/02/18/shi-jian-fu-za-du/</url>
      
        <content type="html"><![CDATA[<p>今天开始学习数据结构，一边学习一边整理，第一个要学的是时间复杂度；</p><a id="more"></a><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>定义：算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))(T(n)是语句总的执行次数)，它表示随问</p><p>题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。</p><p>其中f(n)是问题的规模n的某个函数；</p><h4 id="推导大O阶方法"><a href="#推导大O阶方法" class="headerlink" title="推导大O阶方法"></a>推导大O阶方法</h4><p>1、用常数1取代运行时间中的所有加法常数；</p><p>2、在修改后的运行次数函数中，只保留最高阶项；</p><p>3、如果最高阶项存在且不是1，则去除与这个项相乘的常数；</p><p>得到的的结果就是大O阶；</p><h4 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h4><p>常数阶    ——&gt;    O(1)</p><p>线性阶    ——&gt;    O(n)</p><p>平方阶    ——&gt;    O(n^2)</p><p>对数阶    ——&gt;    O(logn)</p><p>nlogn阶  ——&gt;    O(nlogn)</p><p>立方阶    ——&gt;    O(n^3)</p><p>指数阶    ——&gt;    O(2^n)</p><h4 id="常见的时间复杂度所耗时间的大小排列"><a href="#常见的时间复杂度所耗时间的大小排列" class="headerlink" title="常见的时间复杂度所耗时间的大小排列"></a>常见的时间复杂度所耗时间的大小排列</h4><p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>算法的时间复杂度内容不多，很好理解，从下一章开始就将进入代码的世界；</p><p>拜拜啦~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表—Link List</title>
      <link href="/2020/02/18/lian-biao/"/>
      <url>/2020/02/18/lian-biao/</url>
      
        <content type="html"><![CDATA[<p>链表是C语言中非常难理解的一个知识点，可以说是比指针还难学的东西。在学习数据结构的时候常常会用到，所</p><p>以想来想去有必要整理一波；</p><a id="more"></a><p>链表种类很多种，有单向链表，双向链表，空头链表，非空头链表，循环链表，非循环链表；</p><p>这里小浩只学了单向空头和单向非空头链表，先整理这两种，以后学完再添加；</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>链表实际上是线性表的链式存储结构，与数组不同的是，它是用一组任意的存储单元来存储线性表中的数据，存储</p><p>单元不一定是连续的；</p><p>且链表的长度不是固定的，链表数据的这一特点使其可以非常的方便地实现节点的插入和删除操作；</p><p>链表的每个元素称为一个节点，每个节点都可以存储在内存中的不同的位置，为了表示每个元素与后继元素的逻辑</p><p>关系，以便构成“一个节点链着一个节点”的链式存储结构；</p><p>除了存储元素本身的信息外，还要存储其直接后继信息，因此，每个节点都包含两个部分，第一部分称为链表的数</p><p>据区域，用于存储元素本身的数据信息，第二部分是一个结构体指针，称为链表的指针域，用于存储其直接后继的</p><p>节点信息；</p><p>next的值实际上就是下一个节点的地址，当前节点为末节点时，next的值设为空指针；</p><h4 id="优点（相对于数组）"><a href="#优点（相对于数组）" class="headerlink" title="优点（相对于数组）"></a>优点（相对于数组）</h4><p>对线性表进行删除，添加等操作时候，不需要移动大量数据，操作简便，而数组需要动用大量数据，十分困难；同</p><p>时链表属于动态分配内存，数据量可以改变，而数组长度必须提前定义好，属于静态分配内存；链表省空间，数组</p><p>容易越界，长度过长又会造成系统资源浪费；</p><p>总的来说，链表优点非常多；</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>单向链表只能顺序访问，不能随机访问，这种储存结构最大缺点就是容易断链；一旦某个节点指针域数据丢失，将</p><p>无法找到下一个节点，也就是说，该节点的后面的数据全部丢失；</p><h3 id="无空头链表"><a href="#无空头链表" class="headerlink" title="无空头链表"></a>无空头链表</h3><h4 id="头文件-函数声明-结构体-全局变量"><a href="#头文件-函数声明-结构体-全局变量" class="headerlink" title="头文件+函数声明+结构体+全局变量"></a>头文件+函数声明+结构体+全局变量</h4><p>头文件stdlib.h，调用malloc（）函数和free（）函数；</p><p>函数比较多，先声明一下，便于阅读；</p><p>结构体先设一个成员，根据自己情况来设；</p><p>设全局变量的话，写各个操作函数的时候就省了一个形参；</p><h5 id="头文件（根据使用的语言自行修改）"><a href="#头文件（根据使用的语言自行修改）" class="headerlink" title="头文件（根据使用的语言自行修改）"></a>头文件（根据使用的语言自行修改）</h5><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;</code></pre><h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><pre><code class="c">//函数声明 链表的增、删、查、改；void AddTail(int n); //创建链表，在链表中增加一个数据，尾添加void AddHead(int n); //创建链表，在链表中增加一个数据，头添加void AddList(int index, int n); //在数字index后面添加数字avoid DeleteHead(); //头删除void DeleteTail(); //尾删除void DeleteNode(int n); //删除指定节点 void SeekList(); //遍历链表——&gt;查struct Node* SearchNode(int n); //查询指定节点void ChangeNode(int index, int n); //将index改为 n  void FreeList(); //链表清空</code></pre><h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><pre><code class="c">//节点结构体struct Node{    int a;    struct Node* next; //指向下一个节点的指针};</code></pre><h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><pre><code class="c">//链表头尾指针（全局变量）struct Node* head = NULL;struct Node* tail = NULL;</code></pre><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><h5 id="头添加"><a href="#头添加" class="headerlink" title="头添加"></a>头添加</h5><pre><code class="c">void AddHead(int n) //创建链表，在链表中增加一个数据，头添加{    //创建一个节点    struct Node* pTemp = (struct Node*)malloc(sizeof(struct Node));    //节点数据进行赋值    pTemp-&gt;a = n;    pTemp-&gt;next = NULL;    //接在链表上    if (head == NULL)//链表为空，新节点既是头也是尾巴    {        head = pTemp;        tail = pTemp;    }    else    {        pTemp-&gt;next = head; //新节点的下一个指向头        head = pTemp;//新节点就是头了    }}</code></pre><h5 id="尾添加"><a href="#尾添加" class="headerlink" title="尾添加"></a>尾添加</h5><pre><code class="c">void AddTail(int n) //创建链表，在链表中增加一个数据，尾添加{    //创建一个节点    struct Node* pTemp = (struct Node*)malloc(sizeof(struct Node));    //节点数据进行赋值    pTemp-&gt;a = n;    pTemp-&gt;next = NULL;    //链接    if (head == NULL || tail == NULL)//空链表，既是头，又是尾    {        head = pTemp;    }    else //不为空，往尾巴上添加    {        tail-&gt;next = pTemp;    }    tail = pTemp;// 尾巴一直指向最后一个节点}</code></pre><h5 id="任意位置添加"><a href="#任意位置添加" class="headerlink" title="任意位置添加"></a>任意位置添加</h5><pre><code class="c">void AddList(int index, int n)//在数字index后面添加数字n{    if (head == NULL)    {        printf("链表为空，没有节点\n");        return;    }    struct Node* fp = SearchNode(index);    if (fp == NULL)    {        printf("没有指定的节点\n");        return;    }    //有此节点，给a创建节点    struct Node* pTemp = (struct Node*)malloc(sizeof(struct Node));    pTemp-&gt;a = n;    pTemp-&gt;next = NULL;    if (fp == tail)//链接到链表上    {        tail-&gt;next = pTemp; //尾巴的下一个，指向新的节点        tail = pTemp;  //新节点是最后一个，变成尾巴    }    else    {        pTemp-&gt;next = fp-&gt;next;//先连        fp-&gt;next = pTemp;      //后断    }}</code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h5 id="头删除"><a href="#头删除" class="headerlink" title="头删除"></a>头删除</h5><pre><code class="c">void DeleteHead() //头删除{    if (head == NULL)//检查链表是否为空    {        printf("链表为NULL，无需释放!\n");        return;    }    if (head == tail)    {        free(head);        head = NULL;        tail = NULL;    }    else    {        struct Node* pTemp = head;//记住旧的头        head = head-&gt;next; //头的下一个节点变成新的头        free(pTemp); //释放旧的头    }}</code></pre><h5 id="尾删除"><a href="#尾删除" class="headerlink" title="尾删除"></a>尾删除</h5><pre><code class="c">void DeleteTail() //尾删除{    if (head == NULL)//检查链表是否为空    {        printf("链表为NULL，无需释放!\n");        return;    }    //链表不为空 有一个节点    if (head == tail)    {        free(head);        head = NULL;        tail = NULL;    }    else    {        //找尾巴前一个节点        struct Node* pTemp = head;        while (pTemp-&gt;next != tail)        {            pTemp = pTemp-&gt;next;        }        //找到尾巴 删除并释放        free(tail);  //释放尾巴        tail = pTemp;//移动尾巴        tail-&gt;next = NULL;//尾巴的下一个指针赋值为NULL    }}</code></pre><h5 id="任意位置删除"><a href="#任意位置删除" class="headerlink" title="任意位置删除"></a>任意位置删除</h5><pre><code class="c">void DeleteNode(int n)//删除指定节点 {    if (head == NULL)//检查链表是否为空    {        printf("链表为NULL，无需释放!\n");        return;    }    //链表有东西，找此节点    struct Node* pTemp = SearchNode(n);    if (pTemp == NULL)    {        printf("查无此节点\n");        return;    }    //找到了    if (pTemp == head) //只有一个节点    {        DeleteHead();    }    else if (pTemp == tail)//有两个节点    {        DeleteTail();    }    else//有多个节点    {        struct Node* fp = head;        while (fp-&gt;next != pTemp)        {            fp = fp-&gt;next;        }        //找到了        fp-&gt;next = pTemp-&gt;next;//连接        free(pTemp); //释放    }}</code></pre><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><pre><code class="c">void SeekList() //遍历链表——&gt;查{    struct Node* pTemp = head;    while (pTemp != NULL)    {        printf("%d  ",pTemp-&gt;a);        pTemp = pTemp-&gt;next;    }    printf("\n");}</code></pre><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre><code class="c">struct Node* SearchNode(int n) //查询指定节点{    struct Node* pTemp = head;    int num = 1;    while (pTemp != NULL)    {        if (n == pTemp-&gt;a)        {            printf("第%d个数为%d\n", num, pTemp-&gt;a);            //return pTemp;        }        pTemp = pTemp-&gt;next;        num++;    }    return NULL; //没找到}</code></pre><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><pre><code class="c">void ChangeNode(int index, int n)//将index改为 n  {    struct Node* fp = head-&gt;next;    while (fp != NULL)    {        if (fp-&gt;a == index)        {            fp-&gt;a = n;            return;        }        fp = fp-&gt;next;    }}</code></pre><h4 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h4><pre><code class="c">void FreeList() //链表清空{    struct Node* pTemp = head; //记录头，防止头被修改，丢内存    while (pTemp != NULL)    {        struct Node* fp = pTemp;        pTemp = pTemp-&gt;next;        free(fp);    }    //头尾清空    head = NULL;    tail = NULL;}</code></pre><h3 id="空头链表"><a href="#空头链表" class="headerlink" title="空头链表"></a>空头链表</h3><p>空头链表和无空头链表其实本质区别不大，空头链表就是头结点为空（有头指针，但是没有数值域）在进行某些操</p><p>作的时候就比较简单；</p><p>空头链表和无空头链表相似度很高，部分操作相同，就不一一列举了；</p><h4 id="头文件-函数声明-结构体-全局变量-1"><a href="#头文件-函数声明-结构体-全局变量-1" class="headerlink" title="头文件+函数声明+结构体+全局变量"></a>头文件+函数声明+结构体+全局变量</h4><h5 id="头文件（根据使用的语言自行修改）-1"><a href="#头文件（根据使用的语言自行修改）-1" class="headerlink" title="头文件（根据使用的语言自行修改）"></a>头文件（根据使用的语言自行修改）</h5><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;</code></pre><h5 id="函数声明-1"><a href="#函数声明-1" class="headerlink" title="函数声明"></a>函数声明</h5><pre><code class="c">struct Node* CreateNode(int n);//创建节点void NewList();//空头链表初始化void AddHead(int n); // 头添加void AddTail(int n); //尾添加void AddRand(int index, int n);//在数字index后面添加数字avoid DeleteHead();//删除头void DeleteTail();//删除尾void DeleteNode(int n);//删除指定节点void SeekList(); //遍历struct Node* SearchNode(int n); //查找指定节点，并返回节点地址void FreeList();//释放链表</code></pre><h5 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h5><pre><code class="c">//节点结构体struct Node{    int a;    struct Node* next; //指向下一个节点的指针};</code></pre><h5 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h5><pre><code class="c">//链表头尾指针（全局变量）struct Node* head = NULL;struct Node* tail = NULL;</code></pre><h4 id="空头链表初始化"><a href="#空头链表初始化" class="headerlink" title="空头链表初始化"></a>空头链表初始化</h4><pre><code class="c">void NewList()//空头链表初始化{    //链表空头    head = (struct Node*)malloc(sizeof(struct Node));    head-&gt;next = NULL;    tail = head;}</code></pre><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><pre><code class="c">struct Node* CreateNode(int n)//创建节点{    struct Node* pTemp = (struct Node*)malloc(sizeof(struct Node));//创建一个节点    if (pTemp == NULL)//创建失败    {        return NULL;    }    pTemp-&gt;a = n; //节点成员赋值    pTemp-&gt;next = NULL;    return pTemp;//返回节点}</code></pre><h4 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h4><h5 id="头添加-1"><a href="#头添加-1" class="headerlink" title="头添加"></a>头添加</h5><pre><code class="c">void AddHead(int n) // 头添加{    struct Node* pTemp = CreateNode(n);//创建一个节点    if (pTemp == NULL)//创建失败    {        printf("内存不足\n");// 一般不会申请失败，除非内存不足        return;    }    //连接    pTemp-&gt;next = head-&gt;next;    head-&gt;next = pTemp;}</code></pre><h5 id="尾添加-1"><a href="#尾添加-1" class="headerlink" title="尾添加"></a>尾添加</h5><pre><code class="c">void AddTail(int n) //尾添加{    struct Node* pTemp = CreateNode(n);//创建一个节点    if (pTemp == NULL)//创建失败    {        printf("内存不足\n");// 一般不会申请失败，除非内存不足        return;    }    //连接    tail-&gt;next = pTemp;    tail = pTemp;}</code></pre><h5 id="任意位置添加-1"><a href="#任意位置添加-1" class="headerlink" title="任意位置添加"></a>任意位置添加</h5><pre><code class="c">void AddRand(int index,int n)//在数字index后面添加数字a{    if (head-&gt;next == NULL)//判断链表有没有东西    {        printf("链表无节点\n");        return;    }    //找index节点    struct Node* pTemp = SearchNode(index);    if (pTemp == NULL)    {        printf("查无此节点\n");        return;    }    //找到节点,连接到指定位置    //创建节点    struct Node* pNode = CreateNode(n);    //连接    if (pTemp == tail)    {        AddTail(n);    }    else    {        pNode-&gt;next = pTemp-&gt;next;        pTemp-&gt;next = pNode;    }}</code></pre><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><h5 id="头删除-1"><a href="#头删除-1" class="headerlink" title="头删除"></a>头删除</h5><pre><code class="c">void DeleteHead()//删除头{    if (head-&gt;next == NULL)//判断链表有没有东西    {        printf("链表无头");         return;    }    //有节点 ——&gt; 删除      struct Node* pTemp = head-&gt;next; //记录头    head-&gt;next = head-&gt;next-&gt;next;  //变头    free(pTemp);//释放}</code></pre><h5 id="尾删除-1"><a href="#尾删除-1" class="headerlink" title="尾删除"></a>尾删除</h5><pre><code class="c">void DeleteTail()//删除尾{     if (head-&gt;next == NULL)//判断链表有没有东西    {        printf("链表无尾");        return;    }    //有一个节点 ——&gt; 删除    if (head-&gt;next == tail)    {        free(tail);        head-&gt;next = NULL;        tail = head;    }    else    {        struct Node* pTemp = head-&gt;next;        while (pTemp != NULL)        {            if(pTemp-&gt;next == tail)            {                 break;            }            pTemp = pTemp-&gt;next;        }        //pTemp就是尾巴的前一个        free(tail); //释放尾巴        tail = pTemp; //更新尾巴        tail-&gt;next = NULL; //尾巴下一个赋值为NULL    }}</code></pre><p>到这里，剩下的操作和无空头的没啥区别，这里就不多说了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF工具</title>
      <link href="/2020/02/17/ctf-gong-ju/"/>
      <url>/2020/02/17/ctf-gong-ju/</url>
      
        <content type="html"><![CDATA[<p>假期做了很多CTF（攻防世界）的题目，小浩刚学没多久，只会简单的MISC和CRYPTO，网上搜集各种解密类型，</p><p>一个个去尝试，先整理一波；</p><a id="more"></a><p>整理这个其实是因为收藏夹满了，工具堆叠太多（噗哈哈哈），话不多说直接上网址；</p><h4 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h4><p>之前就喜欢密码学，了解的不是很多，但是感觉超厉害！！！Very Good！！！</p><p>做了题目知道了很多密码：Base64，ROT13，摩斯密码，凯撒密码，栅栏密码，幂数加密（计算就可以，或者写</p><p>个脚本），RSA加密（到现在还没看懂原理emmm）</p><p><a href="http://tool.chinaz.com/Tools/Base64.aspx" target="_blank" rel="noopener">Base64</a></p><p><a href="https://tool.lu/morse/" target="_blank" rel="noopener">Morse</a></p><p><a href="https://www.qqxiuzi.cn/bianma/kaisamima.php" target="_blank" rel="noopener">Caesar</a></p><p><a href="https://www.jisuan.mobi/puzzm6z1B1HH6yXW.html" target="_blank" rel="noopener">ROT13</a></p><p><a href="http://www.atoolbox.net/Tool.php?Id=777" target="_blank" rel="noopener">W型栅栏密码</a></p><p><a href="https://www.sojson.com/encrypt_aes.html" target="_blank" rel="noopener">AES</a></p><p><a href="http://www.bejson.com/convert/ox2str/" target="_blank" rel="noopener">16进制文本转换</a></p><p><a href="http://www.atoolbox.net/Category.php?Id=27" target="_blank" rel="noopener">加密解密工具</a></p><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><p>杂项题目更头疼，五花八门的解密方法，确实让人头疼。还得精通ps（真是佩服），有一道p二维码的题，p了一</p><p>个晚上；</p><p><a href="https://www.sojson.com/qr/deqr.html" target="_blank" rel="noopener">二维码</a></p><p><a href="https://app.xunjiepdf.com/pdf2word/" target="_blank" rel="noopener">PDF转-&gt;</a></p><p><a href="http://keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="noopener">与佛论禅</a></p><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p><a href="http://ctf.ssleye.com/?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">CTF在线工具</a></p><p><a href="https://www.ctftools.com/down/" target="_blank" rel="noopener">CTF资源库</a></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>CTF是个很好玩的“游戏”，现在虽然是个小白，但是我要努力成为大佬，题目越做越多，后面再进行整理。</p><p>Fighting！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2020/02/15/pai-xu/"/>
      <url>/2020/02/15/pai-xu/</url>
      
        <content type="html"><![CDATA[<p>初学算法，从最简单的开始——排序；</p><a id="more"></a><p>算法中常用的排序有多钟，比如冒泡排序，桶排序，快速排序，归并排序，sort（我只会这么多，hhh），下面我</p><p>将会一一介绍：</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h3><p>首先，我们来看桶排序。桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个</p><p>桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的</p><p>了；</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){    int bucket[101],i,j,t,n;    memset(bucket,0,sizeof(bucket));  //数组全体置为 0     scanf("%d",&amp;n);  //输入一个数字 n，表示有 n个数     for(i=0;i&lt;n;i++) //循环读入 n个数，并进行桶排序     {        scanf("%d",&amp;t);   //把每次读入的数字用变量 t保存         bucket[t]++;//进行计数，对编号为 t的桶加一     }    for(i=0;i&lt;101;i++)  //依次判断编号为 0-100 的桶     {        for(j=1;j&lt;=bucket[i];j++)  // 出现几次就将桶打印几次         {            printf("%d ",i);        }    }    printf("\n");     return 0;}</code></pre><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>设桶的个数为m，待排序数的个数为n；</p><p>第8行执行了m次，第13行执行了n次，第16行和第19行共执行了m+n次，所以程序共执行了2（m+n)次，时间复</p><p>杂度即为O（2*（m+n）），即O（m+n）；</p><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>其次，我们来看冒泡排序。冒泡排序基本思想是：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过</p><p>来；</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="c">#include&lt;stdio.h&gt;void swap(int *a,int *b){    int t;    t=*a,*a=*b,*b=t;}int main(){    int i,j,n;    int bubble[100];     scanf("%d",&amp;n); // 输入一个n，表示有n个数。     for(i=0;i&lt;n;i++)    {        scanf("%d",&amp;bubble[i]);    // 循环读入n个数，放入数组中     }    //下面是冒泡排序核心        for(i=0;i&lt;n;i++)   //外层for循环控制循环次数     {        for(j=0;j&lt;n-1;j++)   //内层for循环控制相邻两元素进行比较         {            if(bubble[j]&gt;bubble[j+1])   //if(bubble[j]&lt;bubble[j+1])             // 比较；两数大小并交换，前者从小到大排序，后者从大到小排序（也可以通过输出改变排列次序）             {                swap(&amp;bubble[j],&amp;bubble[j+1]);    //交换两个数             }        }    }    for(i=0;i&lt;n;i++)    {        printf("%d ",bubble[i]);        }    return 0;        }</code></pre><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>设待排序数的个数为n；</p><p>不难看出，核心代码中，最短时间为n，最长为n^2,所以时间复杂度为O（n^2）；</p><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>桶排序和冒泡排序虽然简单，但是如果有几万几亿个数排序，那效率就会非常低，这就需要一种快速的排序方法</p><p>——快速排序；</p><p>思路：</p><p>1.对于一个数组，首先选择一个基准值key，这个基准值可以随意选，但是一般选择的是这个数组的第一个元素；</p><p>2.我们对于这个数组，把数组中所有比基准值key小的元素向基准值key的左边扔，把数组中所有比基准值key大的</p><p>元素向key的右边扔；</p><p>3.这样的话基准值key就成为了一个”分界线”，所有比基准值key小的元素都在基准值key的左边，所有比基准值key</p><p>大的元素都在基准值key的右边；</p><p>4.之后我们在递归的对基准值key左边的序列和右边的序列再用以上方法进行排序；</p><p>5.最终整个序列就是有序的了；</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre><code class="c">#include&lt;stdio.h&gt;int quick[101],n; //定义全局变量，需要在子函数中使用 void quicksort(int left, int right){    int i,j,t,temp;    if(left&gt;right)    {        return;    }     temp=quick[left];  // temp存的就是基准数     i=left;    j=right;    while(i!=j)  //顺序很重要     {        while(quick[j]&gt;=temp&amp;&amp;i&lt;j) j--;  //从右往左找         while(quick[i]&lt;=temp&amp;&amp;i&lt;j) i++;  //从左往右找         if(i&lt;j) // 交换两个数在数组中的位置         {            t=quick[i];            quick[i]=quick[j];            quick[j]=t;        }    }    // 基准数归位     quick[left]=quick[i];    quick[i]=temp;    quicksort(left,i-1);  //继续处理左边的，这是一个递归的过程     quicksort(i+1,right); //继续处理右边的，这是一个递归的过程     return;}int main(){    int i,j;    scanf("%d",&amp;n);    for(i=1; i&lt;=n; i++)    {         scanf("%d",&amp;quick[i]);    }    quicksort(1,n);  // 快排调用     for(i=1; i&lt;=n; i++)    {        printf("%d ",quick[i]);    }    printf("\n");    return 0;}</code></pre><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>设需要排序的数字的个数为n；</p><p>理想的情况是，每次划分所选择的中间数恰好将当前序列几乎等分，经过log2n趟划分，便可得到长度为1的子</p><p>表。这样，整个算法的时间复杂度为O(nlog2n)；</p><p>最坏的情况是，每次所选的中间数是当前序列中的最大或最小元素，这使得每次划分所得的子表中一个为空表，另</p><p>一子表的长度为原表的长度-1。这样，长度为n的数据表的快速排序需要经过n趟划分，使得整个排序算法的时间</p><p>复杂度为O(n^2)；</p><p>平均起来，快速排序的时间复杂度为O（nlogn）；</p><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>原理：</p><p>假设初始待排序数据有n个，可以将n个数据看成n个独立的子序列，因此每个子序列的长度为1，然后两两合并，</p><p>得到n/2个长度为2或1(如果n为奇数时，就会出现多出一个元素无法与其他元素合并)的有序子序列; 再两两合并，</p><p>一直重复下去，直到得到一个长度为n的有序序列为止（2路排序）；</p><p>核心：</p><p>两个有序子序列的合并；</p><p>（1）将待排序序列一分为二，对左右两边进行递归分割，得到m个子序列；</p><p>（2）对m个子序列递归执行合并操作，最终得到有序的序列；</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre><code class="c">#include&lt;stdio.h&gt;//原数组arr1，临时空间数组arr2void merge(int arr1[],int arr2[],int low, int mid, int high){    int i = low, j = mid+1, k = low;    while (i&lt;=mid &amp;&amp; j&lt;=high)    {        if (arr1[i]&lt;arr1[j])        {            arr2[k++] = arr1[i++];        }        else        {            arr2[k++] = arr1[j++];        }    }    while (i&lt;=mid)    {        arr2[k++] = arr1[i++];    }    while (j&lt;=high)    {        arr2[k++] = arr1[j++];    }    for (i=low; i&lt;=high;i++)    {        arr1[i] = arr2[i];    }}void mergeSort(int arr1[],int arr2[],int a, int b) {    //直到a=b时，停止递归。    if (a&lt;b)    {        int mid = (a+b)/2;        mergeSort(arr1,arr2,a,mid);        mergeSort(arr1,arr2,mid+1,b);        merge(arr1,arr2,a,mid,b);    }}int main() {    int i,a[10]={3,5,2,1,6,3,2,5,7,4},b[10];    mergeSort(a,b,0,9);    for(i=0;i&lt;=9;i++)    {        printf("%d ",a[i]);        }    return 0;}</code></pre><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>设需要排序的数字的个数为n；</p><p>归并排序稳定性比较高，最好情况、最坏情况都为nlogn，所以时间复杂度为O(nlogn)；</p><h3 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a>sort函数</h3><p>sort函数用于C++中，可以实现升序，也可以实现降序，原理不多说，直接上代码；</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int cmp1(int m,int n)  //自定义函数 {    return m&gt;n;} int cmp2(int m,int n)  //自定义函数 {    return m&lt;n;} int main(){    int a[5],i;        for(i=0;i&lt;5;i++)    {        cin &gt;&gt; a[i];     };    //从大到小--&gt; sort(a,a+5,greater&lt;int&gt;()); 或者 sort(a,a+5,cmp1);     //从小到大--&gt; sort(a,a+5,less&lt;int&gt;());  或者 sort(a,a+5,cmp2);    //acm做题的时候，常常直接sort(a,a+n);--&gt;从小到大    for(i=0;i&lt;5;i++)    {        cout &lt;&lt; a[i] &lt;&lt; ' ';    }}</code></pre><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>sort函数是qsort的升级版，它的时间复杂度也是nlogn，acm的话用sort多一些，简洁明了（偷懒）；</p><p>。。。。未完待续。。。。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2020/02/15/suan-fa/"/>
      <url>/2020/02/15/suan-fa/</url>
      
        <content type="html"><![CDATA[<p>个人基于学习的态度，高考后为了进入学校的双创中心，自学C语言两个月，初步学习了C语言的内容。</p><a id="more"></a><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法</p><p>描述解决问题的策略机制；简单来讲，就是解决问题的方法和机制；</p><h5 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h5><p>1、有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一步骤在可接受的时间内完成；</p><p>2、确定性：算法的每一步骤都有确定的含义，不会出现二义性；</p><p>3、可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成;</p><p>4、输入输出：0至多个输入，1至多个输出；</p><h4 id="我所了解的算法"><a href="#我所了解的算法" class="headerlink" title="我所了解的算法"></a>我所了解的算法</h4><p>第一个接触的算法叫做排序，分了很多种（桶，冒泡，归并，快速）；二分法，前缀和与差分法，枚举法，bfs，</p><p>dfs，还有栈，队列等等；</p><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>在接下来的一些时间里，快速学习多种算法，达到速成的效果；</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2020/02/15/shu-ju-jie-gou/"/>
      <url>/2020/02/15/shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<p>数据结构是学习语言过程中必会内容，对以后做项目，工作会有很大的帮助；</p><p>下学习开数据结构课，所以将学习记的一些笔记写进blog里面；</p><p>后面会不定时的更新；</p><a id="more"></a><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法</p><p>描述解决问题的策略机制；简单来讲，就是解决问题的方法和机制；</p><h5 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h5><p>1、有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一步骤在可接受的时间内完成；</p><p>2、确定性：算法的每一步骤都有确定的含义，不会出现二义性；</p><p>3、可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成；</p><p>4、输入输出：0至多个输入，1至多个输出；</p><h4 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h4><p>程序 = 数据结构 + 算法；</p><h4 id="数据结构概念"><a href="#数据结构概念" class="headerlink" title="数据结构概念"></a>数据结构概念</h4><p>数据结构：是相互之间存在一种或多种特定关系的数据结构元素的集合；</p><p>//接下来的时间我将会整理数据结构的相关内容，敬请期待；</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/02/14/hello-world/"/>
      <url>/2020/02/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to Hexo！！</p><p>我是一名计算机小白，这是我的第一篇博客，不足之处，请多指教；</p><p>学习语言最基本了解它大概长什么样子，下面通过打印Hello World！来了解了解；</p><a id="more"></a><h4 id="打印”Hello-World-”"><a href="#打印”Hello-World-”" class="headerlink" title="打印”Hello World!”"></a>打印”Hello World!”</h4><h5 id="C"><a href="#C" class="headerlink" title="C"></a>C</h5><pre><code class="c">#include &lt;stdio.h&gt;int main(){    printf("Hello World!\n");    return 0;}</code></pre><h5 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h5><pre><code class="c">#include &lt;iostream&gt;using namespace std;int main(){    cout &lt;&lt; "Hello World!" &lt;&lt; endl;    return 0;}</code></pre><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><pre><code class="Java">public class HelloWorld {    public static void main(String[] args) {        System.out.println("Hello World!");    }}</code></pre><h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><pre><code class="Python">print("Hello World!");</code></pre><h5 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h5><pre><code class="php">&lt;?phpecho "Hello World!";?&gt;</code></pre><h5 id="C-2"><a href="#C-2" class="headerlink" title="C#"></a>C#</h5><pre><code class="c#">using System;namespace HelloWorld{    class HelloWorld    {        static void Main(string[] args){            Console.WriteLine("Hello World!");        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Testing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Testing </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
