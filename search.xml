<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Algorithm</title>
      <link href="/2020/03/05/algorithm/"/>
      <url>/2020/03/05/algorithm/</url>
      
        <content type="html"><![CDATA[<p>这篇博客很早就想整理了，一直没有时间，今天上课，课余时间真的不多，那就来整理一波；</p><a id="more"></a><h3 id="Unix时间戳"><a href="#Unix时间戳" class="headerlink" title="Unix时间戳"></a>Unix时间戳</h3><p>讲算法之前，先说一个实用的东西——Unix时间戳；</p><p>Unix时间戳是从1970年1月1日开始所经过的秒数，不考虑闰秒。</p><p>这个是柠檬大佬给我写的（自己太菜）；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">time_t</span> now;</span><br><span class="line"><span class="keyword">int</span> Time=time(&amp;now);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"现在的时间为"</span> &lt;&lt; Time &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>先来一个简单的sort吧；</p><p>sort() 是C++标准库里面的库函数，之前做编程练习题目的时候经常会用到，算是quicksort的另一种形式，因为时</p><p>间复杂度都为 O(log₂N)，完美地解决了所谓的TLE问题，直接上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>],i,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+n); <span class="comment">//调用sort函数 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种是最简单的形式，默认从小到大，那从大到小呢？嘿嘿，别着急，来看：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span>  <span class="comment">//自定义函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m&gt;n;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>],i,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+n,cmp); <span class="comment">//调用sort函数 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种是加一个自定义函数cmp，用于大小比较，从小到大时也可以自定义一个函数，但是没必要其实；</p><p>还有其他很多种形式，去about页面，有我的联系方式，给我发信息给你代码（嘻嘻嘻）；</p><p>可以去练习一下，请见<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1040" target="_blank" rel="noopener">杭电1040</a></p><h3 id="gcd-amp-lcm"><a href="#gcd-amp-lcm" class="headerlink" title="gcd &amp; lcm"></a>gcd &amp; lcm</h3><p>gcd模板其实已经写烂了，但是几个月没碰过编程了，难免会有些生疏，再来回顾一下；</p><p>lcm也很简单，两数乘积除以最大公约数；</p><h4 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h4><p>先看最原始的代码（我第一次写的代码）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">while</span>(b!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = a%b; </span><br><span class="line">a = b;</span><br><span class="line"> b = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; gcd(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三目运算法（这个超级简单）：</p><p>不会三目运算符的回C语言再学习一下哦~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !b?a:gcd(b,a%b); <span class="comment">//三目运算符</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; gcd(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lcm"><a href="#lcm" class="headerlink" title="lcm"></a>lcm</h4><p>lcm其实没啥好说的，用三目来说，直接看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !b?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (m*n)/gcd(m,n);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; lcm(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是超级简单，那就去练习一下：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2504" target="_blank" rel="noopener">杭电2504</a></p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>排列组合也遇到过，解决“有多少种”这类问题经常遇见，只不过，这类问题都很简单，一学就会；概念高中已经学</p><p>过了，这里就不多说了；</p><h4 id="排列A"><a href="#排列A" class="headerlink" title="排列A"></a>排列A</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,t,ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(m&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">m=t;</span><br><span class="line">t=n;</span><br><span class="line">n=m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=m;i&gt;=m-n+<span class="number">1</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">ans *= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span>(m&gt;n) <span class="built_in">cout</span> &lt;&lt; A(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; A(n,m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合C"><a href="#组合C" class="headerlink" title="组合C"></a>组合C</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&gt;=n-k+<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">    ans*=i;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    ans/=i;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span>(m&gt;n) <span class="built_in">cout</span> &lt;&lt; C(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; C(n,m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>快速幂这个算法可以用来计算那些次方很多数据很大的问题，有些问题会出现TLE，引入快速幂，很好得解决了这</p><p>个问题，它的时间复杂度为 O(log₂N)，上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">quick</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>,base = x;</span><br><span class="line"><span class="keyword">while</span>( y &gt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( y % <span class="number">2</span> )</span><br><span class="line">&#123;</span><br><span class="line">ans *= base;</span><br><span class="line">&#125;</span><br><span class="line">base *= base;</span><br><span class="line">y /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; quick(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个可以计算到2的62次方左右，因为long long的范围有限；</p><h3 id="大数相加（模拟）"><a href="#大数相加（模拟）" class="headerlink" title="大数相加（模拟）"></a>大数相加（模拟）</h3><p>这个挺有意思的题目，上大学之前刷题的时候就有人说，初学者做不出来“A+B”，当时我还笑了，“A+B”有什么难</p><p>的，一个输入一个输出不就完事，后来有人说，那你计算111….(100个1) + 222….(100个2)的值，我一想，不行</p><p>啊，int不够，long long不够，int64页不够，我就放弃了；再后来….咳，请看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大数相加</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m=<span class="number">1</span>,n=<span class="number">1</span>,i,j,L1,L2,k;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">1002</span>],b[<span class="number">1002</span>];</span><br><span class="line"><span class="keyword">int</span> num1[<span class="number">1002</span>],num2[<span class="number">1002</span>];</span><br><span class="line"><span class="built_in">memset</span>(num1,<span class="number">0</span>,<span class="keyword">sizeof</span>(num1));    <span class="comment">//数组清零 </span></span><br><span class="line"><span class="built_in">memset</span>(num2,<span class="number">0</span>,<span class="keyword">sizeof</span>(num2));    <span class="comment">//数组清零</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;                  <span class="comment">//输入数组 </span></span><br><span class="line">L1 = <span class="built_in">strlen</span>(a);  <span class="comment">//计算数组a的长度 </span></span><br><span class="line">L2 = <span class="built_in">strlen</span>(b); <span class="comment">//计算数组b的长度 </span></span><br><span class="line"><span class="keyword">for</span>(i=L1<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">num1[m] = a[i] - <span class="string">'0'</span>;   </span><br><span class="line">m++;   <span class="comment">//字符--&gt;数字 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=L2<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">num2[n] = b[i] - <span class="string">'0'</span>;    </span><br><span class="line">n++;  <span class="comment">//字符--&gt;数字 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">1002</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">k = i;</span><br><span class="line">num1[i] += num2[i];<span class="comment">// num1数组当成一个新的数组，重新赋值 </span></span><br><span class="line"><span class="keyword">if</span>(num1[i]&gt;<span class="number">9</span>)</span><br><span class="line">&#123;</span><br><span class="line">num1[i] = num1[i]%<span class="number">10</span>;<span class="comment">//判断是否超过10 超过进位 </span></span><br><span class="line">num1[++k] ++;<span class="comment">//下一位进 1 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1001</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(num1[i]!=<span class="number">0</span>) <span class="comment">//判断什么时候不为 0 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num1[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来啊，把数字转换成字符串的形式，这样的话，就很容易了；</p><p>学会了吗，去练习一下吧：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1002" target="_blank" rel="noopener">杭电1002</a></p><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>这个算法是过双创中心面试之后第一个讲解的算法，其实现在还是懵懵的；</p><p>二分查找法，其实是一种有序的查找方法，也称折半查找，如果是无序的则要先进行排序操作；</p><p>基本思想是：目标值通过与中间元素比较，可分为三种情况：</p><p>1、目标值与中间元素相等，查找结束；</p><p>2、目标值比中间元素大，则把后半部分的中间元素与目标值比较；</p><p>3、目标值比中间元素小，则把前半部分的中间元素与目标值比较；</p><p>这三步一直循环，直到找到答案为止；</p><p>适用情况：求最大值中的最小值、求最小值中的最大值；（听着很别扭，其实就是这样）</p><p>类似于数学里面的二分，思想差不多；</p><p>以一道题来举例：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4004" target="_blank" rel="noopener">杭电4004</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">500200</span>];</span><br><span class="line"><span class="keyword">int</span> L,n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//二分函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,cnt=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]-a[i<span class="number">-1</span>]&gt;x)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i]-t&gt;x)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            t=a[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt+<span class="number">1</span>&lt;=m)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid,i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;L&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">        a[<span class="number">0</span>]=<span class="number">0</span>,a[++n]=L;</span><br><span class="line">        sort(a,a+n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=L,res;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r) <span class="comment">//这里的小于等于千万不能忘记等于</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid=(l+r)/<span class="number">2</span>; <span class="comment">//分半</span></span><br><span class="line">            <span class="keyword">if</span>(check(mid)) <span class="comment">//取左</span></span><br><span class="line">            &#123;</span><br><span class="line">                res=mid;</span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//取右</span></span><br><span class="line">            &#123;</span><br><span class="line">            l=mid+<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题是不是太难了呀，不要紧，在给你一道简单的：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2199" target="_blank" rel="noopener">杭电2199</a></p><p>这题算是很简单的二分了，要是不会的话，回来看代码：</p><p>注意啊，这段代码里面的cin和cout要改成C语言的scanf和printf，不知为什么cin和cout过不去，可能因为保留的</p><p>小数位数吧，就很离谱；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">8</span>*x*x*x*x+<span class="number">7</span>*x*x*x+<span class="number">2</span>*x*x+<span class="number">3</span>*x+<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">double</span> l,r,m,n,mid;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">l=<span class="number">0</span>,r=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(f(<span class="number">0</span>)&gt;m||f(<span class="number">100</span>)&lt;m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"No solution!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(r-l &gt; <span class="number">0.000001</span>)</span><br><span class="line">&#123;</span><br><span class="line">   mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">   <span class="keyword">if</span>((f(mid)-m) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   r = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">l = mid;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">5</span>) &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串—String</title>
      <link href="/2020/03/01/chuan/"/>
      <url>/2020/03/01/chuan/</url>
      
        <content type="html"><![CDATA[<p>学完了栈与队列，应该都会了吧，今天来聊聊串；</p><a id="more"></a><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>串是由零个或多个字符组成的有限序列，又名叫字符串；</p><p>串中的字符数目n称为串的长度；</p><p>零个字符的串称为空串，可以用两双引号””表示，也可以用希腊字母Ø表示；</p><p>字符串，大家都不陌生对吧，学习C语言的时候就讲过了，编程题中常常遇到，这里就不多说了；</p><h3 id="串的比较"><a href="#串的比较" class="headerlink" title="串的比较"></a>串的比较</h3><p>这里串的比较在C语言也学过了，strcmp()函数，一会会讲到，就不多说；</p><h3 id="串的抽象数据类型"><a href="#串的抽象数据类型" class="headerlink" title="串的抽象数据类型"></a>串的抽象数据类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、StrAssign(S, *chars) <span class="comment">//生成一个值等于chars的串S</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、StrCopy(S,T) <span class="comment">//串T复制得串S</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、StrLength(S) <span class="comment">//串S的长度，即S中的元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、StrCat(S,T) <span class="comment">//串T连接在串S后面</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、SubString(Sub,S,pos,len) <span class="comment">//用Sub返回串S的第pos个字符起长度为len的子串</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、StrIndex(S,T) <span class="comment">//若串S中存在与串T相同的子串，则返回它在串S中第一次出现的位置，否则返回代表错误的值</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、StrInsert(S,pos,T) <span class="comment">//在串S的第pos个字符插入串T</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、StrDelete(S,pos,len) <span class="comment">//从串S中删除第pos个字符起长度为len的子串</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>、StrReplace(S,T,V) <span class="comment">//用串V替换串S中出现得到所有与T相等的不重叠子串</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>、StrEmpty(S) <span class="comment">//若串S为空串，则返回1，否则返回0</span></span><br><span class="line"></span><br><span class="line"><span class="number">11</span>、StrCompare(S,T) <span class="comment">//若S&gt;T，则返回值&gt;0,若S=T，则返回值=0,若S&lt;T，则返回值&lt;0</span></span><br><span class="line"></span><br><span class="line"><span class="number">12</span>、StrClear(S) <span class="comment">//将串S清空</span></span><br><span class="line"></span><br><span class="line"><span class="number">13</span>、DispStr(S) <span class="comment">//显示串S的所有字符</span></span><br></pre></td></tr></table></figure><h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><p>串的存储结构也是分为顺序存储结构和链式存储结构，重点讲顺序存储结构，即定长顺序串；</p><h4 id="结构代码"><a href="#结构代码" class="headerlink" title="结构代码"></a>结构代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> ch[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> Len;</span><br><span class="line">&#125;<span class="keyword">String</span>;</span><br></pre></td></tr></table></figure><h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrLength</span><span class="params">(<span class="keyword">String</span>* S)</span> <span class="comment">//求字符串S长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (S-&gt;ch[i] != <span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">S-&gt;Len = i;</span><br><span class="line"><span class="keyword">return</span> (S-&gt;Len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="建立新串"><a href="#建立新串" class="headerlink" title="建立新串"></a>建立新串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateStr</span><span class="params">(<span class="keyword">String</span>* S)</span> <span class="comment">//建立一个新串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">gets(S-&gt;ch);</span><br><span class="line">S-&gt;Len = StrLength(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求子串函数"><a href="#求子串函数" class="headerlink" title="求子串函数"></a>求子串函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SubString</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">String</span>* Sub, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span> <span class="comment">//求子串函数，用Sub返回串S的第pos个字符起长度为len的子串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;S-&gt;Len || len&lt;<span class="number">1</span> || len&gt;S-&gt;Len - pos + <span class="number">1</span>) <span class="comment">//范围错误</span></span><br><span class="line">&#123;</span><br><span class="line">Sub-&gt;Len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line">Sub-&gt;ch[j] = S-&gt;ch[pos + j - <span class="number">1</span>]; <span class="comment">//新串Sub赋值</span></span><br><span class="line">&#125;</span><br><span class="line">Sub-&gt;ch[j] = <span class="string">'\0'</span>; <span class="comment">//新串尾部加上字符串结束标志</span></span><br><span class="line">Sub-&gt;Len = len; <span class="comment">//规定长度</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除子串"><a href="#删除子串" class="headerlink" title="删除子串"></a>删除子串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrDelete</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">int</span> i, <span class="keyword">int</span> l)</span> <span class="comment">//删除子串，在S中删除第i开始连续l个字符</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (i + l - <span class="number">1</span> &gt; S-&gt;Len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"子串超界"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (k = i + l - <span class="number">1</span>; k &lt; S-&gt;Len; k++, i++) <span class="comment">//从第i位开始删除长度为l个字符</span></span><br><span class="line">&#123;</span><br><span class="line">S-&gt;ch[i - <span class="number">1</span>] = S-&gt;ch[k];</span><br><span class="line">&#125;</span><br><span class="line">S-&gt;Len = S-&gt;Len - l; <span class="comment">//长度-l</span></span><br><span class="line">S-&gt;ch[S-&gt;Len] = <span class="string">'\0'</span>; <span class="comment">//新串尾部加上字符串结束标志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入子串"><a href="#插入子串" class="headerlink" title="插入子串"></a>插入子串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrInsert</span><span class="params">(<span class="keyword">String</span> *S,<span class="keyword">String</span> *T,<span class="keyword">int</span> i)</span> <span class="comment">//串S中第i个字符插入子串T</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (i &gt; S-&gt;Len + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入位置错误"</span>)；</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(S-&gt;Len+T-&gt;Len&gt;MAXSIZE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"两串长度超过存储空间长度"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (k = S-&gt;Len - <span class="number">1</span>; k &gt;= i - <span class="number">1</span>; k--) <span class="comment">//将第i位开始的字符各向后移动T串长度</span></span><br><span class="line">&#123;</span><br><span class="line">S-&gt;ch[T-&gt;Len + k] = S-&gt;ch[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; T-&gt;Len; k++) <span class="comment">//将子串T插入到串S的第i位处</span></span><br><span class="line">&#123;</span><br><span class="line">S-&gt;ch[i + k - <span class="number">1</span>] = T-&gt;ch[k];</span><br><span class="line">&#125;</span><br><span class="line">S-&gt;Len = S-&gt;Len + T-&gt;Len; <span class="comment">//修改串S的长度</span></span><br><span class="line">S-&gt;ch[S-&gt;Len] = <span class="string">'\0'</span>; <span class="comment">//新串S尾部加上字符串结束标志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定位子串"><a href="#定位子串" class="headerlink" title="定位子串"></a>定位子串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrIndex</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">String</span>* T)</span> <span class="comment">//串的定位函数，若串S中存在与串T相同的子串，则返回它在串S中第一次出现的位置(第几个字符，不是下标)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k;</span><br><span class="line"><span class="keyword">while</span> (i &lt; S-&gt;Len &amp;&amp; j &lt; T-&gt;Len) <span class="comment">//当两串指针没指向该串尾时进行比较</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;ch[i] == T-&gt;ch[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i = i - j + <span class="number">1</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= T-&gt;Len) <span class="comment">//串S中有串T</span></span><br><span class="line">&#123;</span><br><span class="line">k = i - T-&gt;Len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">k = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCompare</span><span class="params">(<span class="keyword">String</span>* S1, <span class="keyword">String</span>* S2)</span><span class="comment">//判断两个串是否相等</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (S1-&gt;ch[i] != <span class="string">'\0'</span> &amp;&amp; S2-&gt;ch[i] != <span class="string">'\0'</span>) <span class="comment">//当两串没到串尾部时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S1-&gt;ch[i] != S2-&gt;ch[i]) <span class="comment">//两串对应位置的字符是否相同</span></span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>; <span class="comment">//标志置为1</span></span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//结束循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i++; <span class="comment">//计数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; S1-&gt;Len == S2-&gt;Len) <span class="comment">//两串长度相同且所有字符都相同，两串相等</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> S1-&gt;ch[i] - S2-&gt;ch[i]; <span class="comment">//返回对应第一个不相同位置字符ASCII码差值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCat</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">String</span>* T)</span> <span class="comment">//连接函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, flag;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;Len + T-&gt;Len &lt;= MAXSIZE) <span class="comment">//连接后串长小于MAXSIZE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = S-&gt;Len; i &lt; S-&gt;Len + T-&gt;Len; i++)</span><br><span class="line">&#123;</span><br><span class="line">S-&gt;ch[i] = T-&gt;ch[i - S-&gt;Len]; <span class="comment">//赋值连接</span></span><br><span class="line">&#125;</span><br><span class="line">S-&gt;ch[i] = <span class="string">'\0'</span>;</span><br><span class="line">S-&gt;Len += T-&gt;Len; <span class="comment">//长度相加</span></span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (S-&gt;Len &lt; MAXSIZE) <span class="comment">//连接后串长大于MAXSIZE，但串S长度小于MAXSIZE，连接后串T部分字符序列被舍弃</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = S-&gt;Len; i &lt; MAXSIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">S-&gt;ch[i] = T-&gt;ch[i - S-&gt;Len];</span><br><span class="line">&#125;</span><br><span class="line">S-&gt;Len = MAXSIZE;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//串S的长度等于MAXSIZE，串T不被连接</span></span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子串替换"><a href="#子串替换" class="headerlink" title="子串替换"></a>子串替换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrReplace</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">String</span>* T, <span class="keyword">String</span>* V)</span> <span class="comment">//子串替换，用串V替换串S中出现得到所有与T相等的不重叠子串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, m, n, p, q;</span><br><span class="line">n = S-&gt;Len;</span><br><span class="line">m = T-&gt;Len;</span><br><span class="line">q = V-&gt;Len;</span><br><span class="line">p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">i = StrIndex(S, T); <span class="comment">//调用定位函数得到子串T在子串S的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">-1</span>) <span class="comment">//当主串S有该子串T时</span></span><br><span class="line">&#123;</span><br><span class="line">StrDelete(S, i, m); <span class="comment">//删除子串T</span></span><br><span class="line">StrInsert(S, V, i); <span class="comment">//插入子串V</span></span><br><span class="line">p = i + q;</span><br><span class="line">S-&gt;Len = S-&gt;Len + q - m; <span class="comment">//修改主串S的长度</span></span><br><span class="line">n = S-&gt;Len;+</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((p &lt;= n - m + <span class="number">1</span>) &amp;&amp; (i != <span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>串这部分内容呢比较简单，后面还有广义表和KMP算法，这里先不讲了；</p><p>下周直接学树；</p><p>Bye Bye~</p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2月29日的深更半夜</title>
      <link href="/2020/02/29/2-yue-29-ri/"/>
      <url>/2020/02/29/2-yue-29-ri/</url>
      
        <content type="html"><![CDATA[<p>这篇博客呢就闲聊一点吧，反正今天也是一个特殊的日子；</p><a id="more"></a><p>​        寒假到今天为止50天了，因为疫情原因，大把好时光就这么浪费了，真是难过又觉得可惜，先自我作个总结吧：</p><p>​        从寒假第一天开始，玩了一个多星期的王者荣耀（自己很不务正业），想着自己还有任务，赶紧学习，还来得及其实，但是吧，我这人，虽说自觉性很高，但是吧，想耐住性子学习还真不容易；</p><p>​        况且，我们任务学习汇编和PHP。这种底层语言真的是很无聊，学着就想吐；刚开始接触PHP的时候感觉很好玩，但是学了一段时间，发现，它的语法还有格式对我这种强迫症来讲，算了算了吧，实在是驾驭不了；</p><p>​        我就重点学习汇编，汇编说实话，更麻烦，枯燥无味，很繁琐，可能受C，C++的影响，底层语言真的是无话可说，顿时感觉高级语言好玩；</p><p>​        讲真的，想过放弃，但是某一天，堆堆给了我XCTF的链接，我一进去，哇塞，好酷的页面，瞬间又有了学习的动力，我就注册账号，发现题目不是想象的那样，太难了；但是没关系，谁能一开始就觉得简单呢，我就边玩边学，耐得住性子，坐在写字桌前面看书看视频，开头难但是还得学好。。。</p><p>​        第一次做出来一道CTF的题目的时候，我那心情，别提有多高兴，题目考验的不仅仅是思维能力，还有计算能力，使用工具的能力，印象最深的是一道P二维码的题目，为了做它，新学了一点PS基础，P了一个晚上还没出来，心态没了；</p><p>​        再后来，老师收集学习进度说还得整blog（一提到blog我就来气），看着教程做都做不出来，多亏了柠檬大佬，才有了今天在这里写似日记非日记的东西（嘻嘻嘻）；</p><p>​        最近，又得学习Python，还得装虚拟机，虚拟机更是麻烦，所有的错误情况我都遇见了估计，没有比我还倒霉的啦，现在还没装，没心情了，想着尽快把Python基础学完才行，才能进行下一个学习计划；</p><p>、</p><p>、</p><p>、</p><p>长路漫漫，为了拿offer，为了将来，加油干<del>~</del></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列—Stack &amp; Queue</title>
      <link href="/2020/02/26/zhan-yu-dui-lie/"/>
      <url>/2020/02/26/zhan-yu-dui-lie/</url>
      
        <content type="html"><![CDATA[<p>学习完线性表，今天开始学习栈与队列；</p><a id="more"></a><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>栈是限定仅在表尾进行插入和删除操作的线性表；</p><p>允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈，栈又称为后进先出线性表，</p><p>简称LIFO结构；</p><h3 id="栈的抽象数据类型——基本操作-入栈-出栈"><a href="#栈的抽象数据类型——基本操作-入栈-出栈" class="headerlink" title="栈的抽象数据类型——基本操作( 入栈 出栈 )"></a>栈的抽象数据类型——基本操作( 入栈 出栈 )</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、InitStack(*S) <span class="comment">//初始化操作，建立一个空栈</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、DestroyStack(*S) <span class="comment">//若栈存在，则销毁它</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、ClearStack(*S) <span class="comment">//将栈清空</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、StackEmpty(*S) <span class="comment">//若栈为空，返回true，否则返回false</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、GetTop(S, *e) <span class="comment">//若栈存在且非空，用e返回S的栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、Push(*S, e) <span class="comment">//若栈S存在，插入新元素e到栈S中并成为栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、Pop(*S, *e) <span class="comment">//删除栈S中栈顶元素，并用e返回其值</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、StackLength(S) <span class="comment">//返回栈S的元素个数</span></span><br></pre></td></tr></table></figure><h3 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h3><h4 id="结构代码"><a href="#结构代码" class="headerlink" title="结构代码"></a>结构代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DataType data[MAXSIZE]; <span class="comment">//栈的元素最大个数</span></span><br><span class="line"><span class="keyword">int</span> top; <span class="comment">//用于栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><h4 id="初始化栈"><a href="#初始化栈" class="headerlink" title="初始化栈"></a>初始化栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack* S)</span> <span class="comment">//初始化栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S-&gt;top = <span class="number">-1</span>; <span class="comment">//初始化栈为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断栈是否已满"><a href="#判断栈是否已满" class="headerlink" title="判断栈是否已满"></a>判断栈是否已满</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackFull</span><span class="params">(SqStack* S)</span> <span class="comment">//判断栈是否已满</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == MaxSIZE - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(SqStack* S)</span> <span class="comment">//判断栈是否为空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(SqStack* S, DataType e)</span> <span class="comment">//进栈操作 插入元素e为新的栈顶元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (StackFull(S)) <span class="comment">//栈满</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">S-&gt;top++; <span class="comment">//栈顶指针增加1</span></span><br><span class="line">S-&gt;data[S-&gt;top] = e; <span class="comment">//新插入元素赋值给栈顶空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(SqStack* S, DataType* e)</span> <span class="comment">//出栈操作 若栈不为空，则删除栈顶元素，用e返回其值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (StackEmpty(S)) <span class="comment">//栈空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">*e = S-&gt;data[S-&gt;top]; <span class="comment">//将要删除的元素赋值给e</span></span><br><span class="line">S-&gt;top--; <span class="comment">//栈顶指针减少1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h3><h4 id="结构代码-1"><a href="#结构代码-1" class="headerlink" title="结构代码"></a>结构代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DataType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure><h4 id="初始化栈-1"><a href="#初始化栈-1" class="headerlink" title="初始化栈"></a>初始化栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkStack* <span class="title">InitStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStack* S;</span><br><span class="line">S = <span class="literal">NULL</span>; <span class="comment">//初始化栈为空</span></span><br><span class="line"><span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断栈是否为空-1"><a href="#判断栈是否为空-1" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EmptyStack</span><span class="params">(LinkStack* S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进栈-1"><a href="#进栈-1" class="headerlink" title="进栈"></a>进栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(LinkStack* S, DataType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStack* p = (LinkStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">p-&gt;data = e; <span class="comment">//e放入新节点的数据域</span></span><br><span class="line">p-&gt;next = S; <span class="comment">//新节点插入链表表头之前</span></span><br><span class="line">S = p; <span class="comment">//新节点作为栈顶</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(LinkStack* S, DataType* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStack* p;</span><br><span class="line"><span class="keyword">if</span> (EmptyStack(S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">*e = S-&gt;data; <span class="comment">//栈顶元素赋值给e</span></span><br><span class="line">p = S; <span class="comment">//p节点指向原栈顶S</span></span><br><span class="line">S = S-&gt;next; <span class="comment">//原栈顶S指向其下一个节点</span></span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">//释放原栈顶空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">(LinkStack* S, DataType* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (EmptyStack(S)) <span class="comment">//栈为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">*e = S-&gt;data; <span class="comment">//栈顶元素赋给变量e</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历栈"><a href="#遍历栈" class="headerlink" title="遍历栈"></a>遍历栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowStack</span><span class="params">(LinkStack* S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStack* p = S;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈为空\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表；</p><p>队列是一种先进先出的线性表，简称FIFO；允许插入的一端称为队尾，允许删除的一端称为队头；</p><h3 id="队列的抽象数据类型——基本操作"><a href="#队列的抽象数据类型——基本操作" class="headerlink" title="队列的抽象数据类型——基本操作"></a>队列的抽象数据类型——基本操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、InitQueue(*Q) <span class="comment">//初始化操作，建立一个空队列</span></span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>、DestroyQueue(*Q) <span class="comment">//若队列Q存在，则销毁</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>、ClearQueue(*Q) <span class="comment">//将队列Q清空</span></span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>、QueueEmpty(Q) <span class="comment">//若队列为空，返回true，否则返回false</span></span><br><span class="line">    </span><br><span class="line"><span class="number">5</span>、GetHead(Q,*e) <span class="comment">//若队列存在且非空，用e返回Q的队头元素</span></span><br><span class="line">    </span><br><span class="line"><span class="number">6</span>、EnQueu(*Q,e) <span class="comment">//若队列存在，则插入e于Q，并成为队尾元素</span></span><br><span class="line">    </span><br><span class="line"><span class="number">7</span>、DeQueue(*Q,*e) <span class="comment">// 删除队列Q中队头元素，并用e返回其值</span></span><br><span class="line">    </span><br><span class="line"><span class="number">8</span>、QueueLength(Q) <span class="comment">//返回队列Q中元素个数</span></span><br></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><h4 id="队列顺序存储的不足"><a href="#队列顺序存储的不足" class="headerlink" title="队列顺序存储的不足"></a>队列顺序存储的不足</h4><p>与栈不同的是，队列的出列是在队头，那就意味着，队列的所有元素都得移动，以保证下标为0的位置不为空，此</p><p>时间复杂度为O(n);</p><p>为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，</p><p>rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列；</p><p>假溢出：说白了就是数组末尾元素已满，再向后加就越界，而队列前面还有空位的现象（0,1,2….空着）；</p><h4 id="循环队列定义"><a href="#循环队列定义" class="headerlink" title="循环队列定义"></a>循环队列定义</h4><p>头尾相接顺序存储结构称为循环队列；</p><p>设队列最大长度为QueueSize，那么：</p><p>队列满的条件为(rear+1) % QueueSize == front ;</p><p>队空条件为front == rear ;</p><p>队列长度计算公式为(rear-front+QueueSize) % QueueSize ; (自己推导式子很简单)</p><h4 id="循环队列顺序存储结构"><a href="#循环队列顺序存储结构" class="headerlink" title="循环队列顺序存储结构"></a>循环队列顺序存储结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DataType data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> front; <span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">int</span> rear; <span class="comment">//尾指针，若队列不变，指向队列尾元素的下一个位置</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><h4 id="队列初始化"><a href="#队列初始化" class="headerlink" title="队列初始化"></a>队列初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span> <span class="comment">//初始化一个对列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q-&gt;front = <span class="number">0</span>;</span><br><span class="line">Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="队列长度"><a href="#队列长度" class="headerlink" title="队列长度"></a>队列长度</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span> <span class="comment">//求队列长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (Q.rear - Q.front + MAXSIZE) % MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(SqQueue* Q, DataType e)</span> <span class="comment">//若队列未满则e入列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXSIZE == Q-&gt;front) <span class="comment">//队列已满</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Q-&gt;data[Q-&gt;rear] = e; <span class="comment">//e赋值给队尾</span></span><br><span class="line">Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZE; <span class="comment">//rear指针后移一个位置，若到最后则转到数组头部</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(SqQueue* Q, DataType* e)</span> <span class="comment">//若队列不空则删除队头，并用e返回其值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;near) <span class="comment">//队列为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">*e = Q-&gt;data[Q-&gt;front]; <span class="comment">//将队头元素赋值给e</span></span><br><span class="line">Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXSIZE; <span class="comment">//front指针向后移一位置，若到最后则转到数组头部</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h3><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列；</p><h4 id="链式队列存储结构"><a href="#链式队列存储结构" class="headerlink" title="链式队列存储结构"></a>链式队列存储结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">qnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DataType data; <span class="comment">//节点的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qnode</span>* <span class="title">next</span>;</span> <span class="comment">//节点的指针域</span></span><br><span class="line">&#125;LinkListQ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LinkListQ* front, * rear; <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><h4 id="队列初始化-1"><a href="#队列初始化-1" class="headerlink" title="队列初始化"></a>队列初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkQueue* <span class="title">InitQueue</span><span class="params">()</span> <span class="comment">//队列初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkQueue* Q;</span><br><span class="line">LinkListQ* p;</span><br><span class="line">Q = (LinkQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkQueue)); <span class="comment">//头指针所指节点</span></span><br><span class="line">p = (LinkListQ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkListQ)); <span class="comment">//头节点</span></span><br><span class="line">Q-&gt;front = p; <span class="comment">//Q指针所指的front指针指向p</span></span><br><span class="line">Q-&gt;rear = p; <span class="comment">//Q指针所指的rear指针指向p</span></span><br><span class="line"><span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(LinkQueue* Q, DataType e)</span> <span class="comment">//插入e于队尾</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkListQ* s;</span><br><span class="line">s = (LinkListQ)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkListQ)); <span class="comment">//分配内存空间</span></span><br><span class="line">s-&gt;data = e; <span class="comment">//将e存入新节点的数据域</span></span><br><span class="line">s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">Q-&gt;rear-&gt;next = s; <span class="comment">//将新节点插入链队之后</span></span><br><span class="line">Q-&gt;rear = s; <span class="comment">//队尾指针指向队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(LinkQueue* Q, DataType* e)</span> <span class="comment">//删除队头，用e返回其值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkListQ* p;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) <span class="comment">//队空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">p = Q-&gt;front-&gt;next; <span class="comment">//p指向队头元素</span></span><br><span class="line">*e = p-&gt;data; <span class="comment">//队头元素的值赋给e</span></span><br><span class="line">Q-&gt;front-&gt;next = p-&gt;next; <span class="comment">//原队头节点后继p-&gt;next赋给头节点后继</span></span><br><span class="line"><span class="keyword">if</span> (Q-&gt;rear == p)<span class="comment">/*p-&gt;next==NULL*/</span> <span class="comment">//队头等于队尾，删除后将rear指向头节点</span></span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;rear = Q-&gt;front; <span class="comment">//此时队空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于循环队列和链队列的比较，可以从两方面，从时间上看，它们基本操作都是常数时间，都为O(1)，从空间看，</p><p>循环队列必须有一个固定的长度，就有了存储元素个数和空间资源浪费的问题，而链队列不存在这个问题；尽管需</p><p>要一个指针域，需要空间，但是可以接受，所以空间上链队列更加灵活；</p><p>总的来说，在可以确定队列长度最大值的情况下，建议使用循环队列，无法估计队列长度时则用链队列；</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表—Linear List</title>
      <link href="/2020/02/18/xian-xing-biao/"/>
      <url>/2020/02/18/xian-xing-biao/</url>
      
        <content type="html"><![CDATA[<p>今天开始学习线性表，这也算是进入数据结构的世界了；</p><a id="more"></a><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>1、定义：n(n≥0)个数据元素的有限序列；</p><p>2、线性表是一种最常用且最简单的数据结构，含有n个元素的线性表是一个数据结构；</p><p>3、List = (D,R)  ——&gt;  D是data数据，R是relation关系；</p><h3 id="前驱后继"><a href="#前驱后继" class="headerlink" title="前驱后继"></a>前驱后继</h3><p>若将线性表记为a1,a2,a3……ai-1,ai,ai+1……an,则称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当</p><p>i=1,2,3…n-1时，ai有且仅有一个直接后继，当i=2,3,4…n时，ai有且仅有一个直接前驱；</p><p>所以，线性表的元素的个数n(n≥0)定义为线性表的长度，当n=0时，称为空表；</p><h3 id="线性表的抽象数据类型——基本操作-增-删-查-取-空-长"><a href="#线性表的抽象数据类型——基本操作-增-删-查-取-空-长" class="headerlink" title="线性表的抽象数据类型——基本操作( 增 删 查 取 空 长 )"></a>线性表的抽象数据类型——基本操作( 增 删 查 取 空 长 )</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、InitList(*L) <span class="comment">//初始化,建立一个新的线性表L；</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、ListEmpty(L) <span class="comment">//线性表为空，返回true，否则返回false；</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、ListLength(L) <span class="comment">//求长度，返回线性表中元素的个数；</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、GetElem(L,i,*e) <span class="comment">//将线性表L中第i个数据元素赋值给e；</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、LocateElem(L,e) <span class="comment">//在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功，否则，返回0表示失败；</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、ListInsert(*L,i,e) <span class="comment">//在线性表L中第i个位置插入新的数据e，表长+1；</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、ListDelete(*L,i,e) <span class="comment">//删除线性表L中第i个数据元素，e返回其值，表长-1；</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、ClearList(*L) <span class="comment">//将线性表清空；</span></span><br></pre></td></tr></table></figure><h2 id="线性表的顺序存储结构——顺序表"><a href="#线性表的顺序存储结构——顺序表" class="headerlink" title="线性表的顺序存储结构——顺序表"></a>线性表的顺序存储结构——顺序表</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>线性表的顺序存储结构，指的是用一段地址连续的储存单元依次储存线性表的数据元素；</p><h3 id="顺序储存方式"><a href="#顺序储存方式" class="headerlink" title="顺序储存方式"></a>顺序储存方式</h3><p>先来看看结构代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 20  <span class="comment">//储存空间初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data[MaxSize];</span><br><span class="line"><span class="keyword">int</span> length;  <span class="comment">//线性表当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h3 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i, ElemType* e)</span> <span class="comment">//获得元素——&gt;e返回L中第i个数据元素的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L.length == <span class="number">0</span> || i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">*e = L.data[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(SqList* L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">//插入操作——&gt;在L中第i个位置之前插入新的数据元素e，L的长度加1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;length == MaxSize) <span class="comment">//线性表已满</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length + <span class="number">1</span>) <span class="comment">//i不在范围内</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt;= L-&gt;length) <span class="comment">//插入的元素不在表尾</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (k = L-&gt;length - <span class="number">1</span>; k &gt;= i - <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">L-&gt;data[k + <span class="number">1</span>] = L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;data[i - <span class="number">1</span>] = e; <span class="comment">//新元素插入</span></span><br><span class="line">L-&gt;length++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(SqList* L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">//删除操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;length == <span class="number">0</span>) <span class="comment">//线性表为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length) <span class="comment">//删除位置不正确</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">*e = L-&gt;data[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (i &lt; L-&gt;length) <span class="comment">//删除不是最后位置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (k = i; k &lt; L-&gt;length; k++) <span class="comment">//删除位置后继元素前移</span></span><br><span class="line">&#123;</span><br><span class="line">L-&gt;data[k - <span class="number">1</span>] = L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;length--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>1、优点：</p><p>①无需为表中元素之间的逻辑关系增加额外的储存空间；</p><p>②可以快速的存取表中任意位置的元素；</p><p>2、缺点：</p><p>①插入和删除操作需要移动大量元素；</p><p>②当线性表长度变化较大时，难以确定储存空间的容量；</p><p>③造成储存空间的“碎片”；</p><h2 id="线性表的链式储存结构——链表"><a href="#线性表的链式储存结构——链表" class="headerlink" title="线性表的链式储存结构——链表"></a>线性表的链式储存结构——链表</h2><p>链表在之前的博客里面已经整理了一部分，在这里再整理一遍吧；</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>先定义一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">LinkList</span>;</span> <span class="comment">//定义LinkList</span></span><br></pre></td></tr></table></figure><h4 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType* e)</span> <span class="comment">//用e返回L中第i个数据元素的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p;   <span class="comment">//声明指针p</span></span><br><span class="line">p = L-&gt;next;  <span class="comment">//p指向链表L的第一个节点</span></span><br><span class="line">j = <span class="number">1</span>;    <span class="comment">//j为计数器</span></span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; j &lt; i) <span class="comment">//p不为空且计数器j还没有等于i时，循环继续</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next; <span class="comment">//p指向下一个节点</span></span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!p || j &gt; i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//第i个节点不存在</span></span><br><span class="line">&#125;</span><br><span class="line">*e = p-&gt;data;  <span class="comment">//取第i个节点的数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(LinkList* L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">//在L的第i个节点之前插入元素e，L的长度加1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p,s;</span><br><span class="line">p = *L;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; j &lt; i) <span class="comment">//寻找第i-1个节点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!p || j &lt; i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//第i个节点不存在</span></span><br><span class="line">&#125;</span><br><span class="line">s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//生成新节点</span></span><br><span class="line">s-&gt;data = e;</span><br><span class="line">s-&gt;next = p-&gt;next;  <span class="comment">//将p的后继节点赋值给s的后继</span></span><br><span class="line">p-&gt;next = s;  <span class="comment">//将s赋值给p的后继</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkDelete</span><span class="params">(LinkList* L, <span class="keyword">int</span> i, ElemType* e)</span> <span class="comment">//删除L中的第i个节点，并用e返回其值，L的长度减1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p, q;</span><br><span class="line">p = *L;</span><br><span class="line">j = i;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i) <span class="comment">//遍历寻找第i-1个节点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;next) || j &gt; i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//第i个节点不存在</span></span><br><span class="line">&#125;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next; <span class="comment">//将q的后继赋值给p的后继</span></span><br><span class="line">*e = q-&gt;data;   <span class="comment">//将q节点中的数据给e</span></span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h4><h5 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListHead</span><span class="params">(LinkList* L, <span class="keyword">int</span> n)</span> <span class="comment">//随机产生n个元素的值，建立带表头节点的单链线性表L（头插法）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList o;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">srand(time(<span class="number">0</span>));  <span class="comment">//初始化随机种子</span></span><br><span class="line">*L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">(*L)-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//先建立一个带头结点的单链表</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//生成新节点</span></span><br><span class="line">p-&gt;data = rand() % <span class="number">100</span> + <span class="number">1</span>;  <span class="comment">//随机生成100以内的数字</span></span><br><span class="line">p-&gt;next = (*L)-&gt;next;</span><br><span class="line">(*L)-&gt;next = p;   <span class="comment">//插入到表头</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListTail</span><span class="params">(LinkList* L, <span class="keyword">int</span> n)</span><span class="comment">//随机产生n个元素的值，建立带表头节点的单链线性表L（尾插法）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList p, r;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">srand(time(<span class="number">0</span>));</span><br><span class="line">*L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">r = *L;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//生成新节点</span></span><br><span class="line">p-&gt;data = rand() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">r-&gt;next = p;  <span class="comment">//将表尾终端节点的指针指向新节点</span></span><br><span class="line">r = p;  <span class="comment">//将当前的新节点定义为表尾终端节点</span></span><br><span class="line">&#125;</span><br><span class="line">r-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//表示当前链表结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清空链表"><a href="#清空链表" class="headerlink" title="清空链表"></a>清空链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ClearList</span><span class="params">(LinkList* L)</span> <span class="comment">//单链表的整表删除，将L置为空表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList p, q;</span><br><span class="line">p = (*L)-&gt;next; <span class="comment">//p指向第一个节点</span></span><br><span class="line"><span class="keyword">while</span> (p)  <span class="comment">//没到表尾</span></span><br><span class="line">&#123;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = q;</span><br><span class="line">&#125;</span><br><span class="line">(*L)-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//头结点指针域为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h4><p>1、存储分配方式</p><p>​        ①顺序存储结构一般用一段连续的存储单元依次存储线性表的数据元素</p><p>​        ②单链表采用链式存储结构，用一组任意的存储大单元存放线性表的元素</p><p>2、时间性能</p><p>①查找</p><p>ⅰ顺序存储结构O(1)</p><p>ⅱ单链表O(n)</p><p>②插入和删除</p><p>​        ⅰ顺序存储结构需要平均移动表长一半的元素，时间为o(n)</p><p>​        ⅱ单链表在线出某位置的指针后，插入和删除时间仅为o(1)</p><p>③空间性能</p><p>​        ⅰ顺序存储结构需要预分配存储空间，分大了，浪费，分小了，易发生上溢</p><p>​        ⅱ单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制</p><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>用数组描述的链表叫做静态链表 ；</p><p>具体描述：首先让数组的两个元素都是由两个数据域组成，data和cur；也就是说，数组的每个下标都对应一个</p><p>data和cur；数据域data，用来存放数据元素,也就是通常我们要处理的数据；而cur相当于链表中的next指针，存</p><p>放该元素的后继在数组中的下标，我们把cur叫做游标；</p><p>小注：这里我理解的游标就是next那根链，元素的游标指向下一个数值的下标；;</p><h4 id="静态链表存储结构"><a href="#静态链表存储结构" class="headerlink" title="静态链表存储结构"></a>静态链表存储结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000 <span class="comment">// 假设链表最大长度是1k</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="keyword">int</span> cur; <span class="comment">//游标，为0时表示无指向</span></span><br><span class="line">&#125;StaticLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure><h4 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h4><p>0-998游标从1-999，最后一个游标为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitLink</span><span class="params">(StaticLinkList space)</span> <span class="comment">//将一位数组space中各分量链成一备用链表，space[0].cur为头指针，"0"表示空指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">space[i].cur = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">space[MAXSIZE - <span class="number">1</span>].cur = <span class="number">0</span>; <span class="comment">//目前静态链表为空，最后一个元素的cur为0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><p>​    我们通常把未使用的数组元素成为备用链表；</p><p>​    数组的第一个元素，即下标为0的那个元素的cur就存放备用链表的第一个节点的下标；</p><p>​    数组的最后一个元素，即下标为MAXSIZE-1的cur则存放第一个有数值的元素的下标，相当于头节点的作用；</p><h4 id="获取链表中元素的个数"><a href="#获取链表中元素的个数" class="headerlink" title="获取链表中元素的个数"></a>获取链表中元素的个数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = L[MAXSIZE - <span class="number">1</span>].cur; <span class="comment">//最后一个元素的游标，从头循环计数</span></span><br><span class="line"><span class="keyword">while</span> (i) <span class="comment">//循环计数，找到空闲分量即停止循环</span></span><br><span class="line">&#123;</span><br><span class="line">i = L[i].cur; </span><br><span class="line">j++;  <span class="comment">//计数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态链表的插入操作"><a href="#静态链表的插入操作" class="headerlink" title="静态链表的插入操作"></a>静态链表的插入操作</h4><h5 id="获得空闲分量的下标"><a href="#获得空闲分量的下标" class="headerlink" title="获得空闲分量的下标"></a>获得空闲分量的下标</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SSL</span><span class="params">(StaticLinkList space)</span> <span class="comment">//若备用空间链表为空，则返回分配的节点下标，否则返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = space[<span class="number">0</span>].cur; <span class="comment">//当前数组第一个元素cur存的值，就是要返回的第一个备用空闲的下标</span></span><br><span class="line"><span class="keyword">if</span> (space[<span class="number">0</span>].cur)</span><br><span class="line">&#123;</span><br><span class="line">space[<span class="number">0</span>].cur = space[i].cur; <span class="comment">// 由于要拿出一个分量来使用，所以我们就得把它的下一个分量用来做备用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">// 在L中第i个元素之前插入新的数据元素e</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j, k, l;</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>;  <span class="comment">//k是最后一个元素的下标</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;Listlength(L) + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">j = Malloc_SSL(L);  <span class="comment">//获得空闲分量的下标</span></span><br><span class="line"><span class="keyword">if</span> (j)</span><br><span class="line">&#123;</span><br><span class="line">L[j].data = e; <span class="comment">//将数值赋值给此分量的data</span></span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; l++)  <span class="comment">//找到第i个元素之前的位置</span></span><br><span class="line">&#123;</span><br><span class="line">k = L[k].cur;</span><br><span class="line">&#125;</span><br><span class="line">L[j].cur = L[k].cur;  <span class="comment">//把第i个元素之前的cur赋值给新元素的cur</span></span><br><span class="line">L[k].cur = j;  <span class="comment">//把新元素的下标赋值给第i个元素之前元素的cur</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态链表的删除操作"><a href="#静态链表的删除操作" class="headerlink" title="静态链表的删除操作"></a>静态链表的删除操作</h4><h5 id="回收节点"><a href="#回收节点" class="headerlink" title="回收节点"></a>回收节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SSL</span><span class="params">(StaticLinkList space,<span class="keyword">int</span> k)</span><span class="comment">//将下标为k的空闲节点回收到备用链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">space[k].cur = space[<span class="number">0</span>].cur; <span class="comment">//把第一个元素cur值赋给要删除的分量cur</span></span><br><span class="line">space[<span class="number">0</span>].cur = k; <span class="comment">//把要删除的分量下标赋给第一个元素的cur</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i)</span> <span class="comment">// 删除L中第i个元素e</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j, k;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;ListLength(L))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">k = L[k].cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// j &gt; k</span></span><br><span class="line">j = L[k].cur;  <span class="comment">//L[k].cur指向删除元素的下标，赋值给j</span></span><br><span class="line">L[k].cur = L[j].cur;  <span class="comment">//被删除元素的游标赋值给前一个元素的游标，实现连接</span></span><br><span class="line">Free_SSL(L, j); <span class="comment">//回收</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态链表优缺点"><a href="#静态链表优缺点" class="headerlink" title="静态链表优缺点"></a>静态链表优缺点</h4><p>1、优点：</p><p>​        ●在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作</p><p>需要移动大量元素的缺点</p><p>2、缺点：</p><p>​        ●没有解决连续存储分配带来的表长难以确定的问题</p><p>​        ●失去了顺序存储结构随机存取的特性</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>循环链表——首尾相连的链表；</p><p>将单链表中终端节点的指针端由空指针改为指向头节点，就使整个单链表形成一个环。这种头尾相接的单链表称为</p><p>单循环链表，简称循环链表；</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>循环链表中，从任一节点出发都可以访问到表中所有节点，在单链表中，必须从头指针开始，否则无法访问到该节</p><p>点之前的其他节点；</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>双向链表是在单链表的每个节点中，再设置一个指向其前驱节点的指针域，前驱后继方向都能遍历；</p><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>* <span class="title">prior</span>;</span>  <span class="comment">//直接前驱指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>* <span class="title">next</span>;</span>  <span class="comment">//直接后继指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>显然，与单链表相比，多了一个直接前驱；</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一章节是线性表，线性表对于以后学习的数据结构会有很大作用；</p><p>选择使用哪种线性表，结合情况再定，各有利弊；</p><p>下一章学习栈与队列，不见不散；</p><p>Bye~~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度</title>
      <link href="/2020/02/18/shi-jian-fu-za-du/"/>
      <url>/2020/02/18/shi-jian-fu-za-du/</url>
      
        <content type="html"><![CDATA[<p>今天开始学习数据结构，一边学习一边整理，第一个要学的是时间复杂度；</p><a id="more"></a><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>定义：算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))(T(n)是语句总的执行次数)，它表示随问</p><p>题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。</p><p>其中f(n)是问题的规模n的某个函数；</p><h4 id="推导大O阶方法"><a href="#推导大O阶方法" class="headerlink" title="推导大O阶方法"></a>推导大O阶方法</h4><p>1、用常数1取代运行时间中的所有加法常数；</p><p>2、在修改后的运行次数函数中，只保留最高阶项；</p><p>3、如果最高阶项存在且不是1，则去除与这个项相乘的常数；</p><p>得到的的结果就是大O阶；</p><h4 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h4><p>常数阶    ——&gt;    O(1)</p><p>线性阶    ——&gt;    O(n)</p><p>平方阶    ——&gt;    O(n^2)</p><p>对数阶    ——&gt;    O(logn)</p><p>nlogn阶  ——&gt;    O(nlogn)</p><p>立方阶    ——&gt;    O(n^3)</p><p>指数阶    ——&gt;    O(2^n)</p><h4 id="常见的时间复杂度所耗时间的大小排列"><a href="#常见的时间复杂度所耗时间的大小排列" class="headerlink" title="常见的时间复杂度所耗时间的大小排列"></a>常见的时间复杂度所耗时间的大小排列</h4><p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>算法的时间复杂度内容不多，很好理解，从下一章开始就将进入代码的世界；</p><p>拜拜啦~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表—Link List</title>
      <link href="/2020/02/18/lian-biao/"/>
      <url>/2020/02/18/lian-biao/</url>
      
        <content type="html"><![CDATA[<p>链表是C语言中非常难理解的一个知识点，可以说是比指针还难学的东西。在学习数据结构的时候常常会用到，所</p><p>以想来想去有必要整理一波；</p><a id="more"></a><p>链表种类很多种，有单向链表，双向链表，空头链表，非空头链表，循环链表，非循环链表；</p><p>这里小浩只学了单向空头和单向非空头链表，先整理这两种，以后学完再添加；</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>链表实际上是线性表的链式存储结构，与数组不同的是，它是用一组任意的存储单元来存储线性表中的数据，存储</p><p>单元不一定是连续的；</p><p>且链表的长度不是固定的，链表数据的这一特点使其可以非常的方便地实现节点的插入和删除操作；</p><p>链表的每个元素称为一个节点，每个节点都可以存储在内存中的不同的位置，为了表示每个元素与后继元素的逻辑</p><p>关系，以便构成“一个节点链着一个节点”的链式存储结构；</p><p>除了存储元素本身的信息外，还要存储其直接后继信息，因此，每个节点都包含两个部分，第一部分称为链表的数</p><p>据区域，用于存储元素本身的数据信息，第二部分是一个结构体指针，称为链表的指针域，用于存储其直接后继的</p><p>节点信息；</p><p>next的值实际上就是下一个节点的地址，当前节点为末节点时，next的值设为空指针；</p><h4 id="优点（相对于数组）"><a href="#优点（相对于数组）" class="headerlink" title="优点（相对于数组）"></a>优点（相对于数组）</h4><p>对线性表进行删除，添加等操作时候，不需要移动大量数据，操作简便，而数组需要动用大量数据，十分困难；同</p><p>时链表属于动态分配内存，数据量可以改变，而数组长度必须提前定义好，属于静态分配内存；链表省空间，数组</p><p>容易越界，长度过长又会造成系统资源浪费；</p><p>总的来说，链表优点非常多；</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>单向链表只能顺序访问，不能随机访问，这种储存结构最大缺点就是容易断链；一旦某个节点指针域数据丢失，将</p><p>无法找到下一个节点，也就是说，该节点的后面的数据全部丢失；</p><h3 id="无空头链表"><a href="#无空头链表" class="headerlink" title="无空头链表"></a>无空头链表</h3><h4 id="头文件-函数声明-结构体-全局变量"><a href="#头文件-函数声明-结构体-全局变量" class="headerlink" title="头文件+函数声明+结构体+全局变量"></a>头文件+函数声明+结构体+全局变量</h4><p>头文件stdlib.h，调用malloc（）函数和free（）函数；</p><p>函数比较多，先声明一下，便于阅读；</p><p>结构体先设一个成员，根据自己情况来设；</p><p>设全局变量的话，写各个操作函数的时候就省了一个形参；</p><h5 id="头文件（根据使用的语言自行修改）"><a href="#头文件（根据使用的语言自行修改）" class="headerlink" title="头文件（根据使用的语言自行修改）"></a>头文件（根据使用的语言自行修改）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明 链表的增、删、查、改；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddTail</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//创建链表，在链表中增加一个数据，尾添加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddHead</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//创建链表，在链表中增加一个数据，头添加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddList</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span></span>; <span class="comment">//在数字index后面添加数字a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteHead</span><span class="params">()</span></span>; <span class="comment">//头删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTail</span><span class="params">()</span></span>; <span class="comment">//尾删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//删除指定节点 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeekList</span><span class="params">()</span></span>; <span class="comment">//遍历链表——&gt;查</span></span><br><span class="line"><span class="function">struct Node* <span class="title">SearchNode</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//查询指定节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChangeNode</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span></span>; <span class="comment">//将index改为 n  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeList</span><span class="params">()</span></span>; <span class="comment">//链表清空</span></span><br></pre></td></tr></table></figure><h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span> <span class="comment">//指向下一个节点的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表头尾指针（全局变量）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">tail</span> = <span class="title">NULL</span>;</span></span><br></pre></td></tr></table></figure><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><h5 id="头添加"><a href="#头添加" class="headerlink" title="头添加"></a>头添加</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddHead</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//创建链表，在链表中增加一个数据，头添加</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = (<span class="title">struct</span> <span class="title">Node</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//节点数据进行赋值</span></span><br><span class="line">pTemp-&gt;a = n;</span><br><span class="line">pTemp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接在链表上</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)<span class="comment">//链表为空，新节点既是头也是尾巴</span></span><br><span class="line">&#123;</span><br><span class="line">head = pTemp;</span><br><span class="line">tail = pTemp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pTemp-&gt;next = head; <span class="comment">//新节点的下一个指向头</span></span><br><span class="line">head = pTemp;<span class="comment">//新节点就是头了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="尾添加"><a href="#尾添加" class="headerlink" title="尾添加"></a>尾添加</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddTail</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//创建链表，在链表中增加一个数据，尾添加</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = (<span class="title">struct</span> <span class="title">Node</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//节点数据进行赋值</span></span><br><span class="line">pTemp-&gt;a = n;</span><br><span class="line">pTemp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链接</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || tail == <span class="literal">NULL</span>)<span class="comment">//空链表，既是头，又是尾</span></span><br><span class="line">&#123;</span><br><span class="line">head = pTemp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//不为空，往尾巴上添加</span></span><br><span class="line">&#123;</span><br><span class="line">tail-&gt;next = pTemp;</span><br><span class="line">&#125;</span><br><span class="line">tail = pTemp;<span class="comment">// 尾巴一直指向最后一个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="任意位置添加"><a href="#任意位置添加" class="headerlink" title="任意位置添加"></a>任意位置添加</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddList</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span><span class="comment">//在数字index后面添加数字n</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表为空，没有节点\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">fp</span> = <span class="title">SearchNode</span>(<span class="title">index</span>);</span></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"没有指定的节点\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有此节点，给a创建节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = (<span class="title">struct</span> <span class="title">Node</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line">pTemp-&gt;a = n;</span><br><span class="line">pTemp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fp == tail)<span class="comment">//链接到链表上</span></span><br><span class="line">&#123;</span><br><span class="line">tail-&gt;next = pTemp; <span class="comment">//尾巴的下一个，指向新的节点</span></span><br><span class="line">tail = pTemp;  <span class="comment">//新节点是最后一个，变成尾巴</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pTemp-&gt;next = fp-&gt;next;<span class="comment">//先连</span></span><br><span class="line">fp-&gt;next = pTemp;      <span class="comment">//后断</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h5 id="头删除"><a href="#头删除" class="headerlink" title="头删除"></a>头删除</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteHead</span><span class="params">()</span> <span class="comment">//头删除</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)<span class="comment">//检查链表是否为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表为NULL，无需释放!\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head == tail)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(head);</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line">tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">struct Node* pTemp = head;<span class="comment">//记住旧的头</span></span><br><span class="line">head = head-&gt;next; <span class="comment">//头的下一个节点变成新的头</span></span><br><span class="line"><span class="built_in">free</span>(pTemp); <span class="comment">//释放旧的头</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="尾删除"><a href="#尾删除" class="headerlink" title="尾删除"></a>尾删除</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTail</span><span class="params">()</span> <span class="comment">//尾删除</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)<span class="comment">//检查链表是否为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表为NULL，无需释放!\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表不为空 有一个节点</span></span><br><span class="line"><span class="keyword">if</span> (head == tail)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(head);</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line">tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找尾巴前一个节点</span></span><br><span class="line">struct Node* pTemp = head;</span><br><span class="line"><span class="keyword">while</span> (pTemp-&gt;next != tail)</span><br><span class="line">&#123;</span><br><span class="line">pTemp = pTemp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到尾巴 删除并释放</span></span><br><span class="line"><span class="built_in">free</span>(tail);  <span class="comment">//释放尾巴</span></span><br><span class="line">tail = pTemp;<span class="comment">//移动尾巴</span></span><br><span class="line">tail-&gt;next = <span class="literal">NULL</span>;<span class="comment">//尾巴的下一个指针赋值为NULL</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="任意位置删除"><a href="#任意位置删除" class="headerlink" title="任意位置删除"></a>任意位置删除</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//删除指定节点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)<span class="comment">//检查链表是否为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表为NULL，无需释放!\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表有东西，找此节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">SearchNode</span>(<span class="title">n</span>);</span></span><br><span class="line"><span class="keyword">if</span> (pTemp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"查无此节点\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到了</span></span><br><span class="line"><span class="keyword">if</span> (pTemp == head) <span class="comment">//只有一个节点</span></span><br><span class="line">&#123;</span><br><span class="line">DeleteHead();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pTemp == tail)<span class="comment">//有两个节点</span></span><br><span class="line">&#123;</span><br><span class="line">DeleteTail();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//有多个节点</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">struct Node* fp = head;</span><br><span class="line"><span class="keyword">while</span> (fp-&gt;next != pTemp)</span><br><span class="line">&#123;</span><br><span class="line">fp = fp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到了</span></span><br><span class="line">fp-&gt;next = pTemp-&gt;next;<span class="comment">//连接</span></span><br><span class="line"><span class="built_in">free</span>(pTemp); <span class="comment">//释放</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeekList</span><span class="params">()</span> <span class="comment">//遍历链表——&gt;查</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">head</span>;</span></span><br><span class="line"><span class="keyword">while</span> (pTemp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d  "</span>,pTemp-&gt;a);</span><br><span class="line">pTemp = pTemp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct Node* <span class="title">SearchNode</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//查询指定节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">head</span>;</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (pTemp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n == pTemp-&gt;a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d个数为%d\n"</span>, num, pTemp-&gt;a);</span><br><span class="line"><span class="comment">//return pTemp;</span></span><br><span class="line">&#125;</span><br><span class="line">pTemp = pTemp-&gt;next;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChangeNode</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span><span class="comment">//将index改为 n  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">fp</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;a == index)</span><br><span class="line">&#123;</span><br><span class="line">fp-&gt;a = n;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">fp = fp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeList</span><span class="params">()</span> <span class="comment">//链表清空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">head</span>;</span> <span class="comment">//记录头，防止头被修改，丢内存</span></span><br><span class="line"><span class="keyword">while</span> (pTemp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">fp</span> = <span class="title">pTemp</span>;</span></span><br><span class="line">pTemp = pTemp-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头尾清空</span></span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line">tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空头链表"><a href="#空头链表" class="headerlink" title="空头链表"></a>空头链表</h3><p>空头链表和无空头链表其实本质区别不大，空头链表就是头结点为空（有头指针，但是没有数值域）在进行某些操</p><p>作的时候就比较简单；</p><p>空头链表和无空头链表相似度很高，部分操作相同，就不一一列举了；</p><h4 id="头文件-函数声明-结构体-全局变量-1"><a href="#头文件-函数声明-结构体-全局变量-1" class="headerlink" title="头文件+函数声明+结构体+全局变量"></a>头文件+函数声明+结构体+全局变量</h4><h5 id="头文件（根据使用的语言自行修改）-1"><a href="#头文件（根据使用的语言自行修改）-1" class="headerlink" title="头文件（根据使用的语言自行修改）"></a>头文件（根据使用的语言自行修改）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="函数声明-1"><a href="#函数声明-1" class="headerlink" title="函数声明"></a>函数声明</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct Node* <span class="title">CreateNode</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//创建节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NewList</span><span class="params">()</span></span>;<span class="comment">//空头链表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddHead</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">// 头添加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddTail</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//尾添加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddRand</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span></span>;<span class="comment">//在数字index后面添加数字a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteHead</span><span class="params">()</span></span>;<span class="comment">//删除头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTail</span><span class="params">()</span></span>;<span class="comment">//删除尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//删除指定节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeekList</span><span class="params">()</span></span>; <span class="comment">//遍历</span></span><br><span class="line"><span class="function">struct Node* <span class="title">SearchNode</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//查找指定节点，并返回节点地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeList</span><span class="params">()</span></span>;<span class="comment">//释放链表</span></span><br></pre></td></tr></table></figure><h5 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span> <span class="comment">//指向下一个节点的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表头尾指针（全局变量）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">tail</span> = <span class="title">NULL</span>;</span></span><br></pre></td></tr></table></figure><h4 id="空头链表初始化"><a href="#空头链表初始化" class="headerlink" title="空头链表初始化"></a>空头链表初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NewList</span><span class="params">()</span><span class="comment">//空头链表初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//链表空头</span></span><br><span class="line">head = (struct Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">tail = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct Node* <span class="title">CreateNode</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//创建节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = (<span class="title">struct</span> <span class="title">Node</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span><span class="comment">//创建一个节点</span></span><br><span class="line"><span class="keyword">if</span> (pTemp == <span class="literal">NULL</span>)<span class="comment">//创建失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pTemp-&gt;a = n; <span class="comment">//节点成员赋值</span></span><br><span class="line">pTemp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> pTemp;<span class="comment">//返回节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h4><h5 id="头添加-1"><a href="#头添加-1" class="headerlink" title="头添加"></a>头添加</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddHead</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// 头添加</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">CreateNode</span>(<span class="title">n</span>);</span><span class="comment">//创建一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pTemp == <span class="literal">NULL</span>)<span class="comment">//创建失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"内存不足\n"</span>);<span class="comment">// 一般不会申请失败，除非内存不足</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//连接</span></span><br><span class="line">pTemp-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = pTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="尾添加-1"><a href="#尾添加-1" class="headerlink" title="尾添加"></a>尾添加</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddTail</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//尾添加</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">CreateNode</span>(<span class="title">n</span>);</span><span class="comment">//创建一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pTemp == <span class="literal">NULL</span>)<span class="comment">//创建失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"内存不足\n"</span>);<span class="comment">// 一般不会申请失败，除非内存不足</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//连接</span></span><br><span class="line">tail-&gt;next = pTemp;</span><br><span class="line">tail = pTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="任意位置添加-1"><a href="#任意位置添加-1" class="headerlink" title="任意位置添加"></a>任意位置添加</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddRand</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> n)</span><span class="comment">//在数字index后面添加数字a</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>)<span class="comment">//判断链表有没有东西</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表无节点\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找index节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">SearchNode</span>(<span class="title">index</span>);</span></span><br><span class="line"><span class="keyword">if</span> (pTemp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"查无此节点\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到节点,连接到指定位置</span></span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pNode</span> = <span class="title">CreateNode</span>(<span class="title">n</span>);</span></span><br><span class="line"><span class="comment">//连接</span></span><br><span class="line"><span class="keyword">if</span> (pTemp == tail)</span><br><span class="line">&#123;</span><br><span class="line">AddTail(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pNode-&gt;next = pTemp-&gt;next;</span><br><span class="line">pTemp-&gt;next = pNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><h5 id="头删除-1"><a href="#头删除-1" class="headerlink" title="头删除"></a>头删除</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteHead</span><span class="params">()</span><span class="comment">//删除头</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>)<span class="comment">//判断链表有没有东西</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表无头"</span>); </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有节点 ——&gt; 删除  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span> <span class="comment">//记录头</span></span><br><span class="line">head-&gt;next = head-&gt;next-&gt;next;  <span class="comment">//变头</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(pTemp);<span class="comment">//释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="尾删除-1"><a href="#尾删除-1" class="headerlink" title="尾删除"></a>尾删除</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTail</span><span class="params">()</span><span class="comment">//删除尾</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>)<span class="comment">//判断链表有没有东西</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表无尾"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有一个节点 ——&gt; 删除</span></span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == tail)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(tail);</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">tail = head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">struct Node* pTemp = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (pTemp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pTemp-&gt;next == tail)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pTemp = pTemp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pTemp就是尾巴的前一个</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(tail); <span class="comment">//释放尾巴</span></span><br><span class="line">tail = pTemp; <span class="comment">//更新尾巴</span></span><br><span class="line">tail-&gt;next = <span class="literal">NULL</span>; <span class="comment">//尾巴下一个赋值为NULL</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，剩下的操作和无空头的没啥区别，这里就不多说了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF工具</title>
      <link href="/2020/02/17/ctf-gong-ju/"/>
      <url>/2020/02/17/ctf-gong-ju/</url>
      
        <content type="html"><![CDATA[<p>假期做了很多CTF（攻防世界）的题目，小浩刚学没多久，只会简单的MISC和CRYPTO，网上搜集各种解密类型，</p><p>一个个去尝试，先整理一波；</p><a id="more"></a><p>整理这个其实是因为收藏夹满了，工具堆叠太多（噗哈哈哈），话不多说直接上网址；</p><h4 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h4><p>之前就喜欢密码学，了解的不是很多，但是感觉超厉害！！！Very Good！！！</p><p>做了题目知道了很多密码：Base64，ROT13，摩斯密码，凯撒密码，栅栏密码，幂数加密（计算就可以，或者写</p><p>个脚本），RSA加密（到现在还没看懂原理emmm）</p><p><a href="http://tool.chinaz.com/Tools/Base64.aspx" target="_blank" rel="noopener">Base64</a></p><p><a href="https://tool.lu/morse/" target="_blank" rel="noopener">Morse</a></p><p><a href="https://www.qqxiuzi.cn/bianma/kaisamima.php" target="_blank" rel="noopener">Caesar</a></p><p><a href="https://www.jisuan.mobi/puzzm6z1B1HH6yXW.html" target="_blank" rel="noopener">ROT13</a></p><p><a href="http://www.atoolbox.net/Tool.php?Id=777" target="_blank" rel="noopener">W型栅栏密码</a></p><p><a href="https://www.sojson.com/encrypt_aes.html" target="_blank" rel="noopener">AES</a></p><p><a href="http://www.bejson.com/convert/ox2str/" target="_blank" rel="noopener">16进制文本转换</a></p><p><a href="http://www.atoolbox.net/Category.php?Id=27" target="_blank" rel="noopener">加密解密工具</a></p><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><p>杂项题目更头疼，五花八门的解密方法，确实让人头疼。还得精通ps（真是佩服），有一道p二维码的题，p了一</p><p>个晚上；</p><p><a href="https://www.sojson.com/qr/deqr.html" target="_blank" rel="noopener">二维码</a></p><p><a href="https://app.xunjiepdf.com/pdf2word/" target="_blank" rel="noopener">PDF转-&gt;</a></p><p><a href="http://keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="noopener">与佛论禅</a></p><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p><a href="http://ctf.ssleye.com/?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">CTF在线工具</a></p><p><a href="https://www.ctftools.com/down/" target="_blank" rel="noopener">CTF资源库</a></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>CTF是个很好玩的“游戏”，现在虽然是个小白，但是我要努力成为大佬，题目越做越多，后面再进行整理。</p><p>Fighting！</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2020/02/15/pai-xu/"/>
      <url>/2020/02/15/pai-xu/</url>
      
        <content type="html"><![CDATA[<p>初学算法，从最简单的开始——排序；</p><a id="more"></a><p>算法中常用的排序有多钟，比如冒泡排序，桶排序，快速排序，归并排序，sort（我只会这么多，hhh），下面我</p><p>将会一一介绍：</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h3><p>首先，我们来看桶排序。桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个</p><p>桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的</p><p>了；</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> bucket[<span class="number">101</span>],i,j,t,n;</span><br><span class="line"><span class="built_in">memset</span>(bucket,<span class="number">0</span>,<span class="keyword">sizeof</span>(bucket));  <span class="comment">//数组全体置为 0 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);  <span class="comment">//输入一个数字 n，表示有 n个数 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="comment">//循环读入 n个数，并进行桶排序 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);   <span class="comment">//把每次读入的数字用变量 t保存 </span></span><br><span class="line">bucket[t]++;<span class="comment">//进行计数，对编号为 t的桶加一 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">101</span>;i++)  <span class="comment">//依次判断编号为 0-100 的桶 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=bucket[i];j++)  <span class="comment">// 出现几次就将桶打印几次 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>设桶的个数为m，待排序数的个数为n；</p><p>第8行执行了m次，第13行执行了n次，第16行和第19行共执行了m+n次，所以程序共执行了2（m+n)次，时间复</p><p>杂度即为O（2*（m+n）），即O（m+n）；</p><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>其次，我们来看冒泡排序。冒泡排序基本思想是：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过</p><p>来；</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">t=*a,*a=*b,*b=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,n;</span><br><span class="line"><span class="keyword">int</span> bubble[<span class="number">100</span>]; </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n); <span class="comment">// 输入一个n，表示有n个数。 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;bubble[i]);<span class="comment">// 循环读入n个数，放入数组中 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是冒泡排序核心</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)   <span class="comment">//外层for循环控制循环次数 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>;j++)   <span class="comment">//内层for循环控制相邻两元素进行比较 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(bubble[j]&gt;bubble[j+<span class="number">1</span>])   <span class="comment">//if(bubble[j]&lt;bubble[j+1]) </span></span><br><span class="line"><span class="comment">// 比较；两数大小并交换，前者从小到大排序，后者从大到小排序（也可以通过输出改变排列次序） </span></span><br><span class="line">&#123;</span><br><span class="line">swap(&amp;bubble[j],&amp;bubble[j+<span class="number">1</span>]);<span class="comment">//交换两个数 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,bubble[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>设待排序数的个数为n；</p><p>不难看出，核心代码中，最短时间为n，最长为n^2,所以时间复杂度为O（n^2）；</p><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>桶排序和冒泡排序虽然简单，但是如果有几万几亿个数排序，那效率就会非常低，这就需要一种快速的排序方法</p><p>——快速排序；</p><p>思路：</p><p>1.对于一个数组，首先选择一个基准值key，这个基准值可以随意选，但是一般选择的是这个数组的第一个元素；</p><p>2.我们对于这个数组，把数组中所有比基准值key小的元素向基准值key的左边扔，把数组中所有比基准值key大的</p><p>元素向key的右边扔；</p><p>3.这样的话基准值key就成为了一个”分界线”，所有比基准值key小的元素都在基准值key的左边，所有比基准值key</p><p>大的元素都在基准值key的右边；</p><p>4.之后我们在递归的对基准值key左边的序列和右边的序列再用以上方法进行排序；</p><p>5.最终整个序列就是有序的了；</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> quick[<span class="number">101</span>],n; <span class="comment">//定义全局变量，需要在子函数中使用 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,t,temp;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        temp=quick[left];  <span class="comment">// temp存的就是基准数 </span></span><br><span class="line">        i=left;</span><br><span class="line">        j=right;</span><br><span class="line">        <span class="keyword">while</span>(i!=j)  <span class="comment">//顺序很重要 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(quick[j]&gt;=temp&amp;&amp;i&lt;j) j--;  <span class="comment">//从右往左找 </span></span><br><span class="line">            <span class="keyword">while</span>(quick[i]&lt;=temp&amp;&amp;i&lt;j) i++;  <span class="comment">//从左往右找 </span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;j) <span class="comment">// 交换两个数在数组中的位置 </span></span><br><span class="line">            &#123;</span><br><span class="line">                t=quick[i];</span><br><span class="line">                quick[i]=quick[j];</span><br><span class="line">                quick[j]=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 基准数归位 </span></span><br><span class="line">        quick[left]=quick[i];</span><br><span class="line">        quick[i]=temp;</span><br><span class="line">        quicksort(left,i<span class="number">-1</span>);  <span class="comment">//继续处理左边的，这是一个递归的过程 </span></span><br><span class="line">        quicksort(i+<span class="number">1</span>,right); <span class="comment">//继续处理右边的，这是一个递归的过程 </span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;quick[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        quicksort(<span class="number">1</span>,n);  <span class="comment">// 快排调用 </span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,quick[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>设需要排序的数字的个数为n；</p><p>理想的情况是，每次划分所选择的中间数恰好将当前序列几乎等分，经过log2n趟划分，便可得到长度为1的子</p><p>表。这样，整个算法的时间复杂度为O(nlog2n)；</p><p>最坏的情况是，每次所选的中间数是当前序列中的最大或最小元素，这使得每次划分所得的子表中一个为空表，另</p><p>一子表的长度为原表的长度-1。这样，长度为n的数据表的快速排序需要经过n趟划分，使得整个排序算法的时间</p><p>复杂度为O(n^2)；</p><p>平均起来，快速排序的时间复杂度为O（nlogn）；</p><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>原理：</p><p>假设初始待排序数据有n个，可以将n个数据看成n个独立的子序列，因此每个子序列的长度为1，然后两两合并，</p><p>得到n/2个长度为2或1(如果n为奇数时，就会出现多出一个元素无法与其他元素合并)的有序子序列; 再两两合并，</p><p>一直重复下去，直到得到一个长度为n的有序序列为止（2路排序）；</p><p>核心：</p><p>两个有序子序列的合并；</p><p>（1）将待排序序列一分为二，对左右两边进行递归分割，得到m个子序列；</p><p>（2）对m个子序列递归执行合并操作，最终得到有序的序列；</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原数组arr1，临时空间数组arr2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr1[],<span class="keyword">int</span> arr2[],<span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = low, j = mid+<span class="number">1</span>, k = low;</span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr1[i]&lt;arr1[j])</span><br><span class="line">&#123;</span><br><span class="line">arr2[k++] = arr1[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">arr2[k++] = arr1[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid)</span><br><span class="line">&#123;</span><br><span class="line">arr2[k++] = arr1[i++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line">    arr2[k++] = arr1[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=low; i&lt;=high;i++)</span><br><span class="line">&#123;</span><br><span class="line">arr1[i] = arr2[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr1[],<span class="keyword">int</span> arr2[],<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//直到a=b时，停止递归。</span></span><br><span class="line"><span class="keyword">if</span> (a&lt;b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (a+b)/<span class="number">2</span>;</span><br><span class="line">mergeSort(arr1,arr2,a,mid);</span><br><span class="line">mergeSort(arr1,arr2,mid+<span class="number">1</span>,b);</span><br><span class="line">merge(arr1,arr2,a,mid,b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">4</span>&#125;,b[<span class="number">10</span>];</span><br><span class="line">    mergeSort(a,b,<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>设需要排序的数字的个数为n；</p><p>归并排序稳定性比较高，最好情况、最坏情况都为nlogn，所以时间复杂度为O(nlogn)；</p><h3 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a>sort函数</h3><p>sort函数用于C++中，可以实现升序，也可以实现降序，原理不多说，直接上代码；</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span>  <span class="comment">//自定义函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m&gt;n;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span>  <span class="comment">//自定义函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m&lt;n;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>],i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i]; </span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//从大到小--&gt; sort(a,a+5,greater&lt;int&gt;()); 或者 sort(a,a+5,cmp1); </span></span><br><span class="line">    <span class="comment">//从小到大--&gt; sort(a,a+5,less&lt;int&gt;());  或者 sort(a,a+5,cmp2);</span></span><br><span class="line">    <span class="comment">//acm做题的时候，常常直接sort(a,a+n);--&gt;从小到大</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>sort函数是qsort的升级版，它的时间复杂度也是nlogn，acm的话用sort多一些，简洁明了（偷懒）；</p><p>。。。。未完待续。。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2020/02/15/suan-fa/"/>
      <url>/2020/02/15/suan-fa/</url>
      
        <content type="html"><![CDATA[<p>个人基于学习的态度，高考后为了进入学校的双创中心，自学C语言两个月，初步学习了C语言的内容。</p><a id="more"></a><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法</p><p>描述解决问题的策略机制；简单来讲，就是解决问题的方法和机制；</p><h5 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h5><p>1、有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一步骤在可接受的时间内完成；</p><p>2、确定性：算法的每一步骤都有确定的含义，不会出现二义性；</p><p>3、可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成;</p><p>4、输入输出：0至多个输入，1至多个输出；</p><h4 id="我所了解的算法"><a href="#我所了解的算法" class="headerlink" title="我所了解的算法"></a>我所了解的算法</h4><p>第一个接触的算法叫做排序，分了很多种（桶，冒泡，归并，快速）；二分法，前缀和与差分法，枚举法，bfs，</p><p>dfs，还有栈，队列等等；</p><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>在接下来的一些时间里，快速学习多种算法，达到速成的效果；</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2020/02/15/shu-ju-jie-gou/"/>
      <url>/2020/02/15/shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<p>数据结构是学习语言过程中必会内容，对以后做项目，工作会有很大的帮助；</p><p>下学习开数据结构课，所以将学习记的一些笔记写进blog里面；</p><p>后面会不定时的更新；</p><a id="more"></a><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法</p><p>描述解决问题的策略机制；简单来讲，就是解决问题的方法和机制；</p><h5 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h5><p>1、有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一步骤在可接受的时间内完成；</p><p>2、确定性：算法的每一步骤都有确定的含义，不会出现二义性；</p><p>3、可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成；</p><p>4、输入输出：0至多个输入，1至多个输出；</p><h4 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h4><p>程序 = 数据结构 + 算法；</p><h4 id="数据结构概念"><a href="#数据结构概念" class="headerlink" title="数据结构概念"></a>数据结构概念</h4><p>数据结构：是相互之间存在一种或多种特定关系的数据结构元素的集合；</p><p>//接下来的时间我将会整理数据结构的相关内容，敬请期待；</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/02/14/hello-world/"/>
      <url>/2020/02/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to Hexo！！</p><p>我是一名计算机小白，这是我的第一篇博客，不足之处，请多指教；</p><p>学习语言最基本了解它大概长什么样子，下面通过打印Hello World！来了解了解；</p><a id="more"></a><h4 id="打印”Hello-World-”"><a href="#打印”Hello-World-”" class="headerlink" title="打印”Hello World!”"></a>打印”Hello World!”</h4><h5 id="C"><a href="#C" class="headerlink" title="C"></a>C</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure><h5 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Hello World!"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h5 id="C-2"><a href="#C-2" class="headerlink" title="C#"></a>C#</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">HelloWorld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">HelloWorld</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Hello World!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Testing </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
