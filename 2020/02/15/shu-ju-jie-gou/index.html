<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据结构 | Los-Kos</title><meta name="description" content="大一下开设的课程，记录学习笔记和一些问题"><meta name="keywords" content="数据结构"><meta name="author" content="Los-kos"><meta name="copyright" content="Los-kos"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/whloki/cdn@master/img/avatar.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据结构"><meta name="twitter:description" content="大一下开设的课程，记录学习笔记和一些问题"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/img/featureimages/2.jpg"><meta property="og:type" content="article"><meta property="og:title" content="数据结构"><meta property="og:url" content="https://www.los-kos.cn/2020/02/15/shu-ju-jie-gou/"><meta property="og:site_name" content="Los-Kos"><meta property="og:description" content="大一下开设的课程，记录学习笔记和一些问题"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/img/featureimages/2.jpg"><meta property="article:published_time" content="2020-02-15T07:44:13.000Z"><meta property="article:modified_time" content="2020-06-02T05:00:47.908Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://www.los-kos.cn/2020/02/15/shu-ju-jie-gou/"><link rel="prev" title="CTF常用工具汇总" href="https://www.los-kos.cn/2020/02/17/ctf-gong-ju/"><link rel="next" title="Hello World" href="https://www.los-kos.cn/2020/02/14/hello-world/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8156eb470c2d34104408dd52ad3f8182";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://www.los-kos.cn/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"I,Love,You,我喜欢你,很喜欢你,超级超级喜欢你","fontSize":"18px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Los-Kos" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="Los-Kos" type="application/rss+xml">
<link rel="stylesheet" href="/css/prism-shades-of-purple.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/whloki/cdn@master/img/avatar.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">19</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构概念"><span class="toc-number">1.1.</span> <span class="toc-text">数据结构概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法特点"><span class="toc-number">1.2.</span> <span class="toc-text">算法特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序设计"><span class="toc-number">1.3.</span> <span class="toc-text">程序设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#时间复杂度"><span class="toc-number">2.</span> <span class="toc-text">时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#推导大O阶方法"><span class="toc-number">2.1.</span> <span class="toc-text">推导大O阶方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见的时间复杂度"><span class="toc-number">2.2.</span> <span class="toc-text">常见的时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见的时间复杂度所耗时间的大小排列"><span class="toc-number">2.3.</span> <span class="toc-text">常见的时间复杂度所耗时间的大小排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">2.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线性表—Linear-List"><span class="toc-number">3.</span> <span class="toc-text">线性表—Linear List</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义"><span class="toc-number">3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前驱后继"><span class="toc-number">3.2.</span> <span class="toc-text">前驱后继</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线性表的抽象数据类型——基本操作-增-删-查-取-空-长"><span class="toc-number">3.3.</span> <span class="toc-text">线性表的抽象数据类型——基本操作( 增 删 查 取 空 长 )</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线性表的顺序存储结构——顺序表"><span class="toc-number">3.4.</span> <span class="toc-text">线性表的顺序存储结构——顺序表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-1"><span class="toc-number">3.4.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#顺序储存方式"><span class="toc-number">3.4.2.</span> <span class="toc-text">顺序储存方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#顺序表的操作"><span class="toc-number">3.4.3.</span> <span class="toc-text">顺序表的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#获得元素操作"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">获得元素操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插入操作"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除操作"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">删除操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优缺点"><span class="toc-number">3.4.4.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线性表的链式储存结构——链表"><span class="toc-number">3.5.</span> <span class="toc-text">线性表的链式储存结构——链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单链表"><span class="toc-number">3.5.1.</span> <span class="toc-text">单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单链表的读取"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">单链表的读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单链表的插入"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">单链表的插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单链表的删除"><span class="toc-number">3.5.1.3.</span> <span class="toc-text">单链表的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单链表的整表创建"><span class="toc-number">3.5.1.4.</span> <span class="toc-text">单链表的整表创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#头插法"><span class="toc-number">3.5.1.4.1.</span> <span class="toc-text">头插法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#尾插法"><span class="toc-number">3.5.1.4.2.</span> <span class="toc-text">尾插法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#清空链表"><span class="toc-number">3.5.1.5.</span> <span class="toc-text">清空链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单链表结构与顺序存储结构优缺点"><span class="toc-number">3.5.1.6.</span> <span class="toc-text">单链表结构与顺序存储结构优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态链表"><span class="toc-number">3.6.</span> <span class="toc-text">静态链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-2"><span class="toc-number">3.6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态链表存储结构"><span class="toc-number">3.6.2.</span> <span class="toc-text">静态链表存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化数组"><span class="toc-number">3.6.3.</span> <span class="toc-text">初始化数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取链表中元素的个数"><span class="toc-number">3.6.4.</span> <span class="toc-text">获取链表中元素的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态链表的插入操作"><span class="toc-number">3.6.5.</span> <span class="toc-text">静态链表的插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#获得空闲分量的下标"><span class="toc-number">3.6.5.1.</span> <span class="toc-text">获得空闲分量的下标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插入"><span class="toc-number">3.6.5.2.</span> <span class="toc-text">插入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态链表的删除操作"><span class="toc-number">3.6.6.</span> <span class="toc-text">静态链表的删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#回收节点"><span class="toc-number">3.6.6.1.</span> <span class="toc-text">回收节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除"><span class="toc-number">3.6.6.2.</span> <span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态链表优缺点"><span class="toc-number">3.6.7.</span> <span class="toc-text">静态链表优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双向链表"><span class="toc-number">3.7.</span> <span class="toc-text">双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-3"><span class="toc-number">3.7.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储结构"><span class="toc-number">3.7.2.</span> <span class="toc-text">存储结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环链表"><span class="toc-number">3.8.</span> <span class="toc-text">循环链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-4"><span class="toc-number">3.8.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特点"><span class="toc-number">3.8.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结-1"><span class="toc-number">3.9.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#栈—Stack"><span class="toc-number">4.</span> <span class="toc-text">栈—Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义-5"><span class="toc-number">4.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈的抽象数据类型——基本操作-入栈-出栈"><span class="toc-number">4.2.</span> <span class="toc-text">栈的抽象数据类型——基本操作( 入栈 出栈 )</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈的顺序存储结构"><span class="toc-number">4.3.</span> <span class="toc-text">栈的顺序存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构代码"><span class="toc-number">4.3.1.</span> <span class="toc-text">结构代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化栈"><span class="toc-number">4.3.2.</span> <span class="toc-text">初始化栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断栈是否已满"><span class="toc-number">4.3.3.</span> <span class="toc-text">判断栈是否已满</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断栈是否为空"><span class="toc-number">4.3.4.</span> <span class="toc-text">判断栈是否为空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进栈"><span class="toc-number">4.3.5.</span> <span class="toc-text">进栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#出栈"><span class="toc-number">4.3.6.</span> <span class="toc-text">出栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈的链式存储结构"><span class="toc-number">4.4.</span> <span class="toc-text">栈的链式存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构代码-1"><span class="toc-number">4.4.1.</span> <span class="toc-text">结构代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化栈-1"><span class="toc-number">4.4.2.</span> <span class="toc-text">初始化栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断栈是否为空-1"><span class="toc-number">4.4.3.</span> <span class="toc-text">判断栈是否为空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进栈-1"><span class="toc-number">4.4.4.</span> <span class="toc-text">进栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#出栈-1"><span class="toc-number">4.4.5.</span> <span class="toc-text">出栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#取栈顶元素"><span class="toc-number">4.4.6.</span> <span class="toc-text">取栈顶元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历栈"><span class="toc-number">4.4.7.</span> <span class="toc-text">遍历栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结-2"><span class="toc-number">4.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#队列—Queue"><span class="toc-number">5.</span> <span class="toc-text">队列—Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义-6"><span class="toc-number">5.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#队列的抽象数据类型——基本操作"><span class="toc-number">5.2.</span> <span class="toc-text">队列的抽象数据类型——基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环队列"><span class="toc-number">5.3.</span> <span class="toc-text">循环队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#队列顺序存储的不足"><span class="toc-number">5.3.1.</span> <span class="toc-text">队列顺序存储的不足</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环队列定义"><span class="toc-number">5.3.2.</span> <span class="toc-text">循环队列定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环队列顺序存储结构"><span class="toc-number">5.3.3.</span> <span class="toc-text">循环队列顺序存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列初始化"><span class="toc-number">5.3.4.</span> <span class="toc-text">队列初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列长度"><span class="toc-number">5.3.5.</span> <span class="toc-text">队列长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#入队"><span class="toc-number">5.3.6.</span> <span class="toc-text">入队</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#出队"><span class="toc-number">5.3.7.</span> <span class="toc-text">出队</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#队列的链式存储结构及实现"><span class="toc-number">5.4.</span> <span class="toc-text">队列的链式存储结构及实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#链式队列存储结构"><span class="toc-number">5.4.1.</span> <span class="toc-text">链式队列存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列初始化-1"><span class="toc-number">5.4.2.</span> <span class="toc-text">队列初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#入队-1"><span class="toc-number">5.4.3.</span> <span class="toc-text">入队</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#出队-1"><span class="toc-number">5.4.4.</span> <span class="toc-text">出队</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结-3"><span class="toc-number">5.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#串—String"><span class="toc-number">6.</span> <span class="toc-text">串—String</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义-7"><span class="toc-number">6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#串的抽象数据类型"><span class="toc-number">6.2.</span> <span class="toc-text">串的抽象数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#串的存储结构"><span class="toc-number">6.3.</span> <span class="toc-text">串的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构代码-2"><span class="toc-number">6.3.1.</span> <span class="toc-text">结构代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串长度"><span class="toc-number">6.3.2.</span> <span class="toc-text">字符串长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#建立新串"><span class="toc-number">6.3.3.</span> <span class="toc-text">建立新串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求子串函数"><span class="toc-number">6.3.4.</span> <span class="toc-text">求子串函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除子串"><span class="toc-number">6.3.5.</span> <span class="toc-text">删除子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入子串"><span class="toc-number">6.3.6.</span> <span class="toc-text">插入子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定位子串"><span class="toc-number">6.3.7.</span> <span class="toc-text">定位子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串比较"><span class="toc-number">6.3.8.</span> <span class="toc-text">字符串比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串连接"><span class="toc-number">6.3.9.</span> <span class="toc-text">字符串连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子串替换"><span class="toc-number">6.3.10.</span> <span class="toc-text">子串替换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结-4"><span class="toc-number">6.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#树—Tree"><span class="toc-number">7.</span> <span class="toc-text">树—Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#树的定义"><span class="toc-number">7.1.</span> <span class="toc-text">树的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-8"><span class="toc-number">7.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树的表示方法"><span class="toc-number">7.1.2.</span> <span class="toc-text">树的表示方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树的基本术语z"><span class="toc-number">7.1.3.</span> <span class="toc-text">树的基本术语z</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树"><span class="toc-number">7.2.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树定义"><span class="toc-number">7.2.1.</span> <span class="toc-text">二叉树定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的特点"><span class="toc-number">7.2.2.</span> <span class="toc-text">二叉树的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的基本形态"><span class="toc-number">7.2.3.</span> <span class="toc-text">二叉树的基本形态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的性质"><span class="toc-number">7.2.4.</span> <span class="toc-text">二叉树的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特殊二叉树"><span class="toc-number">7.2.5.</span> <span class="toc-text">特殊二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#斜树"><span class="toc-number">7.2.5.1.</span> <span class="toc-text">斜树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#定义-9"><span class="toc-number">7.2.5.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#特点-1"><span class="toc-number">7.2.5.1.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#满二叉树"><span class="toc-number">7.2.5.2.</span> <span class="toc-text">满二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#定义-10"><span class="toc-number">7.2.5.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#特点-2"><span class="toc-number">7.2.5.2.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#完全二叉树"><span class="toc-number">7.2.5.3.</span> <span class="toc-text">完全二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#定义-11"><span class="toc-number">7.2.5.3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#特点-3"><span class="toc-number">7.2.5.3.2.</span> <span class="toc-text">特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的存储结构"><span class="toc-number">7.2.6.</span> <span class="toc-text">二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉树的顺序存储结构"><span class="toc-number">7.2.6.1.</span> <span class="toc-text">二叉树的顺序存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉树的链式存储结构"><span class="toc-number">7.2.6.2.</span> <span class="toc-text">二叉树的链式存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#二叉链表"><span class="toc-number">7.2.6.2.1.</span> <span class="toc-text">二叉链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#抽象数据类型"><span class="toc-number">7.2.6.2.2.</span> <span class="toc-text">抽象数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#存储结构-1"><span class="toc-number">7.2.6.2.3.</span> <span class="toc-text">存储结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的遍历"><span class="toc-number">7.2.7.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义-12"><span class="toc-number">7.2.7.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#前序遍历（DLR）"><span class="toc-number">7.2.7.2.</span> <span class="toc-text">前序遍历（DLR）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#操作"><span class="toc-number">7.2.7.2.1.</span> <span class="toc-text">操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#算法"><span class="toc-number">7.2.7.2.2.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#输出"><span class="toc-number">7.2.7.2.3.</span> <span class="toc-text">输出</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中序遍历（LDR）"><span class="toc-number">7.2.7.3.</span> <span class="toc-text">中序遍历（LDR）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#操作-1"><span class="toc-number">7.2.7.3.1.</span> <span class="toc-text">操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#算法-1"><span class="toc-number">7.2.7.3.2.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#输出-1"><span class="toc-number">7.2.7.3.3.</span> <span class="toc-text">输出</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#后序遍历（LRD）"><span class="toc-number">7.2.7.4.</span> <span class="toc-text">后序遍历（LRD）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#操作-2"><span class="toc-number">7.2.7.4.1.</span> <span class="toc-text">操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#算法-2"><span class="toc-number">7.2.7.4.2.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#输出-2"><span class="toc-number">7.2.7.4.3.</span> <span class="toc-text">输出</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#层序遍历"><span class="toc-number">7.2.7.5.</span> <span class="toc-text">层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#操作-3"><span class="toc-number">7.2.7.5.1.</span> <span class="toc-text">操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#算法-3"><span class="toc-number">7.2.7.5.2.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#输出-3"><span class="toc-number">7.2.7.5.3.</span> <span class="toc-text">输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的建立"><span class="toc-number">7.2.8.</span> <span class="toc-text">二叉树的建立</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特殊处理"><span class="toc-number">7.2.8.1.</span> <span class="toc-text">特殊处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#统计二叉树叶子结点的数目"><span class="toc-number">7.2.9.</span> <span class="toc-text">统计二叉树叶子结点的数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#统计二叉树结点总数"><span class="toc-number">7.2.10.</span> <span class="toc-text">统计二叉树结点总数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求二叉树的深度"><span class="toc-number">7.2.11.</span> <span class="toc-text">求二叉树的深度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线索二叉树"><span class="toc-number">7.3.</span> <span class="toc-text">线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引言"><span class="toc-number">7.3.1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-13"><span class="toc-number">7.3.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线索化"><span class="toc-number">7.3.3.</span> <span class="toc-text">线索化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储结构-2"><span class="toc-number">7.3.4.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中序遍历线索化"><span class="toc-number">7.3.5.</span> <span class="toc-text">中序遍历线索化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中序遍历线索二叉树"><span class="toc-number">7.3.6.</span> <span class="toc-text">中序遍历线索二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树、森林与二叉树的转换"><span class="toc-number">7.4.</span> <span class="toc-text">树、森林与二叉树的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#树转换为二叉树"><span class="toc-number">7.4.1.</span> <span class="toc-text">树转换为二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#森林转换为二叉树"><span class="toc-number">7.4.2.</span> <span class="toc-text">森林转换为二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树还原为树"><span class="toc-number">7.4.3.</span> <span class="toc-text">二叉树还原为树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树还原为森林"><span class="toc-number">7.4.4.</span> <span class="toc-text">二叉树还原为森林</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树应用"><span class="toc-number">7.5.</span> <span class="toc-text">二叉树应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结-5"><span class="toc-number">7.6.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/img/featureimages/2.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Los-Kos</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">数据结构</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-02-15 15:44:13"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-02-15</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-02 13:00:47"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-02</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">12.1k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 44 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"> <div class="post-content" id="article-container"><p>数据结构是学习语言过程中必会内容，对以后做项目，工作会有很大的帮助；</p>
<p>下学期开数据结构课，所以将学习记的一些笔记写进blog里面；</p>
<p>后面会不定时的更新；</p>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法</p>
<p>描述解决问题的策略机制；简单来讲，就是解决问题的方法和机制；</p>
<h2 id="数据结构概念"><a href="#数据结构概念" class="headerlink" title="数据结构概念"></a>数据结构概念</h2><p>数据结构：是相互之间存在一种或多种特定关系的数据结构元素的集合；</p>
<h2 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h2><p>1、有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一步骤在可接受的时间内完成；</p>
<p>2、确定性：算法的每一步骤都有确定的含义，不会出现二义性；</p>
<p>3、可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成；</p>
<p>4、输入输出：0至多个输入，1至多个输出；</p>
<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p><strong>程序 = 数据结构 + 算法；</strong></p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>定义：算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))(T(n)是语句总的执行次数)，它表示随问</p>
<p>题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。</p>
<p>其中f(n)是问题的规模n的某个函数；</p>
<h2 id="推导大O阶方法"><a href="#推导大O阶方法" class="headerlink" title="推导大O阶方法"></a>推导大O阶方法</h2><p>1、用常数1取代运行时间中的所有加法常数；</p>
<p>2、在修改后的运行次数函数中，只保留最高阶项；</p>
<p>3、如果最高阶项存在且不是1，则去除与这个项相乘的常数；</p>
<p>得到的的结果就是大O阶；</p>
<h2 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h2><p>常数阶    ——&gt;    O(1)</p>
<p>线性阶    ——&gt;    O(n)</p>
<p>平方阶    ——&gt;    O(n^2)</p>
<p>对数阶    ——&gt;    O(logn)</p>
<p><u>nlogn</u>阶  ——&gt;    O(nlogn)</p>
<p>立方阶    ——&gt;    O(n^3)</p>
<p>指数阶    ——&gt;    O(2^n)</p>
<h2 id="常见的时间复杂度所耗时间的大小排列"><a href="#常见的时间复杂度所耗时间的大小排列" class="headerlink" title="常见的时间复杂度所耗时间的大小排列"></a>常见的时间复杂度所耗时间的大小排列</h2><p><strong>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</strong></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>算法的时间复杂度内容不多，很好理解，从下一章开始就将进入代码的世界；</p>
<p>拜拜啦~</p>
<h1 id="线性表—Linear-List"><a href="#线性表—Linear-List" class="headerlink" title="线性表—Linear List"></a>线性表—Linear List</h1><p>学完时间复杂度，基本打开了数据结构的大门了，第一个我们来学线性表~</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>1、定义：n(n≥0)个<u>数据元素</u>的有限序列；</p>
<p>2、线性表是一种最常用且最简单的数据结构，含有n个元素的线性表是一个数据结构；</p>
<p>3、List = (D,R)  ——&gt;  D是data数据，R是relation关系；</p>
<h2 id="前驱后继"><a href="#前驱后继" class="headerlink" title="前驱后继"></a>前驱后继</h2><p>若将线性表记为a1,a2,a3……ai-1,ai,ai+1……an,则称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当</p>
<p>i=1,2,3…n-1时，ai有且仅有一个直接后继，当i=2,3,4…n时，ai有且仅有一个直接前驱；</p>
<p>所以，线性表的元素的个数n(n≥0)定义为线性表的长度，当n=0时，称为空表；</p>
<h2 id="线性表的抽象数据类型——基本操作-增-删-查-取-空-长"><a href="#线性表的抽象数据类型——基本操作-增-删-查-取-空-长" class="headerlink" title="线性表的抽象数据类型——基本操作( 增 删 查 取 空 长 )"></a>线性表的抽象数据类型——基本操作( 增 删 查 取 空 长 )</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、InitList(*L) <span class="comment">//初始化,建立一个新的线性表L；</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、ListEmpty(L) <span class="comment">//线性表为空，返回true，否则返回false；</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、ListLength(L) <span class="comment">//求长度，返回线性表中元素的个数；</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、GetElem(L,i,*e) <span class="comment">//将线性表L中第i个数据元素赋值给e；</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、LocateElem(L,e) <span class="comment">//在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功，否则，返回0表示失败；</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、ListInsert(*L,i,e) <span class="comment">//在线性表L中第i个位置插入新的数据e，表长+1；</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、ListDelete(*L,i,e) <span class="comment">//删除线性表L中第i个数据元素，e返回其值，表长-1；</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、ClearList(*L) <span class="comment">//将线性表清空；</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="线性表的顺序存储结构——顺序表"><a href="#线性表的顺序存储结构——顺序表" class="headerlink" title="线性表的顺序存储结构——顺序表"></a>线性表的顺序存储结构——顺序表</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>线性表的顺序存储结构，指的是用一段地址连续的储存单元依次储存线性表的数据元素；</p>
<h3 id="顺序储存方式"><a href="#顺序储存方式" class="headerlink" title="顺序储存方式"></a>顺序储存方式</h3><p>先来看看结构代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000  <span class="comment">//储存空间初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	ElemType data[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> length;  <span class="comment">//线性表当前长度</span></span><br><span class="line">}SqList;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i, ElemType* e)</span> <span class="comment">//获得元素——&gt;e返回L中第i个数据元素的值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span> || i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	*e = L.data[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(SqList* L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">//插入操作——&gt;在L中第i个位置之前插入新的数据元素e，L的长度加1</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;length == MAXSIZE) <span class="comment">//线性表已满</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length + <span class="number">1</span>) <span class="comment">//i不在范围内</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= L-&gt;length) <span class="comment">//插入的元素不在表尾 (可加if可不加)</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (k = L-&gt;length - <span class="number">1</span>; k &gt;= i - <span class="number">1</span>; k--)</span><br><span class="line">		{</span><br><span class="line">			L-&gt;data[k + <span class="number">1</span>] = L-&gt;data[k];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	L-&gt;data[i - <span class="number">1</span>] = e; <span class="comment">//新元素插入</span></span><br><span class="line">	L-&gt;length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(SqList* L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">//删除操作</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;length == <span class="number">0</span>) <span class="comment">//线性表为空</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length) <span class="comment">//删除位置不正确</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	*e = L-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (i &lt; L-&gt;length) <span class="comment">//删除不是最后位置</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (k = i; k &lt; L-&gt;length; k++) <span class="comment">//删除位置后继元素前移</span></span><br><span class="line">		{</span><br><span class="line">			L-&gt;data[k - <span class="number">1</span>] = L-&gt;data[k];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	L-&gt;length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong><em>1、优点：</em></strong></p>
<p><strong><em>①无需为表中元素之间的逻辑关系增加额外的储存空间；</em></strong></p>
<p><strong><em>②可以快速的存取表中任意位置的元素；</em></strong></p>
<p><strong><em>2、缺点：</em></strong></p>
<p><strong><em>①插入和删除操作需要移动大量元素；</em></strong></p>
<p><strong><em>②当线性表长度变化较大时，难以确定储存空间的容量；</em></strong></p>
<p><strong><em>③造成储存空间的“碎片”；</em></strong></p>
<h2 id="线性表的链式储存结构——链表"><a href="#线性表的链式储存结构——链表" class="headerlink" title="线性表的链式储存结构——链表"></a>线性表的链式储存结构——链表</h2><p>链表在之前的博客里面已经整理了一部分，在这里再整理一遍吧；</p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>先定义一个结构体</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">}Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">LinkList</span>;</span> <span class="comment">//定义LinkList</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType* e)</span> <span class="comment">//用e返回L中第i个数据元素的值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	LinkList p;   <span class="comment">//声明指针p</span></span><br><span class="line">	p = L-&gt;next;  <span class="comment">//p指向链表L的第一个节点</span></span><br><span class="line">	j = <span class="number">1</span>;    <span class="comment">//j为计数器</span></span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; j &lt; i) <span class="comment">//p不为空且计数器j还没有等于i时，循环继续</span></span><br><span class="line">	{</span><br><span class="line">		p = p-&gt;next; <span class="comment">//p指向下一个节点</span></span><br><span class="line">		++j;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (!p || j &gt; i)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//第i个节点不存在</span></span><br><span class="line">	}</span><br><span class="line">	*e = p-&gt;data;  <span class="comment">//取第i个节点的数据</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(LinkList* L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">//在L的第i个节点之前插入元素e，L的长度加1</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	LinkList p,s;</span><br><span class="line">	p = *L;</span><br><span class="line">	j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; j &lt; i) <span class="comment">//寻找第i-1个节点</span></span><br><span class="line">	{</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		++j;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (!p || j &lt; i)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//第i个节点不存在</span></span><br><span class="line">	}</span><br><span class="line">	s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//生成新节点</span></span><br><span class="line">	s-&gt;data = e;</span><br><span class="line">	s-&gt;next = p-&gt;next;  <span class="comment">//将p的后继节点赋值给s的后继</span></span><br><span class="line">	p-&gt;next = s;  <span class="comment">//将s赋值给p的后继</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkDelete</span><span class="params">(LinkList* L, <span class="keyword">int</span> i, ElemType* e)</span> <span class="comment">//删除L中的第i个节点，并用e返回其值，L的长度减1</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	LinkList p, q;</span><br><span class="line">	p = *L;</span><br><span class="line">	j = i;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i) <span class="comment">//遍历寻找第i-1个节点</span></span><br><span class="line">	{</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		++j;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (!(p-&gt;next) || j &gt; i)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//第i个节点不存在</span></span><br><span class="line">	}</span><br><span class="line">	q = p-&gt;next;</span><br><span class="line">	p-&gt;next = q-&gt;next; <span class="comment">//将q的后继赋值给p的后继</span></span><br><span class="line">	*e = q-&gt;data;   <span class="comment">//将q节点中的数据给e</span></span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h4><h5 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListHead</span><span class="params">(LinkList* L, <span class="keyword">int</span> n)</span> <span class="comment">//随机产生n个元素的值，建立带表头节点的单链线性表L（头插法）</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkList p;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	srand(time(<span class="number">0</span>));  <span class="comment">//初始化随机种子</span></span><br><span class="line">	*L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	(*L)-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//先建立一个带头结点的单链表</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	{</span><br><span class="line">		p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//生成新节点</span></span><br><span class="line">		p-&gt;data = rand() % <span class="number">100</span> + <span class="number">1</span>;  <span class="comment">//随机生成100以内的数字</span></span><br><span class="line">		p-&gt;next = (*L)-&gt;next;</span><br><span class="line">		(*L)-&gt;next = p;   <span class="comment">//插入到表头</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListTail</span><span class="params">(LinkList* L, <span class="keyword">int</span> n)</span><span class="comment">//随机产生n个元素的值，建立带表头节点的单链线性表L（尾插法）</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkList p, r;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	srand(time(<span class="number">0</span>));</span><br><span class="line">	*L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	r = *L;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	{</span><br><span class="line">		p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//生成新节点</span></span><br><span class="line">		p-&gt;data = rand() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">		r-&gt;next = p;  <span class="comment">//将表尾终端节点的指针指向新节点</span></span><br><span class="line">		r = p;  <span class="comment">//将当前的新节点定义为表尾终端节点</span></span><br><span class="line">	}</span><br><span class="line">	r-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//表示当前链表结束</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="清空链表"><a href="#清空链表" class="headerlink" title="清空链表"></a>清空链表</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ClearList</span><span class="params">(LinkList* L)</span> <span class="comment">//单链表的整表删除，将L置为空表</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkList p, q;</span><br><span class="line">	p = (*L)-&gt;next; <span class="comment">//p指向第一个节点</span></span><br><span class="line">	<span class="keyword">while</span> (p)  <span class="comment">//没到表尾</span></span><br><span class="line">	{</span><br><span class="line">		q = p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		p = q;</span><br><span class="line">	}</span><br><span class="line">	(*L)-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//头结点指针域为空</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h4><p><strong><em>1、存储分配方式</em></strong></p>
<p>​        <strong><em>①顺序存储结构一般用一段连续的存储单元依次存储线性表的数据元素</em></strong></p>
<p>​        <strong><em>②单链表采用链式存储结构，用一组任意的存储大单元存放线性表的元素</em></strong></p>
<p><strong><em>2、时间性能</em></strong></p>
<p><strong><em>①查找</em></strong></p>
<p><strong><em>ⅰ顺序存储结构O(1)</em></strong></p>
<p><strong><em>ⅱ单链表O(n)</em></strong></p>
<p><strong><em>②插入和删除</em></strong></p>
<p>​        <strong><em>ⅰ顺序存储结构需要平均移动表长一半的元素，时间为o(n)</em></strong></p>
<p>​        <strong><em>ⅱ单链表在线出某位置的指针后，插入和删除时间仅为o(1)</em></strong></p>
<p><strong><em>③空间性能</em></strong></p>
<p>​        <strong><em>ⅰ顺序存储结构需要预分配存储空间，分大了，浪费，分小了，易发生上溢</em></strong></p>
<p>​        <strong><em>ⅱ单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制</em></strong></p>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>用数组描述的链表叫做静态链表 ；</p>
<p>具体描述：首先让数组的两个元素都是由两个数据域组成，data和cur；也就是说，数组的每个下标都对应一个</p>
<p>data和cur；数据域data，用来存放数据元素,也就是通常我们要处理的数据；而cur相当于链表中的next指针，存</p>
<p>放该元素的后继在数组中的下标，我们把cur叫做游标；</p>
<p>小注：这里我理解的游标就是next那根链，元素的游标指向下一个数值的下标；;</p>
<h3 id="静态链表存储结构"><a href="#静态链表存储结构" class="headerlink" title="静态链表存储结构"></a>静态链表存储结构</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000 <span class="comment">// 假设链表最大长度是1k</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">int</span> cur; <span class="comment">//游标，为0时表示无指向</span></span><br><span class="line">}StaticLinkList[MAXSIZE];</span><br></pre></td></tr></tbody></table></figure>

<h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><p>0-998游标从1-999，最后一个游标为0</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitLink</span><span class="params">(StaticLinkList space)</span> <span class="comment">//将一位数组space中各分量链成一备用链表，space[0].cur为头指针，"0"表示空指针</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		space[i].cur = i + <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	space[MAXSIZE - <span class="number">1</span>].cur = <span class="number">0</span>; <span class="comment">//目前静态链表为空，最后一个元素的cur为0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注：</p>
<p>​    我们通常把未使用的数组元素成为备用链表；</p>
<p>​    数组的第一个元素，即下标为0的那个元素的cur就存放备用链表的第一个节点的下标；</p>
<p>​    数组的最后一个元素，即下标为MAXSIZE-1的cur则存放第一个有数值的元素的下标，相当于头节点的作用；</p>
<h3 id="获取链表中元素的个数"><a href="#获取链表中元素的个数" class="headerlink" title="获取链表中元素的个数"></a>获取链表中元素的个数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = L[MAXSIZE - <span class="number">1</span>].cur; <span class="comment">//最后一个元素的游标，从头循环计数</span></span><br><span class="line">	<span class="keyword">while</span> (i) <span class="comment">//循环计数，找到空闲分量即停止循环</span></span><br><span class="line">	{</span><br><span class="line">		i = L[i].cur; </span><br><span class="line">		j++;  <span class="comment">//计数</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="静态链表的插入操作"><a href="#静态链表的插入操作" class="headerlink" title="静态链表的插入操作"></a>静态链表的插入操作</h3><h4 id="获得空闲分量的下标"><a href="#获得空闲分量的下标" class="headerlink" title="获得空闲分量的下标"></a>获得空闲分量的下标</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SSL</span><span class="params">(StaticLinkList space)</span> <span class="comment">//若备用空间链表为空，则返回分配的节点下标，否则返回0</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> i = space[<span class="number">0</span>].cur; <span class="comment">//当前数组第一个元素cur存的值，就是要返回的第一个备用空闲的下标</span></span><br><span class="line">	<span class="keyword">if</span> (space[<span class="number">0</span>].cur)</span><br><span class="line">	{</span><br><span class="line">		space[<span class="number">0</span>].cur = space[i].cur; <span class="comment">// 由于要拿出一个分量来使用，所以我们就得把它的下一个分量用来做备用</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">// 在L中第i个元素之前插入新的数据元素e</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> j, k, l;</span><br><span class="line">	k = MAXSIZE - <span class="number">1</span>;  <span class="comment">//k是最后一个元素的下标</span></span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;Listlength(L) + <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	j = Malloc_SSL(L);  <span class="comment">//获得空闲分量的下标</span></span><br><span class="line">	<span class="keyword">if</span> (j)</span><br><span class="line">	{</span><br><span class="line">		L[j].data = e; <span class="comment">//将数值赋值给此分量的data</span></span><br><span class="line">		<span class="keyword">for</span> (l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; l++)  <span class="comment">//找到第i个元素之前的位置</span></span><br><span class="line">		{</span><br><span class="line">			k = L[k].cur;</span><br><span class="line">		}</span><br><span class="line">		L[j].cur = L[k].cur;  <span class="comment">//把第i个元素之前的cur赋值给新元素的cur</span></span><br><span class="line">		L[k].cur = j;  <span class="comment">//把新元素的下标赋值给第i个元素之前元素的cur</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="静态链表的删除操作"><a href="#静态链表的删除操作" class="headerlink" title="静态链表的删除操作"></a>静态链表的删除操作</h3><h4 id="回收节点"><a href="#回收节点" class="headerlink" title="回收节点"></a>回收节点</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SSL</span><span class="params">(StaticLinkList space,<span class="keyword">int</span> k)</span><span class="comment">//将下标为k的空闲节点回收到备用链表</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	space[k].cur = space[<span class="number">0</span>].cur; <span class="comment">//把第一个元素cur值赋给要删除的分量cur</span></span><br><span class="line">	space[<span class="number">0</span>].cur = k; <span class="comment">//把要删除的分量下标赋给第一个元素的cur</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i)</span> <span class="comment">// 删除L中第i个元素e</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> j, k;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;ListLength(L))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	}</span><br><span class="line">	k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line">	{</span><br><span class="line">		k = L[k].cur;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// j &gt; k</span></span><br><span class="line">	j = L[k].cur;  <span class="comment">//L[k].cur指向删除元素的下标，赋值给j</span></span><br><span class="line">	L[k].cur = L[j].cur;  <span class="comment">//被删除元素的游标赋值给前一个元素的游标，实现连接</span></span><br><span class="line">	Free_SSL(L, j); <span class="comment">//回收</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="静态链表优缺点"><a href="#静态链表优缺点" class="headerlink" title="静态链表优缺点"></a>静态链表优缺点</h3><p><strong><em>1、优点：</em></strong></p>
<p>​        <strong><em>●在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作</em></strong></p>
<p><strong><em>需要移动大量元素的缺点</em></strong></p>
<p><strong><em>2、缺点：</em></strong></p>
<p>​        <strong><em>●没有解决连续存储分配带来的表长难以确定的问题</em></strong></p>
<p>​        <strong><em>●失去了顺序存储结构随机存取的特性</em></strong></p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>双向链表是在单链表的每个节点中，再设置一个指向其前驱节点的指针域，前驱后继方向都能遍历；</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>* <span class="title">prior</span>;</span>  <span class="comment">//直接前驱指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>* <span class="title">next</span>;</span>  <span class="comment">//直接后继指针</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>显然，与单链表相比，多了一个直接前驱；</p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>循环链表——首尾相连的链表；</p>
<p>将单链表中终端节点的指针端由空指针改为指向头节点，就使整个单链表形成一个环。这种头尾相接的单链表称为</p>
<p>单循环链表，简称循环链表；</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>循环链表中，从任一节点出发都可以访问到表中所有节点，在单链表中，必须从头指针开始，否则无法访问到该节</p>
<p>点之前的其他节点；</p>
<p>循环链表好像用处不太大，就不多说了；</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>这一章节是线性表，线性表对于以后学习的数据结构会有很大作用；选择使用哪种线性表，结合情况再定，各有利</p>
<p>弊；   // 下一章学习栈，不见不散；</p>
<p>Bye~~</p>
<h1 id="栈—Stack"><a href="#栈—Stack" class="headerlink" title="栈—Stack"></a><u>栈</u>—Stack</h1><p>线性表总的来说是挺简单的（和链表差不多），学好线性表才可以继续学习哦~</p>
<p>下面我们开始学习栈</p>
<h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><p><u><strong><em>栈是限定仅在表尾进行插入和删除操作的线性表；</em></strong></u></p>
<p>允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈，栈又称为后进先出线性表，</p>
<p>简称LIFO结构；</p>
<h2 id="栈的抽象数据类型——基本操作-入栈-出栈"><a href="#栈的抽象数据类型——基本操作-入栈-出栈" class="headerlink" title="栈的抽象数据类型——基本操作( 入栈 出栈 )"></a>栈的抽象数据类型——基本操作( 入栈 出栈 )</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、InitStack(*S) <span class="comment">//初始化操作，建立一个空栈</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、DestroyStack(*S) <span class="comment">//若栈存在，则销毁它</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、ClearStack(*S) <span class="comment">//将栈清空</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、StackEmpty(*S) <span class="comment">//若栈为空，返回true，否则返回false</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、GetTop(S, *e) <span class="comment">//若栈存在且非空，用e返回S的栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、Push(*S, e) <span class="comment">//若栈S存在，插入新元素e到栈S中并成为栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、Pop(*S, *e) <span class="comment">//删除栈S中栈顶元素，并用e返回其值</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、StackLength(S) <span class="comment">//返回栈S的元素个数</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h2><h3 id="结构代码"><a href="#结构代码" class="headerlink" title="结构代码"></a>结构代码</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	DataType data[MAXSIZE]; <span class="comment">//栈的元素最大个数</span></span><br><span class="line">	<span class="keyword">int</span> top; <span class="comment">//用于栈顶指针</span></span><br><span class="line">}SqStack;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="初始化栈"><a href="#初始化栈" class="headerlink" title="初始化栈"></a>初始化栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack* S)</span> <span class="comment">//初始化栈</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	S-&gt;top = <span class="number">-1</span>; <span class="comment">//初始化栈为空</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="判断栈是否已满"><a href="#判断栈是否已满" class="headerlink" title="判断栈是否已满"></a>判断栈是否已满</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackFull</span><span class="params">(SqStack* S)</span> <span class="comment">//判断栈是否已满</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (S-&gt;top == MaxSIZE - <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(SqStack* S)</span> <span class="comment">//判断栈是否为空</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(SqStack* S, DataType e)</span> <span class="comment">//进栈操作 插入元素e为新的栈顶元素</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (StackFull(S)) <span class="comment">//栈满</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	S-&gt;top++; <span class="comment">//栈顶指针增加1</span></span><br><span class="line">	S-&gt;data[S-&gt;top] = e; <span class="comment">//新插入元素赋值给栈顶空间</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(SqStack* S, DataType* e)</span> <span class="comment">//出栈操作 若栈不为空，则删除栈顶元素，用e返回其值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (StackEmpty(S)) <span class="comment">//栈空</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	*e = S-&gt;data[S-&gt;top]; <span class="comment">//将要删除的元素赋值给e</span></span><br><span class="line">	S-&gt;top--; <span class="comment">//栈顶指针减少1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h2><h3 id="结构代码-1"><a href="#结构代码-1" class="headerlink" title="结构代码"></a>结构代码</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	DataType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">next</span>;</span></span><br><span class="line">}LinkStack;</span><br></pre></td></tr></tbody></table></figure>



<h3 id="初始化栈-1"><a href="#初始化栈-1" class="headerlink" title="初始化栈"></a>初始化栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkStack* <span class="title">InitStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkStack* S;</span><br><span class="line">	S = <span class="literal">NULL</span>; <span class="comment">//初始化栈为空</span></span><br><span class="line">	<span class="keyword">return</span> S;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="判断栈是否为空-1"><a href="#判断栈是否为空-1" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EmptyStack</span><span class="params">(LinkStack* S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (S == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="进栈-1"><a href="#进栈-1" class="headerlink" title="进栈"></a>进栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(LinkStack* S, DataType e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkStack* p = (LinkStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">	p-&gt;data = e; <span class="comment">//e放入新节点的数据域</span></span><br><span class="line">	p-&gt;next = S; <span class="comment">//新节点插入链表表头之前</span></span><br><span class="line">	S = p; <span class="comment">//新节点作为栈顶</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(LinkStack* S, DataType* e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkStack* p;</span><br><span class="line">	<span class="keyword">if</span> (EmptyStack(S))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	*e = S-&gt;data; <span class="comment">//栈顶元素赋值给e</span></span><br><span class="line">	p = S; <span class="comment">//p节点指向原栈顶S</span></span><br><span class="line">	S = S-&gt;next; <span class="comment">//原栈顶S指向其下一个节点</span></span><br><span class="line">	<span class="built_in">free</span>(p); <span class="comment">//释放原栈顶空间</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">(LinkStack* S, DataType* e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (EmptyStack(S)) <span class="comment">//栈为空</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	*e = S-&gt;data; <span class="comment">//栈顶元素赋给变量e</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="遍历栈"><a href="#遍历栈" class="headerlink" title="遍历栈"></a>遍历栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowStack</span><span class="params">(LinkStack* S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkStack* p = S;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"栈为空\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>, p-&gt;data);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>栈相对来说就是比较特殊的线性表罢了，接下来要学习的队列，也是一种特殊的线性表；让我们拭目以待 // Bye~ </p>
<h1 id="队列—Queue"><a href="#队列—Queue" class="headerlink" title="队列—Queue"></a>队列—Queue</h1><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><p><u><strong><em>队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表；</em></strong></u></p>
<p>队列是一种先进先出的线性表，简称FIFO；允许插入的一端称为队尾，允许删除的一端称为队头；</p>
<h2 id="队列的抽象数据类型——基本操作"><a href="#队列的抽象数据类型——基本操作" class="headerlink" title="队列的抽象数据类型——基本操作"></a>队列的抽象数据类型——基本操作</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、InitQueue(*Q) <span class="comment">//初始化操作，建立一个空队列</span></span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>、DestroyQueue(*Q) <span class="comment">//若队列Q存在，则销毁</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>、ClearQueue(*Q) <span class="comment">//将队列Q清空</span></span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>、QueueEmpty(Q) <span class="comment">//若队列为空，返回true，否则返回false</span></span><br><span class="line">    </span><br><span class="line"><span class="number">5</span>、GetHead(Q,*e) <span class="comment">//若队列存在且非空，用e返回Q的队头元素</span></span><br><span class="line">    </span><br><span class="line"><span class="number">6</span>、EnQueu(*Q,e) <span class="comment">//若队列存在，则插入e于Q，并成为队尾元素</span></span><br><span class="line">    </span><br><span class="line"><span class="number">7</span>、DeQueue(*Q,*e) <span class="comment">// 删除队列Q中队头元素，并用e返回其值</span></span><br><span class="line">    </span><br><span class="line"><span class="number">8</span>、QueueLength(Q) <span class="comment">//返回队列Q中元素个数</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><h3 id="队列顺序存储的不足"><a href="#队列顺序存储的不足" class="headerlink" title="队列顺序存储的不足"></a>队列顺序存储的不足</h3><p>与栈不同的是，队列的出列是在队头，那就意味着，队列的所有元素都得移动，以保证下标为0的位置不为空，此</p>
<p>时间复杂度为O(n);</p>
<p>为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，</p>
<p>rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列；</p>
<p>假溢出：说白了就是数组末尾元素已满，再向后加就越界，而队列前面还有空位的现象（0,1,2….空着）；</p>
<h3 id="循环队列定义"><a href="#循环队列定义" class="headerlink" title="循环队列定义"></a>循环队列定义</h3><p>头尾相接顺序存储结构称为循环队列；</p>
<p>设队列最大长度为QueueSize，那么：</p>
<p>队列满的条件为(rear+1) % QueueSize == front ;</p>
<p>队空条件为front == rear ;</p>
<p>队列长度计算公式为(rear-front+QueueSize) % QueueSize ; (自己推导式子很简单)</p>
<h3 id="循环队列顺序存储结构"><a href="#循环队列顺序存储结构" class="headerlink" title="循环队列顺序存储结构"></a>循环队列顺序存储结构</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	DataType data[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> front; <span class="comment">//头指针</span></span><br><span class="line">	<span class="keyword">int</span> rear; <span class="comment">//尾指针，若队列不变，指向队列尾元素的下一个位置</span></span><br><span class="line">}SqQueue;</span><br></pre></td></tr></tbody></table></figure>



<h3 id="队列初始化"><a href="#队列初始化" class="headerlink" title="队列初始化"></a>队列初始化</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span> <span class="comment">//初始化一个对列</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Q-&gt;front = <span class="number">0</span>;</span><br><span class="line">	Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="队列长度"><a href="#队列长度" class="headerlink" title="队列长度"></a>队列长度</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span> <span class="comment">//求队列长度</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> (Q.rear - Q.front + MAXSIZE) % MAXSIZE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(SqQueue* Q, DataType e)</span> <span class="comment">//若队列未满则e入列</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXSIZE == Q-&gt;front) <span class="comment">//队列已满</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	Q-&gt;data[Q-&gt;rear] = e; <span class="comment">//e赋值给队尾</span></span><br><span class="line">	Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZE; <span class="comment">//rear指针后移一个位置，若到最后则转到数组头部</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(SqQueue* Q, DataType* e)</span> <span class="comment">//若队列不空则删除队头，并用e返回其值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (Q-&gt;front == Q-&gt;near) <span class="comment">//队列为空</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	*e = Q-&gt;data[Q-&gt;front]; <span class="comment">//将队头元素赋值给e</span></span><br><span class="line">	Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXSIZE; <span class="comment">//front指针向后移一位置，若到最后则转到数组头部</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h2><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列；</p>
<h3 id="链式队列存储结构"><a href="#链式队列存储结构" class="headerlink" title="链式队列存储结构"></a>链式队列存储结构</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">qnode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	DataType data; <span class="comment">//节点的数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qnode</span>* <span class="title">next</span>;</span> <span class="comment">//节点的指针域</span></span><br><span class="line">}LinkListQ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	LinkListQ* front, * rear; <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">}LinkQueue;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="队列初始化-1"><a href="#队列初始化-1" class="headerlink" title="队列初始化"></a>队列初始化</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkQueue* <span class="title">InitQueue</span><span class="params">()</span> <span class="comment">//队列初始化</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkQueue* Q;</span><br><span class="line">	LinkListQ* p;</span><br><span class="line">	Q = (LinkQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkQueue)); <span class="comment">//头指针所指节点</span></span><br><span class="line">	p = (LinkListQ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkListQ)); <span class="comment">//头节点</span></span><br><span class="line">	Q-&gt;front = p; <span class="comment">//Q指针所指的front指针指向p</span></span><br><span class="line">	Q-&gt;rear = p; <span class="comment">//Q指针所指的rear指针指向p</span></span><br><span class="line">	<span class="keyword">return</span> Q;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(LinkQueue* Q, DataType e)</span> <span class="comment">//插入e于队尾</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkListQ* s;</span><br><span class="line">	s = (LinkListQ)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkListQ)); <span class="comment">//分配内存空间</span></span><br><span class="line">	s-&gt;data = e; <span class="comment">//将e存入新节点的数据域</span></span><br><span class="line">	s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	Q-&gt;rear-&gt;next = s; <span class="comment">//将新节点插入链队之后</span></span><br><span class="line">	Q-&gt;rear = s; <span class="comment">//队尾指针指向队尾元素</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(LinkQueue* Q, DataType* e)</span> <span class="comment">//删除队头，用e返回其值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkListQ* p;</span><br><span class="line">	<span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) <span class="comment">//队空</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	p = Q-&gt;front-&gt;next; <span class="comment">//p指向队头元素</span></span><br><span class="line">	*e = p-&gt;data; <span class="comment">//队头元素的值赋给e</span></span><br><span class="line">	Q-&gt;front-&gt;next = p-&gt;next; <span class="comment">//原队头节点后继p-&gt;next赋给头节点后继</span></span><br><span class="line">	<span class="keyword">if</span> (Q-&gt;rear == p)<span class="comment">/*p-&gt;next==NULL*/</span> <span class="comment">//队头等于队尾，删除后将rear指向头节点</span></span><br><span class="line">	{</span><br><span class="line">		Q-&gt;rear = Q-&gt;front; <span class="comment">//此时队空</span></span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>对于循环队列和链队列的比较，可以从两方面，从时间上看，它们基本操作都是常数时间，都为O(1)，从空间看，</p>
<p>循环队列必须有一个固定的长度，就有了存储元素个数和空间资源浪费的问题，而链队列不存在这个问题；尽管需</p>
<p>要一个指针域，需要空间，但是可以接受，所以空间上链队列更加灵活；</p>
<p>总的来说，在可以确定队列长度最大值的情况下，建议使用循环队列，无法估计队列长度时则用链队列；</p>
<p>下面要学习线性结构的最后一种 — 串； Waiting for me！Bye~</p>
<h1 id="串—String"><a href="#串—String" class="headerlink" title="串—String"></a>串—String</h1><p>字符串，大家都不陌生对吧，学习C语言的时候就讲过了，编程题中常常遇到，这里所学习的串和字符串的用法基本一致，无非就是改改名称，优化算法，hhhh；</p>
<h2 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h2><p>串是由零个或多个字符组成的有限序列，又名叫字符串；</p>
<p>串中的字符数目n称为串的长度；</p>
<p>零个字符的串称为空串，可以用两双引号””表示，也可以用希腊字母Ø表示；</p>
<h2 id="串的抽象数据类型"><a href="#串的抽象数据类型" class="headerlink" title="串的抽象数据类型"></a>串的抽象数据类型</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、StrAssign(S, *chars) <span class="comment">//生成一个值等于chars的串S</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、StrCopy(S,T) <span class="comment">//串T复制得串S</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、StrLength(S) <span class="comment">//串S的长度，即S中的元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、StrCat(S,T) <span class="comment">//串T连接在串S后面</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、SubString(Sub,S,pos,len) <span class="comment">//用Sub返回串S的第pos个字符起长度为len的子串</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、StrIndex(S,T) <span class="comment">//若串S中存在与串T相同的子串，则返回它在串S中第一次出现的位置，否则返回代表错误的值</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、StrInsert(S,pos,T) <span class="comment">//在串S的第pos个字符插入串T</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、StrDelete(S,pos,len) <span class="comment">//从串S中删除第pos个字符起长度为len的子串</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>、StrReplace(S,T,V) <span class="comment">//用串V替换串S中出现得到所有与T相等的不重叠子串</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>、StrEmpty(S) <span class="comment">//若串S为空串，则返回1，否则返回0</span></span><br><span class="line"></span><br><span class="line"><span class="number">11</span>、StrCompare(S,T) <span class="comment">//若S&gt;T，则返回值&gt;0,若S=T，则返回值=0,若S&lt;T，则返回值&lt;0</span></span><br><span class="line"></span><br><span class="line"><span class="number">12</span>、StrClear(S) <span class="comment">//将串S清空</span></span><br><span class="line"></span><br><span class="line"><span class="number">13</span>、DispStr(S) <span class="comment">//显示串S的所有字符</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><p>串的存储结构也是分为顺序存储结构和链式存储结构，重点讲顺序存储结构，即定长顺序串；</p>
<h3 id="结构代码-2"><a href="#结构代码-2" class="headerlink" title="结构代码"></a>结构代码</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">char</span> ch[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> Len;</span><br><span class="line">}<span class="keyword">String</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrLength</span><span class="params">(<span class="keyword">String</span>* S)</span> <span class="comment">//求字符串S长度</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (S-&gt;ch[i] != <span class="string">'\0'</span>)</span><br><span class="line">	{</span><br><span class="line">		i++;</span><br><span class="line">	}</span><br><span class="line">	S-&gt;Len = i;</span><br><span class="line">	<span class="keyword">return</span> (S-&gt;Len);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="建立新串"><a href="#建立新串" class="headerlink" title="建立新串"></a>建立新串</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateStr</span><span class="params">(<span class="keyword">String</span>* S)</span> <span class="comment">//建立一个新串</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	gets(S-&gt;ch);</span><br><span class="line">	S-&gt;Len = StrLength(S);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="求子串函数"><a href="#求子串函数" class="headerlink" title="求子串函数"></a>求子串函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SubString</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">String</span>* Sub, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span> <span class="comment">//求子串函数，用Sub返回串S的第pos个字符起长度为len的子串</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;S-&gt;Len || len&lt;<span class="number">1</span> || len&gt;S-&gt;Len - pos + <span class="number">1</span>) <span class="comment">//范围错误</span></span><br><span class="line">	{</span><br><span class="line">		Sub-&gt;Len = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"ERROR\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">		{</span><br><span class="line">			Sub-&gt;ch[j] = S-&gt;ch[pos + j - <span class="number">1</span>]; <span class="comment">//新串Sub赋值</span></span><br><span class="line">		}</span><br><span class="line">		Sub-&gt;ch[j] = <span class="string">'\0'</span>; <span class="comment">//新串尾部加上字符串结束标志</span></span><br><span class="line">		Sub-&gt;Len = len; <span class="comment">//规定长度</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="删除子串"><a href="#删除子串" class="headerlink" title="删除子串"></a>删除子串</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrDelete</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">int</span> i, <span class="keyword">int</span> l)</span> <span class="comment">//删除子串，在S中删除第i开始连续l个字符</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">if</span> (i + l - <span class="number">1</span> &gt; S-&gt;Len)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"子串超界"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (k = i + l - <span class="number">1</span>; k &lt; S-&gt;Len; k++, i++) <span class="comment">//从第i位开始删除长度为l个字符</span></span><br><span class="line">		{</span><br><span class="line">			S-&gt;ch[i - <span class="number">1</span>] = S-&gt;ch[k];</span><br><span class="line">		}</span><br><span class="line">		S-&gt;Len = S-&gt;Len - l; <span class="comment">//长度-l</span></span><br><span class="line">		S-&gt;ch[S-&gt;Len] = <span class="string">'\0'</span>; <span class="comment">//新串尾部加上字符串结束标志</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="插入子串"><a href="#插入子串" class="headerlink" title="插入子串"></a>插入子串</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrInsert</span><span class="params">(<span class="keyword">String</span> *S,<span class="keyword">String</span> *T,<span class="keyword">int</span> i)</span> <span class="comment">//串S中第i个字符插入子串T</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; S-&gt;Len + <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"插入位置错误"</span>)；</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(S-&gt;Len+T-&gt;Len&gt;MAXSIZE)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"两串长度超过存储空间长度"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (k = S-&gt;Len - <span class="number">1</span>; k &gt;= i - <span class="number">1</span>; k--) <span class="comment">//将第i位开始的字符各向后移动T串长度</span></span><br><span class="line">		{</span><br><span class="line">			S-&gt;ch[T-&gt;Len + k] = S-&gt;ch[k];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; T-&gt;Len; k++) <span class="comment">//将子串T插入到串S的第i位处</span></span><br><span class="line">		{</span><br><span class="line">			S-&gt;ch[i + k - <span class="number">1</span>] = T-&gt;ch[k];</span><br><span class="line">		}</span><br><span class="line">		S-&gt;Len = S-&gt;Len + T-&gt;Len; <span class="comment">//修改串S的长度</span></span><br><span class="line">		S-&gt;ch[S-&gt;Len] = <span class="string">'\0'</span>; <span class="comment">//新串S尾部加上字符串结束标志</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="定位子串"><a href="#定位子串" class="headerlink" title="定位子串"></a>定位子串</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrIndex</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">String</span>* T)</span> <span class="comment">//串的定位函数，若串S中存在与串T相同的子串，则返回它在串S中第一次出现的位置(第几个字符，不是下标)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; S-&gt;Len &amp;&amp; j &lt; T-&gt;Len) <span class="comment">//当两串指针没指向该串尾时进行比较</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (S-&gt;ch[i] == T-&gt;ch[j])</span><br><span class="line">		{</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			i = i - j + <span class="number">1</span>;</span><br><span class="line">			j = <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (j &gt;= T-&gt;Len) <span class="comment">//串S中有串T</span></span><br><span class="line">	{</span><br><span class="line">		k = i - T-&gt;Len + <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		k = <span class="number">-1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> k;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCompare</span><span class="params">(<span class="keyword">String</span>* S1, <span class="keyword">String</span>* S2)</span><span class="comment">//判断两个串是否相等</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (S1-&gt;ch[i] != <span class="string">'\0'</span> &amp;&amp; S2-&gt;ch[i] != <span class="string">'\0'</span>) <span class="comment">//当两串没到串尾部时</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (S1-&gt;ch[i] != S2-&gt;ch[i]) <span class="comment">//两串对应位置的字符是否相同</span></span><br><span class="line">		{</span><br><span class="line">			flag = <span class="number">1</span>; <span class="comment">//标志置为1</span></span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">//结束循环</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			i++; <span class="comment">//计数</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; S1-&gt;Len == S2-&gt;Len) <span class="comment">//两串长度相同且所有字符都相同，两串相等</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> S1-&gt;ch[i] - S2-&gt;ch[i]; <span class="comment">//返回对应第一个不相同位置字符ASCII码差值</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCat</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">String</span>* T)</span> <span class="comment">//连接函数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> i, flag;</span><br><span class="line">	<span class="keyword">if</span> (S-&gt;Len + T-&gt;Len &lt;= MAXSIZE) <span class="comment">//连接后串长小于MAXSIZE</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (i = S-&gt;Len; i &lt; S-&gt;Len + T-&gt;Len; i++)</span><br><span class="line">		{</span><br><span class="line">			S-&gt;ch[i] = T-&gt;ch[i - S-&gt;Len]; <span class="comment">//赋值连接</span></span><br><span class="line">		}</span><br><span class="line">		S-&gt;ch[i] = <span class="string">'\0'</span>;</span><br><span class="line">		S-&gt;Len += T-&gt;Len; <span class="comment">//长度相加</span></span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (S-&gt;Len &lt; MAXSIZE) <span class="comment">//连接后串长大于MAXSIZE，但串S长度小于MAXSIZE，连接后串T部分字符序列被舍弃</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (i = S-&gt;Len; i &lt; MAXSIZE; i++)</span><br><span class="line">		{</span><br><span class="line">			S-&gt;ch[i] = T-&gt;ch[i - S-&gt;Len];</span><br><span class="line">		}</span><br><span class="line">		S-&gt;Len = MAXSIZE;</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//串S的长度等于MAXSIZE，串T不被连接</span></span><br><span class="line">	{</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="子串替换"><a href="#子串替换" class="headerlink" title="子串替换"></a>子串替换</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrReplace</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">String</span>* T, <span class="keyword">String</span>* V)</span> <span class="comment">//子串替换，用串V替换串S中出现得到所有与T相等的不重叠子串</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> i, m, n, p, q;</span><br><span class="line">	n = S-&gt;Len;</span><br><span class="line">	m = T-&gt;Len;</span><br><span class="line">	q = V-&gt;Len;</span><br><span class="line">	p = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> {</span><br><span class="line">		i = StrIndex(S, T); <span class="comment">//调用定位函数得到子串T在子串S的位置</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i != <span class="number">-1</span>) <span class="comment">//当主串S有该子串T时</span></span><br><span class="line">		{</span><br><span class="line">			StrDelete(S, i, m); <span class="comment">//删除子串T</span></span><br><span class="line">			StrInsert(S, V, i); <span class="comment">//插入子串V</span></span><br><span class="line">			p = i + q;</span><br><span class="line">			S-&gt;Len = S-&gt;Len + q - m; <span class="comment">//修改主串S的长度</span></span><br><span class="line">			n = S-&gt;Len;+</span><br><span class="line">		}</span><br><span class="line">	} <span class="keyword">while</span> ((p &lt;= n - m + <span class="number">1</span>) &amp;&amp; (i != <span class="number">-1</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>串这部分内容呢比较简单，后面还有广义表和KMP算法，这里先不讲了；下周直接学非线性结构；</p>
<p>Bye Bye~</p>
<h1 id="树—Tree"><a href="#树—Tree" class="headerlink" title="树—Tree"></a>树—Tree</h1><p>早就对 ”树“ 有所耳闻了，今日一会，果然名不虚传；</p>
<h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p>树（Tree）是n（n≥0）个结点的有限集；n=0时称为空树；在任意一棵非空树中：</p>
<p>(1) 有且仅有一个特定的称为根（Root）的结点；</p>
<p>(2) 当n&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵</p>
<p>树，并且称为根的子树（SubTree）；</p>
<h3 id="树的表示方法"><a href="#树的表示方法" class="headerlink" title="树的表示方法"></a>树的表示方法</h3><p>1、树形表示法：使用一棵倒置的树表示，如下图（1）所示；</p>
<p>2、嵌套集合表示法：使用集合以及集合的包含关系描述树结构，如图（2）所示；</p>
<p>3、凹入表表示法：使用线段的伸缩关系描述树的结构，如图（3）所示；</p>
<p>4、广义表表示法：将树的根结点写在括号的左边 ，除根结点外的其余结点写在括号内并用逗号间隔来描述树的结</p>
<p>构，如图（4）所示；</p>
<p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png" alt="树的表示方法"></p>
<h3 id="树的基本术语z"><a href="#树的基本术语z" class="headerlink" title="树的基本术语z"></a>树的基本术语z</h3><p><strong>(１) 结点———树的结点包含一个数据元素及若干指向其子树的分支；</strong></p>
<p><strong>(２) 结点的度———结点所拥有的分支数目或后继结点个数称为该结点的度；</strong> </p>
<p><strong>(３) 树的度———树中各结点度的最大值称为该树的度；</strong></p>
<p><strong>(４) 叶结点 (终端结点) ———度为零的结点称为叶结点；</strong></p>
<p><strong>(５) 分支结点 (非终端结点) ———度不为零的结点称为分支结点；</strong></p>
<p><strong>(６) 孩子、双亲结点———一个结点的子树的根称为该结点的孩子；该结点称为孩子的双亲；</strong></p>
<p><strong>( 7 ) 兄弟结点———同一双亲结点下的孩子结点互称为兄弟结点；</strong></p>
<p><strong>( 8 ) 堂兄弟———双亲互为兄弟的两个结点互称为堂兄弟；</strong></p>
<p><strong>( 9 ) 子孙结点———一个结点的所有子树中的结点称之为该结点的子孙结点；</strong></p>
<p><strong>(10) 祖先结点———从树根结点到达一个结点的路径上的所有结点称为该结点的祖先结点</strong></p>
<p><strong>(11) 结点的层次———树的根结点的层次为１，其余结点的层次等于它双亲结点的层次加１；（某结点在第L层，</strong></p>
<p><strong>它的子树的根就在L+1层）；</strong></p>
<p><strong>(12) 树的深度———树中结点的最大层次称为树的深度 (或高度)；</strong></p>
<p><strong>(13) 有序树和无序树———如果一棵树中的结点的各子树从左到右是有次序的， 即若交换了某结点各子树的相对</strong></p>
<p><strong>位置， 则构成了不同的树， 称这样的树为有序树，反之， 则为 无序树；</strong></p>
<p><strong>(14) 森林———ｍ (ｍ≥０) 棵互不相交树的集合称为森林；</strong></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h3><p><strong>二叉树（Binary Tree）是有n（n≥0）个结点的有限集合；该集合或者为空集（称为空二叉树），或者由一个</strong></p>
<p><strong>根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成；</strong></p>
<h3 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h3><p><strong>1、每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点；</strong></p>
<p><strong>2、左子树和右子树是有顺序的，次序不能任意颠倒；</strong></p>
<p><strong>3、即使树中某结点只有一颗子树，也要区分它是左子树还是右子树；</strong></p>
<h3 id="二叉树的基本形态"><a href="#二叉树的基本形态" class="headerlink" title="二叉树的基本形态"></a>二叉树的基本形态</h3><p>二叉树具有5种基本形态：</p>
<p>1、空二叉树</p>
<p>2、只要一个根结点</p>
<p>3、根结点只有左子树</p>
<p>4、根结点只有右子树</p>
<p>5、根结点既有左子树又有右子树</p>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p><strong>● 在二叉树的第i层上至多有2^(i-1)个结点（i≥0）;</strong></p>
<p><strong>● 深度为k的二叉树至多有2^k - 1个结点（k≥1）；</strong></p>
<p><strong>● 对任意一棵二叉树T， 如果其叶子结点数为n0，度为２的结点数为n2，则有n0 = n2+1;</strong></p>
<p><strong>● 具有ｎ个结点的完全二叉树的深度为[log2n]+1;([x]为不大于x的最大整数)</strong></p>
<p><strong>● 如果一棵有ｎ个结点的完全二叉树 (其深度为[log2n]+1) 的结点按层次编号 (从第1层到第[log2n]+1层，每层从左到右) 则对任一结点ｉ (1≤ｉ≤ｎ) 有:</strong> </p>
<p>​        <strong>➀ 如果 i＝1， 结点ｉ是根结点， 无双亲； 如果ｉ&gt;1， 则其双亲结点是结点i/2；</strong></p>
<p>​        <strong>➁ 如果 2i&gt;ｎ， 则结点ｉ无左孩子， 该结点为叶子结点， 否则其左孩子是结点2i ；</strong></p>
<p>​        <strong>➂ 如果 2i+1&gt;ｎ， 则结点ｉ无右孩子， 该结点为叶子结点， 否则其右孩子是结点 2i＋1；</strong></p>
<h3 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h3><h4 id="斜树"><a href="#斜树" class="headerlink" title="斜树"></a>斜树</h4><h5 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h5><p>所有的结点都是只有左子树的二叉树叫做左斜树，所有的结点都是只有右子树的二叉树叫做右斜树；这两者统称为</p>
<p>斜树；</p>
<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><p>每一层都只有一个结点，结点的个数与二叉树的深度相同；</p>
<p>如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%96%9C%E6%A0%91.png" alt="斜树"></p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><h5 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h5><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二</p>
<p>叉树；</p>
<h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><p>满二叉树很符合强迫症患者，其特点有：</p>
<p>1、叶子只能出现在最下一层，出现在其它层就不可能达成平衡 ；</p>
<p>2、非叶子结点的度一定是2，否则就是“缺胳膊少腿”了；</p>
<p>3、在同样的深度的二叉树中，满二叉树的结点个数最多，叶子数最多；</p>
<p>如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="满二叉树"></p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><h5 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h5><p>对一棵具有n个结点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在</p>
<p>二叉树中位置完全相同，则这课二叉树称为完全二叉树；</p>
<h5 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h5><p>1、叶子结点只能出现在最下两层；</p>
<p>2、最下面的叶子一定集中在左部连续位置；</p>
<p>3、倒数二层，若有叶子结点，一定都在右部连续位置；</p>
<p>4、如果结点度为1，则该结点只有左孩子，即不存在只有右孩子的情况；</p>
<p>5、同样结点数的二叉树，完全二叉树的深度最小；</p>
<p>如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="完全二叉树"></p>
<p>// 判断某二叉树是否为完全二叉树：给每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空档，就说明不</p>
<p>是完全二叉树，否则就是；</p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h4><p>二叉树的顺存储结构就是用一位数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点</p>
<p>之间的逻辑关系；编号过程：首先，把树的根节点的编号定为1，然后按照层次从上到下，从左到右的顺序对每一</p>
<p>结点进行编号，当一个结点的双亲结点的编号为i时，若它是左孩子，则编号为2i，若它是右孩子，则编号为2i+1;</p>
<p>但是这种存储结构会浪费大量的空间，一般适用于完全二叉树；</p>
<h4 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h4><h5 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h5><p>二叉树的每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，我们称这样的链表叫做二叉链表；</p>
<h5 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、InitTree(*T) <span class="comment">//构造空树T</span></span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>、DestroyTree(*T) <span class="comment">//销毁树T</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>、CreateTree(*T,definition) <span class="comment">//按definition中给出树的定义来构造树</span></span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>、ClearTree(*T) <span class="comment">//若树T存在，则将树T清空为空树</span></span><br><span class="line">    </span><br><span class="line"><span class="number">5</span>、TreeEmpty(T) <span class="comment">//若树为空树，返回true，否则返回false</span></span><br><span class="line">    </span><br><span class="line"><span class="number">6</span>、TreeDepth(T) <span class="comment">//返回T的深度</span></span><br><span class="line">    </span><br><span class="line"><span class="number">7</span>、Root(T) <span class="comment">//返回T的根节点</span></span><br><span class="line">    </span><br><span class="line"><span class="number">8</span>、Value(T,cur_e) <span class="comment">//cur_e是树T中一个结点，返回此结点的值</span></span><br><span class="line">    </span><br><span class="line"><span class="number">9</span>、Assign(T,cur_e,value) <span class="comment">//给树T的结点cur_e赋值为value</span></span><br><span class="line">    </span><br><span class="line"><span class="number">10</span>、Parent(T,cur_e) <span class="comment">//若cur_e是树T的非根结点，则返回它的双亲，否则返回空</span></span><br><span class="line">    </span><br><span class="line"><span class="number">11</span>、LsftChild(T,cur_e) <span class="comment">//若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空</span></span><br><span class="line">    </span><br><span class="line"><span class="number">12</span>、RightSibling(T,cur_e) <span class="comment">//若cur_e有右兄弟，则返回它的右兄弟，否则返回空</span></span><br><span class="line">    </span><br><span class="line"><span class="number">13</span>、InsertChild(*T,*p,i,c) <span class="comment">//其中p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为输入c为树T中p指结点的第i棵子树</span></span><br><span class="line">    </span><br><span class="line"><span class="number">14</span>、DeleteChild(*T,*p,i) <span class="comment">//其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	DataType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line">}BTNode,*BTree;</span><br></pre></td></tr></tbody></table></figure>



<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h4><p><strong>二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次；</strong></p>
<p>以这棵树为例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="遍历二叉树"></p>
<h4 id="前序遍历（DLR）"><a href="#前序遍历（DLR）" class="headerlink" title="前序遍历（DLR）"></a>前序遍历（DLR）</h4><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p><strong>若二叉树为空，遍历结束，否则依次执行以下操作：</strong></p>
<p><strong>1、访问根结点</strong></p>
<p><strong>2、先序遍历根结点的左子树</strong></p>
<p><strong>3、先序遍历根结点的右子树</strong></p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BTree T)</span> <span class="comment">//前序遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data); <span class="comment">//显示结点数据</span></span><br><span class="line">	PreOrderTraverse(T-&gt;lchild); <span class="comment">//先序遍历左子树</span></span><br><span class="line">	PreOrderTraverse(T-&gt;rchild); <span class="comment">//先序遍历右子树</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>先序遍历输出为：<code>ABDGHCEIF</code></p>
<h4 id="中序遍历（LDR）"><a href="#中序遍历（LDR）" class="headerlink" title="中序遍历（LDR）"></a>中序遍历（LDR）</h4><h5 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h5><p><strong>若二叉树为空，遍历结束，否则依次执行以下操作：</strong></p>
<p><strong>1、中序遍历根结点的左子树</strong></p>
<p><strong>2、访问根结点</strong></p>
<p><strong>3、中序遍历根结点的右子树</strong></p>
<h5 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BTree T)</span> <span class="comment">//中序遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	InOrderTraverse(T-&gt;lchild); <span class="comment">//中序遍历左子树</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data); <span class="comment">//显示结点数据</span></span><br><span class="line">	InOrderTraverse(T-&gt;rchild); <span class="comment">//中序遍历右子树</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h5><p>中序遍历输出为：<code>BGDHAEICF</code></p>
<h4 id="后序遍历（LRD）"><a href="#后序遍历（LRD）" class="headerlink" title="后序遍历（LRD）"></a>后序遍历（LRD）</h4><h5 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h5><p><strong>若二叉树为空，遍历结束，否则依次执行以下操作：</strong></p>
<p><strong>1、后序遍历根结点的左子树</strong></p>
<p><strong>2、后序遍历根结点的右子树</strong></p>
<p><strong>3、访问根结点</strong> </p>
<h5 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BTree T)</span> <span class="comment">//后序遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	PostOrderTraverse(T-&gt;lchild); <span class="comment">//后序遍历左子树</span></span><br><span class="line">	PostOrderTraverse(T-&gt;rchild); <span class="comment">//后序遍历右子树</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data); <span class="comment">//显示结点数据</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h5><p>后序遍历输出为：<code>GHDBIEFCA</code></p>
<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><h5 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h5><p><strong>若二叉树为空，遍历结束，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问；</strong></p>
<h5 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraverse</span><span class="params">(BTree T)</span> <span class="comment">//层序遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> front, rear; <span class="comment">//定义队头队尾指针</span></span><br><span class="line">	BTree p, q[MAX]; <span class="comment">//定义循环队列，存放结点指针</span></span><br><span class="line">	p = T;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) <span class="comment">//若二叉树为空，则根结点地址入队</span></span><br><span class="line">	{</span><br><span class="line">		front = <span class="number">1</span>;</span><br><span class="line">		q[front] = p;</span><br><span class="line">		rear = <span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span> (front != rear) <span class="comment">//队列不为空</span></span><br><span class="line">	{</span><br><span class="line">		p = q[front];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data); <span class="comment">//访问队首结点的数据域</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>) <span class="comment">//将队首结点的左孩子入列</span></span><br><span class="line">		{</span><br><span class="line">			q[rear] = p-&gt;lchild;</span><br><span class="line">			rear = (rear + <span class="number">1</span>) % MAX;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>) <span class="comment">//将队首结点的右孩子入列</span></span><br><span class="line">		{</span><br><span class="line">			q[rear] = p-&gt;rchild;</span><br><span class="line">			rear = (rear + <span class="number">1</span>) % MAX;</span><br><span class="line">		}</span><br><span class="line">		front = (front + <span class="number">1</span>) % MAX;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h5><p>层序遍历的输出为：<code>ABCDEFGHI</code></p>
<h3 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h3><h4 id="特殊处理"><a href="#特殊处理" class="headerlink" title="特殊处理"></a>特殊处理</h4><p>为了让树的每个结点确认是否有左右孩子，我们对它进行了扩展，将空结点赋值 “#” ，我们成这种处理后的二叉树为原二叉树的扩展二叉树，所以就会得到类似于“AB##C#D###”的序列；</p>
<p>算法</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBTree</span><span class="params">(BTree* T)</span> <span class="comment">//建立二叉树</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	DataType ch;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;ch);</span><br><span class="line">	<span class="keyword">if</span> (ch == <span class="string">'#'</span>)</span><br><span class="line">	{</span><br><span class="line">		*T = <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		*T = (BTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">		<span class="keyword">if</span> (!*T)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		}</span><br><span class="line">		(*T)-&gt;data = ch; <span class="comment">//生成根结点</span></span><br><span class="line">		CreateBTree(&amp;(*T)-&gt;lchild); <span class="comment">//构造左子树</span></span><br><span class="line">		CreateBTree(&amp;(*T)-&gt;rchild); <span class="comment">//构造右子树</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="统计二叉树叶子结点的数目"><a href="#统计二叉树叶子结点的数目" class="headerlink" title="统计二叉树叶子结点的数目"></a>统计二叉树叶子结点的数目</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Leafnodenum</span><span class="params">(BTree T)</span> <span class="comment">//统计二叉树叶子结点的数目</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">		{</span><br><span class="line">			count1++; <span class="comment">//全局变量计数，初始化为0</span></span><br><span class="line">		}</span><br><span class="line">		Leafnodenum(T-&gt;lchild); <span class="comment">//递归统计左子树叶子结点的数量</span></span><br><span class="line">		Leafnodenum(T-&gt;rchild); <span class="comment">//递归统计右子树叶子结点的数量</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="统计二叉树结点总数"><a href="#统计二叉树结点总数" class="headerlink" title="统计二叉树结点总数"></a>统计二叉树结点总数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Nodetotalnum</span><span class="params">(BTree T)</span> <span class="comment">//统计二叉树结点总数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	{</span><br><span class="line">		count2++; <span class="comment">//全局变量计数，初始化为0</span></span><br><span class="line">		Nodetotalnum(T-&gt;lchild); <span class="comment">//递归统计左子树结点数</span></span><br><span class="line">		Nodetotalnum(T-&gt;rchild); <span class="comment">//递归统计右子树结点数</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="求二叉树的深度"><a href="#求二叉树的深度" class="headerlink" title="求二叉树的深度"></a>求二叉树的深度</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(BTree T)</span> <span class="comment">//求二叉树的深度</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span>  ldep, rdep; <span class="comment">//定义两个整型变量，用以存放左、右子树的深度</span></span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		ldep = TreeDepth(T-&gt;lchild); <span class="comment">//递归统计左子树深度</span></span><br><span class="line">		rdep = TreeDepth(T-&gt;rchild); <span class="comment">//递归统计右子树深度</span></span><br><span class="line">		<span class="keyword">if</span> (ldep &gt; rdep)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> ldep + <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> rdep + <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><strong>对于一个有n个结点的二叉链表，每个结点有指向左右孩子的两个指针域，所以一共是2n个指针域，而n个结点的</strong></p>
<p><strong>二叉树一共有n-1条分支线数，也就是说，其实是存在2n-(n-1) = n+1个空指针域，这些空间不存储任何事物，白</strong></p>
<p><strong>白地浪费内存资源；因此，提出一种方法，利用原来的空指针域存放指针，指向树中其他结点；</strong></p>
<h3 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h3><p><strong>二叉树中所有空指针域的lchild，改为指向当前结点的前驱，把空指针域中的rchild，改为指向结点的后继；</strong></p>
<p><strong>我们把指向前驱和后继的指针叫做线索 ，加上线索的二叉树就称之为线索二叉树。</strong></p>
<h3 id="线索化"><a href="#线索化" class="headerlink" title="线索化"></a>线索化</h3><p><strong>我们对二叉树以某种次序遍历使其变为线索二叉树的过程称作是线索化；</strong></p>
<h3 id="存储结构-2"><a href="#存储结构-2" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>  <span class="comment">//这个是一个枚举类型</span></span><br><span class="line">{</span><br><span class="line">	Link,Thread <span class="comment">//Link=0表示指向左右孩子指针，Thread表示指向前驱或后继的线索</span></span><br><span class="line">}PointerTag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BThrTreeNode</span> //二叉线索存储结点结构</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	DataType data; <span class="comment">//结点数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BThrTreeNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span> <span class="comment">//左右孩子指针</span></span><br><span class="line">	PointerTag L_Tag; <span class="comment">//左右标志</span></span><br><span class="line">	PointerTag R_Tag; <span class="comment">//左右标志</span></span><br><span class="line">}BThrTreeNode, * BThrTree;</span><br></pre></td></tr></tbody></table></figure>

<p>所以线索化的过程就是在遍历的过程中修改空指针的过程=_=</p>
<h3 id="中序遍历线索化"><a href="#中序遍历线索化" class="headerlink" title="中序遍历线索化"></a>中序遍历线索化</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BThrTree pre; <span class="comment">//全局变量，始终指向刚刚访问过的结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BThrTree p)</span> <span class="comment">//中序遍历进行中序线索化</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (p)</span><br><span class="line">	{</span><br><span class="line">		InThreading(p-&gt;lchild); <span class="comment">//递归左子树线索化</span></span><br><span class="line">		<span class="keyword">if</span> (!p-&gt;lchild) <span class="comment">//没有左孩子</span></span><br><span class="line">		{</span><br><span class="line">			p-&gt;L_Tag = Thread; <span class="comment">//前驱线索</span></span><br><span class="line">			p-&gt;lchild = pre; <span class="comment">//左孩子指针指向前驱</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (!pre-&gt;rchild) <span class="comment">//前驱没有右孩子</span></span><br><span class="line">		{</span><br><span class="line">			pre-&gt;R_Tag = Thread; <span class="comment">//后继线索</span></span><br><span class="line">			pre-&gt;rchild = p; <span class="comment">//前驱右孩子指针指向后继（当前结点p）</span></span><br><span class="line">		}</span><br><span class="line">		pre = p; <span class="comment">//保持pre指向p的前驱</span></span><br><span class="line">		InThreading(p-&gt;rchild); <span class="comment">//递归右子树线索化</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="中序遍历线索二叉树"><a href="#中序遍历线索二叉树" class="headerlink" title="中序遍历线索二叉树"></a>中序遍历线索二叉树</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BThrTree T)</span> <span class="comment">//中序遍历二叉线索链表表示的二叉树</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	BThrTree p;</span><br><span class="line">	p = T-&gt;lchild; <span class="comment">//p指向根结点</span></span><br><span class="line">	<span class="keyword">while</span> (p != T) <span class="comment">//空树或者遍历结束时，p==T</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">while</span> (p-&gt;L_Tag == Link) <span class="comment">//当L_Tag==0时循环到中序序列第一个结点</span></span><br><span class="line">		{</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data); <span class="comment">//显示结点数据，可以更改为其他对结点操作</span></span><br><span class="line">		<span class="keyword">while</span> (p-&gt;R_Tag == Thread &amp;&amp; p-&gt;rchild != T)</span><br><span class="line">		{</span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);</span><br><span class="line">		}</span><br><span class="line">		p = p-&gt;rchild; <span class="comment">//p进至其右子树根</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h2><p>前面已经见过树的定义和存储结构，对于树来讲，可以是任意形状，一个结点可以有很多孩子，复杂很多，于是引</p>
<p>入了二叉树，这个就方便很多了；二叉树只有左右两个孩子，这样的话，面对的变化就少了，如果所有的树都能变</p>
<p>成二叉树就好了😅别说，还真可以：</p>
<h3 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h3><p>一般来讲，树转换为二叉树有以下几步：</p>
<p>1、加线：在所有兄弟结点之间加一条线；</p>
<p>2、去线：对树中的每个结点，只保留它与第一个孩子结点之间的连线，删除它与其他孩子结点之间的连线；</p>
<p>3、旋转：以树的根节点为轴心，将整棵树顺时针旋转45°，使之成为二叉树；</p>
<p><strong>如图所示：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="树转换为二叉树"></p>
<h3 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h3><p>森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作，方法如下：</p>
<p>1、把每棵树转换成二叉树；</p>
<p>2、第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵树的根结点的右孩子，用</p>
<p>线连接起来，当所有的二叉树连接起来后就得到了由森林转换来的二叉树；</p>
<p><strong>如图所示：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="森林转换为二叉树"></p>
<h3 id="二叉树还原为树"><a href="#二叉树还原为树" class="headerlink" title="二叉树还原为树"></a>二叉树还原为树</h3><p>二叉树还原为树就是树转换为二叉树的逆过程，直接反过来做就可以</p>
<p>步骤如下：</p>
<p>1、加线：若某结点的左孩子结点存在，则将这个左孩子的右孩子结点，右孩子的右孩子结点，右孩子的右孩子的</p>
<p>右孩子结点….哈哈，就是左孩子的n个右孩子结点都作为结点的孩子，将该结点与这些右孩子结点用线连接起来；</p>
<p>2、去线：删除原二叉树中所有结点与其右孩子结点的连线；</p>
<p>3、旋转：旋转得到树</p>
<p><strong>如图所示：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%98%E5%8E%9F%E4%B8%BA%E6%A0%91.png" alt="二叉树还原为树"></p>
<h3 id="二叉树还原为森林"><a href="#二叉树还原为森林" class="headerlink" title="二叉树还原为森林"></a>二叉树还原为森林</h3><p>判断一棵二叉树能够转换成树还是森林，很简单，只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就</p>
<p>是一棵树，如果是森林，步骤如下：</p>
<p>1、从根结点开始，若右孩子存在，则把它与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则</p>
<p>连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树；</p>
<p>2、再将每棵分离后的二叉树转换为树即可；</p>
<p><strong>如图所示：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%98%E5%8E%9F%E4%B8%BA%E6%A3%AE%E6%9E%97.png" alt="二叉树还原为森林"></p>
<h2 id="二叉树应用"><a href="#二叉树应用" class="headerlink" title="二叉树应用"></a>二叉树应用</h2><p><strong><em>赫夫曼树</em></strong></p>
<p><strong><em>赫夫曼编码</em></strong></p>
<h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>这一章讲的是树🌳，重点学习了二叉树，要牢牢掌握其算法，再了解一下它的应用</p>
<p>emm 下一章讲 “图” ，这个是一点没有接触过的内容了😀</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p><strong>end</strong>  </p>
<p><strong>goodbye~</strong></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Los-kos</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.los-kos.cn/2020/02/15/shu-ju-jie-gou/">https://www.los-kos.cn/2020/02/15/shu-ju-jie-gou/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.los-kos.cn" target="_blank">Los-Kos</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/img/featureimages/18.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/w.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/z.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/02/17/ctf-gong-ju/"><img class="prev_cover" src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/img/featureimages/3.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CTF常用工具汇总</div></div></a></div><div class="next-post pull_right"><a href="/2020/02/14/hello-world/"><img class="next_cover" src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/img/featureimages/1.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="/js/valine.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: '4eTTwcW4LbmtC9nSWqAbekph-gzGzoHsz',
  appKey: 'k1vFce20H7t5wsbsAY4xd1R7',
  notify: false,
  verify: false,
  placeholder: '(●ˇ∀ˇ●)ノ来都来了 留个脚印再走吧（昵称填写QQ有惊喜哦）',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Los-kos</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hello！ Welcome to los-kos's blog ！！</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="/js/third-party/click_heart.js"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script></body></html>