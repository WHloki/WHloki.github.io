<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>汇编语言基础 | Los-Kos</title><meta name="description" content="汇编初识"><meta name="keywords" content="汇编"><meta name="author" content="Los-kos"><meta name="copyright" content="Los-kos"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/whloki/cdn@master/img/avatar.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="汇编语言基础"><meta name="twitter:description" content="汇编初识"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/img/featureimages/19.jpg"><meta property="og:type" content="article"><meta property="og:title" content="汇编语言基础"><meta property="og:url" content="https://www.los-kos.cn/posts/huibian/"><meta property="og:site_name" content="Los-Kos"><meta property="og:description" content="汇编初识"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/img/featureimages/19.jpg"><meta property="article:published_time" content="2020-07-10T02:05:34.000Z"><meta property="article:modified_time" content="2020-07-18T10:48:27.062Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://www.los-kos.cn/posts/huibian/"><link rel="prev" title="C++一些常用语法" href="https://www.los-kos.cn/posts/c/"><link rel="next" title="educoder课设作业" href="https://www.los-kos.cn/posts/educoder/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8156eb470c2d34104408dd52ad3f8182";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://www.los-kos.cn/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"I,Love,You,我喜欢你,很喜欢你,超级超级喜欢你","fontSize":"18px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Los-Kos" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="Los-Kos" type="application/rss+xml">
<link rel="stylesheet" href="/css/prism-shades-of-purple.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/whloki/cdn@master/img/avatar.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础知识"><span class="toc-number">1.</span> <span class="toc-text"> 基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#机器语言"><span class="toc-number">1.1.</span> <span class="toc-text"> 机器语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#汇编语言"><span class="toc-number">1.2.</span> <span class="toc-text"> 汇编语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#汇编语言的产生"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 汇编语言的产生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#汇编语言的组成"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 汇编语言的组成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#寄存器"><span class="toc-number">2.</span> <span class="toc-text"> 寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#通用寄存器"><span class="toc-number">2.1.</span> <span class="toc-text"> 通用寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字"><span class="toc-number">2.2.</span> <span class="toc-text"> 字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#几条汇编指令"><span class="toc-number">2.3.</span> <span class="toc-text"> 几条汇编指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#物理地址"><span class="toc-number">2.4.</span> <span class="toc-text"> 物理地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段寄存器"><span class="toc-number">2.5.</span> <span class="toc-text"> 段寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cs和ip"><span class="toc-number">2.6.</span> <span class="toc-text"> CS和IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#修改cs和ip得到指令"><span class="toc-number">2.7.</span> <span class="toc-text"> 修改CS和IP得到指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dosbox的使用"><span class="toc-number">3.</span> <span class="toc-text"> DOSBox的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#debug"><span class="toc-number">3.1.</span> <span class="toc-text"> Debug</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#debug功能"><span class="toc-number">3.2.</span> <span class="toc-text"> Debug功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dosbox使用方法"><span class="toc-number">3.3.</span> <span class="toc-text"> DOSBox使用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#寄存器内存访问"><span class="toc-number">4.</span> <span class="toc-text"> 寄存器（内存访问）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ds和address"><span class="toc-number">4.1.</span> <span class="toc-text"> DS和[address]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mov-add-sub指令"><span class="toc-number">4.2.</span> <span class="toc-text"> mov、add、sub指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu提供的栈机制"><span class="toc-number">4.3.</span> <span class="toc-text"> CPU提供的栈机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#push过程"><span class="toc-number">4.3.1.</span> <span class="toc-text"> push过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pop过程"><span class="toc-number">4.3.2.</span> <span class="toc-text"> pop过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈顶超界问题"><span class="toc-number">4.4.</span> <span class="toc-text"> 栈顶超界问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第一个程序"><span class="toc-number">5.</span> <span class="toc-text"> 第一个程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个小程序"><span class="toc-number">5.1.</span> <span class="toc-text"> 一个小程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#各部分的含义"><span class="toc-number">5.2.</span> <span class="toc-text"> 各部分的含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序的执行"><span class="toc-number">5.3.</span> <span class="toc-text"> 程序的执行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bx和loop指令"><span class="toc-number">6.</span> <span class="toc-text"> [BX]和loop指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bx"><span class="toc-number">6.1.</span> <span class="toc-text"> [BX]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loop指令"><span class="toc-number">6.2.</span> <span class="toc-text"> loop指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编程举例"><span class="toc-number">6.2.1.</span> <span class="toc-text"> 编程举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段前缀"><span class="toc-number">6.3.</span> <span class="toc-text"> 段前缀</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#包含多个段的程序"><span class="toc-number">7.</span> <span class="toc-text"> 包含多个段的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#在代码段中使用数据"><span class="toc-number">7.1.</span> <span class="toc-text"> 在代码段中使用数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在代码段中使用栈"><span class="toc-number">7.2.</span> <span class="toc-text"> 在代码段中使用栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将数据-代码-栈放入不同的段"><span class="toc-number">7.3.</span> <span class="toc-text"> 将数据、代码、栈放入不同的段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#更灵活的定位内存地址的方法"><span class="toc-number">8.</span> <span class="toc-text"> 更灵活的定位内存地址的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#and和or指令"><span class="toc-number">8.1.</span> <span class="toc-text"> and和or指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#and指令"><span class="toc-number">8.1.1.</span> <span class="toc-text"> and指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#or指令"><span class="toc-number">8.1.2.</span> <span class="toc-text"> or指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#大小写转化问题"><span class="toc-number">8.2.</span> <span class="toc-text"> 大小写转化问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bxidata"><span class="toc-number">8.3.</span> <span class="toc-text"> [bx+idata]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用bxidata的方式处理数组"><span class="toc-number">8.4.</span> <span class="toc-text"> 用[bx+idata]的方式处理数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#si和di"><span class="toc-number">8.5.</span> <span class="toc-text"> SI和DI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bxsi和bxdi"><span class="toc-number">8.6.</span> <span class="toc-text"> [bx+si]和[bx+di]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bxsiidata和bxdiidata"><span class="toc-number">8.7.</span> <span class="toc-text"> [bx+si+idata]和[bx+di+idata]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不同的寻址方式的灵活运用"><span class="toc-number">8.8.</span> <span class="toc-text"> 不同的寻址方式的灵活运用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据处理的两个基本问题"><span class="toc-number">9.</span> <span class="toc-text"> 数据处理的两个基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bx-si-di和bp"><span class="toc-number">9.1.</span> <span class="toc-text"> bx、si、di和bp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#机器指令处理的数据在什么地方"><span class="toc-number">9.2.</span> <span class="toc-text"> 机器指令处理的数据在什么地方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#汇编语言中数据位置的表达"><span class="toc-number">9.3.</span> <span class="toc-text"> 汇编语言中数据位置的表达</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#寻址方式"><span class="toc-number">9.4.</span> <span class="toc-text"> 寻址方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指令处理的数据"><span class="toc-number">9.5.</span> <span class="toc-text"> 指令处理的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dup"><span class="toc-number">9.6.</span> <span class="toc-text"> dup</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#转移指令"><span class="toc-number">10.</span> <span class="toc-text"> 转移指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#操作符offset"><span class="toc-number">10.1.</span> <span class="toc-text"> 操作符offset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jmp指令"><span class="toc-number">10.2.</span> <span class="toc-text"> jmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转移地址在内存中的jmp指令"><span class="toc-number">10.3.</span> <span class="toc-text"> 转移地址在内存中的jmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jcxz指令"><span class="toc-number">10.4.</span> <span class="toc-text"> jcxz指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loop指令-2"><span class="toc-number">10.5.</span> <span class="toc-text"> loop指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#call和ret指令"><span class="toc-number">11.</span> <span class="toc-text"> CALL和RET指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ret和retf"><span class="toc-number">11.1.</span> <span class="toc-text"> ret和retf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call"><span class="toc-number">11.2.</span> <span class="toc-text"> call</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call指令的主要应用格式"><span class="toc-number">11.3.</span> <span class="toc-text"> call指令的主要应用格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#依据位移进行转移的call指令"><span class="toc-number">11.3.1.</span> <span class="toc-text"> 依据位移进行转移的call指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转移目的地址在指令中的call指令"><span class="toc-number">11.3.2.</span> <span class="toc-text"> 转移目的地址在指令中的call指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转移地址在寄存器中的call指令"><span class="toc-number">11.3.3.</span> <span class="toc-text"> 转移地址在寄存器中的call指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转移地址在内存中的call指令"><span class="toc-number">11.3.4.</span> <span class="toc-text"> 转移地址在内存中的call指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mul和div指令"><span class="toc-number">11.4.</span> <span class="toc-text"> mul和div指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mul"><span class="toc-number">11.4.1.</span> <span class="toc-text"> mul</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#div"><span class="toc-number">11.4.2.</span> <span class="toc-text"> div</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#标志寄存器"><span class="toc-number">12.</span> <span class="toc-text"> 标志寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#zf标志"><span class="toc-number">12.1.</span> <span class="toc-text"> ZF标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pf标志"><span class="toc-number">12.2.</span> <span class="toc-text"> PF标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sf标志"><span class="toc-number">12.3.</span> <span class="toc-text"> SF标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cf标志"><span class="toc-number">12.4.</span> <span class="toc-text"> CF标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#of标志"><span class="toc-number">12.5.</span> <span class="toc-text"> OF标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#adc指令"><span class="toc-number">12.6.</span> <span class="toc-text"> adc指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sbb指令"><span class="toc-number">12.7.</span> <span class="toc-text"> sbb指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cmp指令"><span class="toc-number">12.8.</span> <span class="toc-text"> cmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#df-标志"><span class="toc-number">12.9.</span> <span class="toc-text"> DF 标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pushf和popf"><span class="toc-number">12.10.</span> <span class="toc-text"> pushf和popf</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内中断"><span class="toc-number">13.</span> <span class="toc-text"> 内中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内中断的产生"><span class="toc-number">13.1.</span> <span class="toc-text"> 内中断的产生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断向量表"><span class="toc-number">13.2.</span> <span class="toc-text"> 中断向量表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断过程"><span class="toc-number">13.3.</span> <span class="toc-text"> 中断过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断处理程序和iret指令"><span class="toc-number">13.4.</span> <span class="toc-text"> 中断处理程序和iret指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#int指令"><span class="toc-number">14.</span> <span class="toc-text"> int指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#int指令-2"><span class="toc-number">14.1.</span> <span class="toc-text"> int指令</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/img/featureimages/19.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Los-Kos</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">汇编语言基础</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-10 10:05:34"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-07-10</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-18 18:48:27"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-18</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%B1%87%E7%BC%96/">汇编</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">10.7k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 38 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"> <div class="post-content" id="article-container"><p>这篇文章，记录下学习汇编的过程，记录一些需要记忆的知识。</p>
<a id="more"></a>
<h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1>
<h2 id="机器语言"><a class="markdownIt-Anchor" href="#机器语言"></a> 机器语言</h2>
<p>说汇编语言之前，先简单说说机器语言：机器语言是机器指令的集合。机器指令展开来讲就是一台机器执行的命令。像电子计算机，机器指令就是一列一列的二进制数字，计算机可以处理这些数据进行运算。</p>
<h2 id="汇编语言"><a class="markdownIt-Anchor" href="#汇编语言"></a> 汇编语言</h2>
<h3 id="汇编语言的产生"><a class="markdownIt-Anchor" href="#汇编语言的产生"></a> 汇编语言的产生</h3>
<p>不难看出，机器语言无论是书写还是计算都很麻烦，也难于辨别和记忆，所以产生了汇编语言。</p>
<p>汇编语言的主体是汇编指令，这种指令有别于机器指令，在于它便于书写和记忆。</p>
<p><em><strong>例如：</strong></em></p>
<p><em><strong>操作：寄存器BX的内容送到AX中</strong></em></p>
<p><em><strong>机器指令：1000100111011000</strong></em></p>
<p><em><strong>汇编指令：mov ax,bx</strong></em></p>
<p>汇编语言的方便之处很容易看出了吧</p>
<h3 id="汇编语言的组成"><a class="markdownIt-Anchor" href="#汇编语言的组成"></a> 汇编语言的组成</h3>
<p>汇编语言有3类指令组成：</p>
<p>1、汇编指令：机器码的助记符，有相应的机器码。</p>
<p>2、伪指令：没有对应的机器码，由编译器执行，计算机并不执行。</p>
<p>3、其他符号：例如+、-、*、/等，由编译器识别，没有对应的机器码。</p>
<h1 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h1>
<h2 id="通用寄存器"><a class="markdownIt-Anchor" href="#通用寄存器"></a> 通用寄存器</h2>
<p>8086CPU的所有寄存器都是16位的，可以存放2个字节。</p>
<p>通用寄存器有4个：AX、BX、CX、DX，每一个又可以分为两个可以独立使用的8位寄存器来使用：</p>
<p>● AX可以分为AH和AL;</p>
<p>● BX可以分为BH和BL;</p>
<p>● CX可以分为CH和CL;</p>
<p>● DX可以分为DH和DL;</p>
<blockquote>
<p>H是高位，L是低位，AH寄存器存储的是AX的高8位，AL寄存器存储的是AX的低8位</p>
</blockquote>
<blockquote>
<p>寄存器的名称在编码的时候大小写均可以</p>
</blockquote>
<h2 id="字"><a class="markdownIt-Anchor" href="#字"></a> 字</h2>
<p>● 字节： 记为byte，一个字节由8个bit组成，可以存在8位寄存器中。</p>
<p>● 字： 记为word，一个字由两个字节组成，分别称为这个字的高位字节和低位字节。</p>
<h2 id="几条汇编指令"><a class="markdownIt-Anchor" href="#几条汇编指令"></a> 几条汇编指令</h2>
<table>
<thead>
<tr>
<th style="text-align:center">汇编指令</th>
<th style="text-align:center">控制CPU完成的操作</th>
<th style="text-align:center">高级语言语法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mov ax,1000H</td>
<td style="text-align:center">将1000H送入寄存器AX</td>
<td style="text-align:center">AX=1000H</td>
</tr>
<tr>
<td style="text-align:center">mov ax,bx</td>
<td style="text-align:center">将寄存器BX中的数据送入寄存器AX中</td>
<td style="text-align:center">AX=BX</td>
</tr>
<tr>
<td style="text-align:center">add ax,bx</td>
<td style="text-align:center">将AX和BX中的数值相加，结果存在AX</td>
<td style="text-align:center">AX=AX+BX</td>
</tr>
</tbody>
</table>
<h2 id="物理地址"><a class="markdownIt-Anchor" href="#物理地址"></a> 物理地址</h2>
<p>CPU中的相关部件有两个16位地址：一个称为段地址，另一个称为偏移地址；</p>
<p><strong>物理地址 = 段地址 x 16 + 偏移地址 ⇔ 物理地址 = 基础地址 + 偏移地址</strong></p>
<h2 id="段寄存器"><a class="markdownIt-Anchor" href="#段寄存器"></a> 段寄存器</h2>
<p>8086CPU有4个段寄存器：<strong>CS、DS、SS、ES</strong></p>
<h2 id="cs和ip"><a class="markdownIt-Anchor" href="#cs和ip"></a> CS和IP</h2>
<p>CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指针指令寄存器。</p>
<p>任意时刻，CPU将CS：IP中指向的内容当作指令执行。</p>
<h2 id="修改cs和ip得到指令"><a class="markdownIt-Anchor" href="#修改cs和ip得到指令"></a> 修改CS和IP得到指令</h2>
<p>前面提到mov指令可以修改寄存器的值，但是CS和IP的值不能被修改，现在介绍一种新的指令：<strong>jmp指令</strong></p>
<p>用法：</p>
<p>● jmp 段地址：偏移地址。例如：jmp 1234：3，执行后CS=1234H，IP=0003H，CPU将从12343H处读取指令。</p>
<p>● jmp 某一合法寄存器，功能：用寄存器的值修改IP。例如：ax=1000H，IP=0001H，jmp ax，执行后IP=1000H</p>
<h1 id="dosbox的使用"><a class="markdownIt-Anchor" href="#dosbox的使用"></a> DOSBox的使用</h1>
<p>DOSBox是一个模拟dos系统的软件，学习汇编可以使用它来完成编译、连接等过程。</p>
<h2 id="debug"><a class="markdownIt-Anchor" href="#debug"></a> Debug</h2>
<p>Debug是调试工具，使用它可以查看CPU中各种寄存器中的内容、内存情况和在机器码级跟踪程序的运行</p>
<h2 id="debug功能"><a class="markdownIt-Anchor" href="#debug功能"></a> Debug功能</h2>
<p>● 用Debug的R命令查看、改变CPU寄存器的内容</p>
<p>● 用Debug的D命令查看内存中的内容</p>
<p>● 用Debug的E命令改写内存中的内容</p>
<p>● 用Debug的U命令将内存中的机器指令翻译成汇编指令</p>
<p>● 用Debug的T命令执行一条机器指令</p>
<p>● 用Debug的A命令以汇编指令的格式在内存中写入一条机器指令</p>
<h2 id="dosbox使用方法"><a class="markdownIt-Anchor" href="#dosbox使用方法"></a> DOSBox使用方法</h2>
<p>DOSBox使用方法不难，网上有很多教程，这里就不多讲解了</p>
<h1 id="寄存器内存访问"><a class="markdownIt-Anchor" href="#寄存器内存访问"></a> 寄存器（内存访问）</h1>
<h2 id="ds和address"><a class="markdownIt-Anchor" href="#ds和address"></a> DS和[address]</h2>
<p>CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址，在8086CPU中，内存地址由段地址个偏移地址组成，8086CPU中有一个DS寄存器，存放段地址，而常见的“[]”这种格式，表示一个内存单元，里面存放的是偏移地址；</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov bx，1000H</span><br><span class="line"></span><br><span class="line">mov ds，bx</span><br><span class="line"></span><br><span class="line">mov ax，[0]</span><br></pre></td></tr></tbody></table></figure>
<p>这三步指令将10000H（1000：0）中的数据读到ax中</p>
<blockquote>
<p>这里不能直接用mov ds，1000H，8086CPU不支持直接将数据送入段寄存器中，必须通过其他寄存器进行中转才行。</p>
</blockquote>
<h2 id="mov-add-sub指令"><a class="markdownIt-Anchor" href="#mov-add-sub指令"></a> mov、add、sub指令</h2>
<p>前面说到过mov指令和add指令，那就简单说说sub指令：</p>
<table>
<thead>
<tr>
<th style="text-align:center">汇编指令</th>
<th style="text-align:center">控制CPU完成的操作</th>
<th style="text-align:center">高级语言语法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sub ax,bx</td>
<td style="text-align:center">将AX和BX中的数值相加，结果存在AX</td>
<td style="text-align:center">AX=AX-BX</td>
</tr>
</tbody>
</table>
<p>下面是一些常用的格式：</p>
<blockquote>
<p>mov/add/sub 寄存器，数据           例如：mov/add/sub ax,8</p>
<p>mov/add/sub 寄存器，寄存器       例如：mov/add/sub ax,bx</p>
<p>mov/add/sub 寄存器，内存单元   例如：mov/add/sub ax,[0]</p>
<p>mov/add/sub 内存单元，寄存器   例如：mov/add/sub [0],ax</p>
<p>mov 段寄存器，寄存器                   例如：mov ds,ax</p>
</blockquote>
<h2 id="cpu提供的栈机制"><a class="markdownIt-Anchor" href="#cpu提供的栈机制"></a> CPU提供的栈机制</h2>
<p>8086CPU提供入栈和出栈的指令，最基本的是push(入栈)和pop(出栈)：</p>
<table>
<thead>
<tr>
<th style="text-align:center">汇编指令</th>
<th style="text-align:center">控制CPU完成的操作</th>
<th style="text-align:center">高级语言语法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">push ax</td>
<td style="text-align:center">将寄存器ax中的值送入栈中</td>
<td style="text-align:center">—</td>
</tr>
<tr>
<td style="text-align:center">pop ax</td>
<td style="text-align:center">从栈顶取出数据送入ax中</td>
<td style="text-align:center">—</td>
</tr>
</tbody>
</table>
<p>8086CPU在寻找当前栈顶位置时提供了一种方法：</p>
<p>8086CPU中有两个寄存器SS和SP，SS存放栈顶的段地址，SP存放栈顶元素的偏移地址。</p>
<p>任意时刻，SS：SP指向栈顶元素。当执行push和pop指令时，CPU就从SS和SP中获取栈顶的地址。</p>
<h3 id="push过程"><a class="markdownIt-Anchor" href="#push过程"></a> push过程</h3>
<p>push ax的执行，分为以下两部进行：</p>
<p>1、SP=SP-2，SS：SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶。</p>
<p>2、将ax中的内容送到SS：SP指向的内存单元处，SS：SP此时指向新的栈顶。</p>
<h3 id="pop过程"><a class="markdownIt-Anchor" href="#pop过程"></a> pop过程</h3>
<p>pop ax的执行和push正好相反，也是分为两部执行：</p>
<p>1、将SS：SP指向的内存单元处的数据送入ax中。</p>
<p>2、SP=SP+2，SS：SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</p>
<h2 id="栈顶超界问题"><a class="markdownIt-Anchor" href="#栈顶超界问题"></a> 栈顶超界问题</h2>
<p>当一个栈满了之后，此时若执行push命令，则会发生栈满情况，这些栈空间很可能存放很多有用的数据，代码等，是很危险的情况。</p>
<p>当然，若栈为空，执行pop命令也会栈越界。</p>
<p>所以在实际工作中，一定要注意栈越界情况，尽可能的用到最大的栈空间。</p>
<h1 id="第一个程序"><a class="markdownIt-Anchor" href="#第一个程序"></a> 第一个程序</h1>
<h2 id="一个小程序"><a class="markdownIt-Anchor" href="#一个小程序"></a> 一个小程序</h2>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    mov ax,0123H</span><br><span class="line">    mov bx,0456H</span><br><span class="line">    add ax,bx</span><br><span class="line">    add ax,ax</span><br><span class="line">    </span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>
<p>这是一段简单的汇编程序，先说明下各部分的含义：</p>
<h2 id="各部分的含义"><a class="markdownIt-Anchor" href="#各部分的含义"></a> 各部分的含义</h2>
<p><strong>1、伪指令</strong></p>
<p>在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。</p>
<p>汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终被CPU所执行；而伪指令没有对应的机器指令，最终不被CPU所执行而被编译器执行。</p>
<p>上面程序中有3中伪指令：</p>
<p>● <strong>segment</strong>和<strong>ends</strong>是一对成对使用的伪指令，这是在可被编译器编译的汇编程序中必须用到的伪指令。功能是定义一个段，<strong>segment</strong>和<strong>ends</strong>分别说明一个段的开始和结束。</p>
<p>一个程序中通常会有多个段，代码段只是其中一种。</p>
<p>● <strong>end</strong>是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，碰到<strong>end</strong>就会结束。</p>
<p>一定要记得在结尾加上<strong>end</strong>，否则，编译器无法知道程序在何处结束</p>
<p>● <strong>assume</strong>含义是“假设”，它假设某一段寄存器和程序中的某一个用<strong>segment…ends</strong>定义的段相关联，通过assume说明这种关联。</p>
<p><strong>2、标号</strong></p>
<p>汇编源程序中，除了汇编指令和伪指令外，还有一些标号，例如“codesg”。一个标号指代了一个地址。比如codesg在segment的前面，作为一个段的名称，这个段的名称最终被编译、连接程序处理为一个段的段地址。</p>
<p><strong>3、程序的结构</strong></p>
<p>(1) 我们要定义一个段，名称为abc</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">abc ends</span><br></pre></td></tr></tbody></table></figure>
<p>(2) 在这个段中写入汇编指令，来实现我们的任务</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    add ax,ax</span><br><span class="line">abc ends</span><br></pre></td></tr></tbody></table></figure>
<p>(3) 指出程序在何处结束</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>
<p>(4) abc被当做代码段来用，所以，应该将abc和cs联系起来</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>
<p><strong>4、程序返回</strong></p>
<p>一个程序结束后，CPU的控制权交还给使它得以运行的程序，我们称这个过程为：<strong>程序返回</strong></p>
<p>返回方法：在程序的末尾添加返回的程序段：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax 4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></tbody></table></figure>
<p>与结束相关的概念：</p>
<table>
<thead>
<tr>
<th style="text-align:center">目的</th>
<th style="text-align:center">相关指令</th>
<th style="text-align:center">指令性质</th>
<th style="text-align:center">指令执行者</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">通知编译器一个段结束</td>
<td style="text-align:center">段名 ends</td>
<td style="text-align:center">伪指令</td>
<td style="text-align:center">编译时，由编译器执行</td>
</tr>
<tr>
<td style="text-align:center">通知编译器程序结束</td>
<td style="text-align:center">end</td>
<td style="text-align:center">伪指令</td>
<td style="text-align:center">编译时，由编译器执行</td>
</tr>
<tr>
<td style="text-align:center">程序返回</td>
<td style="text-align:center">mov ax,4c00H  int 21H</td>
<td style="text-align:center">汇编指令</td>
<td style="text-align:center">执行时，由CPU执行</td>
</tr>
</tbody>
</table>
<h2 id="程序的执行"><a class="markdownIt-Anchor" href="#程序的执行"></a> 程序的执行</h2>
<p>一个程序从开始到执行分为以下几步：</p>
<p>● 编辑源程序</p>
<p>● 编译</p>
<p>● 连接</p>
<p>● .exe的执行</p>
<p>这些步骤可以用<strong>DOSBox</strong>进行，具体方法就不多说了</p>
<h1 id="bx和loop指令"><a class="markdownIt-Anchor" href="#bx和loop指令"></a> [BX]和loop指令</h1>
<p>1、[bx]</p>
<p>[bx]和[0]类似，都表示一个内存单元，[bx]的偏移地址在bx中，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br></pre></td></tr></tbody></table></figure>
<p>将一个内存单元的内容送入ax，这个内存单元偏移地址在bx，段地址在ds中。</p>
<p>2、loop</p>
<p><strong>loop</strong>有循环的意思，显然这个指令和循环有关。</p>
<p>3、描述性符号"()"</p>
<p>"()"表示一个寄存器或者一个内存单元的内容，例如：</p>
<p>(ax)表示ax中的内容；(20000H)表示内存20000H单元的内容</p>
<p>4、约定符号idata表示常量</p>
<p>用idata表示一个常量，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[idata]</span><br><span class="line"></span><br><span class="line">mov bx,idata</span><br></pre></td></tr></tbody></table></figure>
<p>第一句就代表mov ax,[1]、mov ax,[2]、mov ax,[3]…</p>
<p>第二句就代表mov bx,1、mov bx,2、mov bx,3</p>
<h2 id="bx"><a class="markdownIt-Anchor" href="#bx"></a> [BX]</h2>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br></pre></td></tr></tbody></table></figure>
<p>功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入ax中，即：(ax)=((ds)*16+(bx))</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [bx],ax</span><br></pre></td></tr></tbody></table></figure>
<p>功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA：EA处，即：((ds)*16+(bx)=(ax))</p>
<p><strong>inc指令：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">汇编指令</th>
<th style="text-align:center">控制CPU完成的操作</th>
<th style="text-align:center">高级语言语法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">inc ax</td>
<td style="text-align:center">ax中的内容加一</td>
<td style="text-align:center">ax++</td>
</tr>
</tbody>
</table>
<h2 id="loop指令"><a class="markdownIt-Anchor" href="#loop指令"></a> loop指令</h2>
<p>loop指令的格式是：loop 标号，需要进行两部操作：</p>
<p>● (cx)=(cx)-1</p>
<p>● 判断cx的值，不为0则转至标号处执行程序，如果为0则向下执行</p>
<h3 id="编程举例"><a class="markdownIt-Anchor" href="#编程举例"></a> 编程举例</h3>
<p>若要计算2^3的值，你可能想到2×2×2，在汇编语言中我们知道没有’×’这个符号，那要怎么解决呢？前面讲过的add指令就派上用场了：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br></pre></td></tr></tbody></table></figure>
<p>通过这样的加法运算，可以把乘方问题转化成加法来实现。</p>
<p>但是有一点注意的是，2<sup>3次方还好说，如果2</sup>100,1000次方，再用add指令就麻烦了，所以，我们引入了loop指令可以轻松解决这个问题：</p>
<p>例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    mov cx,100</span><br><span class="line">S:  add ax,ax</span><br><span class="line">    loop s</span><br><span class="line">    </span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>
<p><strong>一、分析：</strong></p>
<p>1、标号</p>
<p>汇编语言中，标号代表一个地址，上面程序中s就是一个标号，它实际上是标识了一个地址，这个地址有一条指令：add ax,ax</p>
<p>2、loop s</p>
<p>CPU执行loop s的时候进行两步操作：</p>
<p>● (cx)=(cx)-1</p>
<p>● 判断cx的值，不为0则转至标号处执行程序，如果为0则向下执行</p>
<p>3、上面程序执行了100次，实际上是计算2^101次方</p>
<p><strong>二、总结：</strong></p>
<p>cx和loop指令配合实现循环功能的3个要点：</p>
<p>● 在cx中存放循环次数</p>
<p>● loop指令中的标号所标识地址要在前面</p>
<p>● 要循环执行的程序段，要写在标号和loop指令的中间，框架如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    mov cx,循环次数</span><br><span class="line">s:  </span><br><span class="line">    循环执行程序段</span><br><span class="line">    loop s</span><br></pre></td></tr></tbody></table></figure>
<h2 id="段前缀"><a class="markdownIt-Anchor" href="#段前缀"></a> 段前缀</h2>
<p>用于显式地指明内存单元的段地址的ds:，cs:，ss:，es:称为段前缀。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds/cs/ss/es:[bx]</span><br></pre></td></tr></tbody></table></figure>
<p>这行代码含义是：</p>
<p>将一个内存单元的内容送入ax，这个内存单元的长度为2个字节(字单元)，存放一个字，偏移地址在bx/cs/ss/es中，段地址在ds中</p>
<h1 id="包含多个段的程序"><a class="markdownIt-Anchor" href="#包含多个段的程序"></a> 包含多个段的程序</h1>
<p>前面我们只接触到了代码段，如果程序需要用其他空间来存放数据，就得使用其他的段。这一章，我们学习数据段、栈段、代码段</p>
<h2 id="在代码段中使用数据"><a class="markdownIt-Anchor" href="#在代码段中使用数据"></a> 在代码段中使用数据</h2>
<p>考虑这样一个问题，编程计算一下8个数据的和，结果存在ax寄存器中：</p>
<p>1,2,3,4,5,6,7,8，</p>
<p>在前面已经学习过了loop指令，因此肯定是希望用循环的方式进行数据的相加，所以，我们可以将数据存储在一组地址连续的内存单元中，通过指令送入。</p>
<p>具体方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    dw 1,2,3,4,5,6,7,8</span><br><span class="line">    </span><br><span class="line">    mov bx,0</span><br><span class="line">    mov ax,0</span><br><span class="line">    mov cx,8</span><br><span class="line">  s:add ax,cs:[bx]</span><br><span class="line">    add bx,2</span><br><span class="line">    loop s</span><br><span class="line">    </span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">    </span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>
<p>说明：</p>
<p>程序中的"dw"的含义是定义字型数据，“dw"即"define word”，dw定义8个字型数据，占16个字节的内存空间。</p>
<p>程序在运行的时候CS中存放的是代码段的段地址，所以段地址是已知的了，那么，偏移地址是多少呢？dw定义的数据处于代码段的一开始，所以偏移地址为0。</p>
<p>程序中用bx存放加2递增的偏移地址，每次循环(bx)=(bx)+2，cs：bx指向下一个数据所在的字单元。</p>
<p>这样就完成了一系列的操作。</p>
<p><strong>在这里有个小问题：</strong></p>
<blockquote>
<p>程序运行的过程中，有时候会找不到程序的"入口"，这样一来，程序的逻辑就会混乱，运行也会出错。</p>
</blockquote>
<p>为了解决上面的问题，引入了新的模板：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">        ...</span><br><span class="line">        数据</span><br><span class="line">        ...</span><br><span class="line">start:</span><br><span class="line">        ...</span><br><span class="line">        代码</span><br><span class="line">        ...</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>
<p><strong>end</strong>不仅仅可以通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。</p>
<p>上面的模板中，<strong>end</strong>后面接了一个<strong>start</strong>，指明了程序的入口为<strong>start</strong>，编译器就从此处开始执行。</p>
<h2 id="在代码段中使用栈"><a class="markdownIt-Anchor" href="#在代码段中使用栈"></a> 在代码段中使用栈</h2>
<p>考虑这样一个问题，将下列一组数据逆序存放：</p>
<p>1,2,3,4,5,6,7,8</p>
<p>第一反应想到的是利用栈，因为入栈和出栈正好相反嘛。利用栈把定义的数据存放在cs:0~cs:F 单元中， 依次将这8个字单元中的数据入栈，再依次出栈到这8个字单元中，从而实现数据的逆序存放。</p>
<p>具体方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">    dw 1,2,3,4,5,6,7,8</span><br><span class="line">    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;用dw定义16个字型数据，在程序加载后，将取得16个字的内存空间，存放着                                        ;16个数据,后面将这段空间当做栈来使用</span><br><span class="line">    </span><br><span class="line">start: mov ax,cs</span><br><span class="line">       mov ss,ax</span><br><span class="line">       mov sp,30h  ;将栈顶ss:sp指向cs:30</span><br><span class="line">       </span><br><span class="line">       mov bx,0</span><br><span class="line">       mov cx,8</span><br><span class="line">   s1: push cs:[bx]</span><br><span class="line">       add bx,2</span><br><span class="line">       loop s1     ;将代码段0~15个单元中的8个字型数据依次入栈</span><br><span class="line">       </span><br><span class="line">       mov bx,0</span><br><span class="line">       mov cx,8</span><br><span class="line">   s2: pop cs:[bx]</span><br><span class="line">       add bx,2</span><br><span class="line">       loop s2     ;依次出栈8个字型数据到代码段0~15个单元中</span><br><span class="line">       </span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line">       </span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>
<p>这样就可以实现数据的逆序存放了</p>
<h2 id="将数据-代码-栈放入不同的段"><a class="markdownIt-Anchor" href="#将数据-代码-栈放入不同的段"></a> 将数据、代码、栈放入不同的段</h2>
<p>定义多个段：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">    dw 1,2,3,4,5,6,7,8</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: mov ax,stack</span><br><span class="line">       mov ss,ax</span><br><span class="line">       mov sp,20h    ;设置栈顶ss:sp指向stack:20</span><br><span class="line">       </span><br><span class="line">       mov ax,data</span><br><span class="line">       mov ds,ax     ;ds指向data段</span><br><span class="line">code ends</span><br></pre></td></tr></tbody></table></figure>
<p>说明：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,data ;这行指令的含义是将名称为data的段的段地址送入ax</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>mov ds,data 这行指令时错误的，8086CPU不允许将一个数值直接送入段寄存器中，如果程序中出现这行指令，将被编译器处理为一个表示段地址的数值</p>
</blockquote>
<p><strong>db、dw、dd的区别：</strong></p>
<blockquote>
<p>db定义字节类型变量，1个字节数据占1个字节单元，读完1个，偏移量+1</p>
<p>dw定义字节类型变量，1个字节数据占2个字节单元，读完1个，偏移量+2</p>
<p>dd定义字节类型变量，1个字节数据占4个字节单元，读完1个，偏移量+4</p>
</blockquote>
<h1 id="更灵活的定位内存地址的方法"><a class="markdownIt-Anchor" href="#更灵活的定位内存地址的方法"></a> 更灵活的定位内存地址的方法</h1>
<h2 id="and和or指令"><a class="markdownIt-Anchor" href="#and和or指令"></a> and和or指令</h2>
<h3 id="and指令"><a class="markdownIt-Anchor" href="#and指令"></a> and指令</h3>
<p>and指令：逻辑与指令，按位进行与运算</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br></pre></td></tr></tbody></table></figure>
<p>执行后，al=00100011B</p>
<p>或运算的计算方法为：“一一得一，其余为零”</p>
<h3 id="or指令"><a class="markdownIt-Anchor" href="#or指令"></a> or指令</h3>
<p>or指令：逻辑或运算，按位进行或运算</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">or al,00111011B</span><br></pre></td></tr></tbody></table></figure>
<p>执行后，al=01111011B</p>
<p>或运算的计算方法为：“零零得零，其余为一”</p>
<blockquote>
<p>若要将一个操作对象的某一位设置成0，则用and指令，例如：将al第3位设置成0：and al,11110111B</p>
<p>若要将一个操作对象的某一位设置成1，则用or指令，例如：将al第5位设置成1：or al,00100000B</p>
</blockquote>
<h2 id="大小写转化问题"><a class="markdownIt-Anchor" href="#大小写转化问题"></a> 大小写转化问题</h2>
<p>为了更深刻地理解and和or指令，考虑如何将一个字符串变成全大写或者全小写。</p>
<p>从一个字母的ASCII码的二进制来看，它的第5位如果是0，则这个字母为大写，如果为1，则为小写。</p>
<p>思路就是：</p>
<p>将一个字母与一个二进制进行and或or运算，强制改变第5位。</p>
<p>看看汇编代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">    db 'AbcDE'</span><br><span class="line">    db 'aBCDe'</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start: mov ax,datasg</span><br><span class="line">       mov ds,ax           ;设置ds指向datasg段</span><br><span class="line">       mov bx,0            ;设置(bx)=0，ds:bx指向'AbcDE'的第一个字母</span><br><span class="line">       mov cx,5            ;5个字母，循环5次</span><br><span class="line">    s1:mov al,[bx]         ;将ASCII码从ds:bx所指向的单元中取出</span><br><span class="line">       and al,11011111B    ;将al中的ASCII码的第5个位置为0，变为大写字母</span><br><span class="line">       mov [bx],al         ;将转变后的ASCII码写回原单元</span><br><span class="line">       inc bx              ;(bx)++，ds:bx指向下一个字母</span><br><span class="line">       loop s1</span><br><span class="line">       </span><br><span class="line">       mov bx,5            ;设置(bx)=5，ds:bx指向'aBCDe'的第一个字母</span><br><span class="line">       mov cx,5</span><br><span class="line">    s2:mov al,[bx]</span><br><span class="line">       or al,00100000B     ;将al中的ASCII码的第5个位置为1，变为小写字母</span><br><span class="line">       mov [bx],al</span><br><span class="line">       inc bx</span><br><span class="line">       loop s2</span><br><span class="line">       </span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line">       </span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>
<h2 id="bxidata"><a class="markdownIt-Anchor" href="#bxidata"></a> [bx+idata]</h2>
<p>前面我们用[bx]的方式来指明一个内存单元，还可以用更灵活的方式来指明内存单元：[bx+idata]表示一个内存单元，它的偏移地址的(bx)+idata(bx中的数值加上idata)。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+200]</span><br></pre></td></tr></tbody></table></figure>
<p>这行指令的含义为：</p>
<p>将一个内存单元的内容送入ax，这个内存单元的长度为2个字节，存放一个字，偏移地址为bx中的数值再加上200，段地址在ds中。</p>
<p>数学化的描述为：</p>
<p>(ax)=((ds)*16+(bx)+200)</p>
<p>上述指令也可以写成：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[200+bx]</span><br><span class="line">mov ax,200[bx]</span><br><span class="line">mov ax,[bx].200</span><br></pre></td></tr></tbody></table></figure>
<h2 id="用bxidata的方式处理数组"><a class="markdownIt-Anchor" href="#用bxidata的方式处理数组"></a> 用[bx+idata]的方式处理数组</h2>
<p>两种形式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[bx]=0[bx]</span><br><span class="line"></span><br><span class="line">[bx+5]=5[bx]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="si和di"><a class="markdownIt-Anchor" href="#si和di"></a> SI和DI</h2>
<p>si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用</p>
<h2 id="bxsi和bxdi"><a class="markdownIt-Anchor" href="#bxsi和bxdi"></a> [bx+si]和[bx+di]</h2>
<p>前面我们用[bx]和[bx+idata]的方式来指明一个内存单元，我们还可以用更灵活的方式：[bx+si]和[bx+di]</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+si]</span><br></pre></td></tr></tbody></table></figure>
<p>含义如下：</p>
<p>将一个内存单元的内容送入ax，这个内存单元的长度为2个字节，存放一个字，偏移地址为bx中的数值加上si中的数值，段地址在ds中。</p>
<p>数学化的描述：</p>
<p>(ax)=((ds)*16+(bx)+(si))</p>
<p>该指令另外一种常用的表示方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx][si]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="bxsiidata和bxdiidata"><a class="markdownIt-Anchor" href="#bxsiidata和bxdiidata"></a> [bx+si+idata]和[bx+di+idata]</h2>
<p>这是一种更加灵活的方式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+si+idata]</span><br></pre></td></tr></tbody></table></figure>
<p>含义如下：</p>
<p>将一个内存单元的内容送入ax，这个内存单元的长度为2个字节，存放一个字，偏移地址为bx中的数值加上si中的数值再加上idata，段地址在ds中。</p>
<p>数学化的描述：</p>
<p>(ax)=((ds)*16+(bx)+(si)+idata)</p>
<p>该指令另外一种常用的表示方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+200+si]</span><br><span class="line">mov ax,[200+bx+si]</span><br><span class="line">mov ax,200[bx][si]</span><br><span class="line">mov ax,[bx].200[si]</span><br><span class="line">mov ax,[bx][si].200</span><br></pre></td></tr></tbody></table></figure>
<h2 id="不同的寻址方式的灵活运用"><a class="markdownIt-Anchor" href="#不同的寻址方式的灵活运用"></a> 不同的寻址方式的灵活运用</h2>
<p>通过比较前面用到过的寻址方法，可以发现：</p>
<blockquote>
<p>1、[idata]用一个常量来表示地址，可用于直接定位一个内存单元。</p>
<p>2、[bx]用一个变量来表示内存单元地址，可用于间接定位一个内存单元。</p>
<p>3、[bx+idata]用一个变量和一个常量来表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元。</p>
<p>4、[bx+si]用两个变量表示地址。</p>
<p>5、[bx+si+idata]用两个变量和一个常量表示地址。</p>
</blockquote>
<p>不同寻址方式各有利弊，根据实际情况而定。</p>
<h1 id="数据处理的两个基本问题"><a class="markdownIt-Anchor" href="#数据处理的两个基本问题"></a> 数据处理的两个基本问题</h1>
<p>在这里定义两个描述性符号：<strong>reg</strong>和<strong>sreg</strong></p>
<p><strong>reg</strong>的集合包括：<strong>ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di</strong></p>
<p><strong>sreg</strong>的集合包括：<strong>ds、ss、cs、es</strong></p>
<h2 id="bx-si-di和bp"><a class="markdownIt-Anchor" href="#bx-si-di和bp"></a> bx、si、di和bp</h2>
<p>1、在8086CPU中，只有bx、si、di和bp这4个寄存器可以用在"[…]"中来进行内存单元的寻址。</p>
<p>2、在[…]中，这4个寄存器可以单个出现，或者只能以4中组合出现：bx和si、bx和di，bp和si，bp和di。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">;正确用法：</span><br><span class="line">mov ax,[bx]</span><br><span class="line">mov ax,[si]</span><br><span class="line">mov ax,[di]</span><br><span class="line">mov ax,[bp]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bx+di]</span><br><span class="line">mov ax,[bp+si]</span><br><span class="line">mov ax,[bp+di]</span><br><span class="line">mov ax,[bx+si+idata]</span><br><span class="line">mov ax,[bx+di+idata]</span><br><span class="line">mov ax,[bp+si+idata]</span><br><span class="line">mov ax,[bp+di+idata]</span><br><span class="line"></span><br><span class="line">;错误用法：</span><br><span class="line">mov ax,[bx+bp]</span><br><span class="line">mov ax,[si+di]</span><br></pre></td></tr></tbody></table></figure>
<p>3、只要在[…]中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bp]          ;含义：(ax)=((ss)*16+(bp))</span><br><span class="line">mov ax,[bp+idata]    ;含义：(ax)=((ss)*16+(bp)+idata)</span><br><span class="line">mov ax,[bp+si]       ;含义：(ax)=((ss)*16+(bp)+(si))</span><br><span class="line">mov ax,[bp+si+idata] ;含义：(ax)=((ss)*16+(bp)+(si)+idata)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="机器指令处理的数据在什么地方"><a class="markdownIt-Anchor" href="#机器指令处理的数据在什么地方"></a> 机器指令处理的数据在什么地方</h2>
<table>
<thead>
<tr>
<th>机器码</th>
<th>汇编指令</th>
<th>指令执行前数据的位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>8E1E0000</td>
<td>mov bx,[0]</td>
<td>内存，ds:0单元</td>
</tr>
<tr>
<td>89C3</td>
<td>mov bx,ax</td>
<td>CPU内部，ax寄存器</td>
</tr>
<tr>
<td>BB0100</td>
<td>mov bx,1</td>
<td>CPU内部，指令缓冲器</td>
</tr>
</tbody>
</table>
<h2 id="汇编语言中数据位置的表达"><a class="markdownIt-Anchor" href="#汇编语言中数据位置的表达"></a> 汇编语言中数据位置的表达</h2>
<p>1、立即数(idata)</p>
<p>对于直接包含在机器指令中的数据，在汇编语言中称为：立即数。</p>
<p>2、寄存器</p>
<p>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。</p>
<p>3、段地址SA偏移地址(EA)</p>
<p>指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。</p>
<p>● 存放段地址的寄存器可以是默认的，例如：</p>
<p>(1)段地址默认在ds中：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br><span class="line">mov ax,[di]</span><br><span class="line">mov ax,[bx+8]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bx+si+8]</span><br></pre></td></tr></tbody></table></figure>
<p>(2)段地址默认在ss中：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bp]</span><br><span class="line">mov ax,[bp+8]</span><br><span class="line">mov ax,[bp+si]</span><br><span class="line">mov ax,[bp+si+8]</span><br></pre></td></tr></tbody></table></figure>
<p>● 存放段地址的寄存器也可以是显性给出的，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[bp]       ;含义：(ax)=((ds)*16+(bp))  </span><br><span class="line">mov ax,es:[bx]       ;含义：(ax)=((es)*16+(bx))  </span><br><span class="line">mov ax,ss:[bx+si]    ;含义：(ax)=((ss)*16+(bx)+(si))  </span><br><span class="line">mov ax,cs:[bx+si+8]  ;含义：(ax)=((cs)*16+(bx)+(si)+8)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="寻址方式"><a class="markdownIt-Anchor" href="#寻址方式"></a> 寻址方式</h2>
<p>1、直接寻址</p>
<table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[idata]</td>
<td style="text-align:center">EA=idata，SA=(ds)</td>
</tr>
</tbody>
</table>
<p>常用格式：[idata]</p>
<p>2、寄存器间接寻址</p>
<table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[bx]</td>
<td style="text-align:center">EA=(bx),SA=(ds)</td>
</tr>
<tr>
<td style="text-align:center">[si]</td>
<td style="text-align:center">EA=(si),SA=(ds)</td>
</tr>
<tr>
<td style="text-align:center">[di]</td>
<td style="text-align:center">EA=(di),SA=(ds)</td>
</tr>
<tr>
<td style="text-align:center">[bp]</td>
<td style="text-align:center">EA=(bp),SA=(ss)</td>
</tr>
</tbody>
</table>
<p>常用格式：[bx]</p>
<p>3、寄存器相对寻址</p>
<table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[bx+idata]</td>
<td style="text-align:center">EA=(bx)+idata,SA=(ds)</td>
</tr>
<tr>
<td style="text-align:center">[si+idata]</td>
<td style="text-align:center">EA=(si)+idata,SA=(ds)</td>
</tr>
<tr>
<td style="text-align:center">[di+idata]</td>
<td style="text-align:center">EA=(di)+idata,SA=(ds)</td>
</tr>
<tr>
<td style="text-align:center">[bp+idata]</td>
<td style="text-align:center">EA=(bp)+idata,SA=(ss)</td>
</tr>
</tbody>
</table>
<p>常用格式：</p>
<p>● 用于结构体：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[bx].idata</span><br></pre></td></tr></tbody></table></figure>
<p>● 用于数组：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idata[si],idata[di]</span><br></pre></td></tr></tbody></table></figure>
<p>● 用于二维数组：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[bx][idata]</span><br></pre></td></tr></tbody></table></figure>
<p>4、基址变址寻址</p>
<table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[bx+si]</td>
<td style="text-align:center">EA=(bx)+(si),SA=(ds)</td>
</tr>
<tr>
<td style="text-align:center">[bx+di]</td>
<td style="text-align:center">EA=(bx)+(di),SA=(ds)</td>
</tr>
<tr>
<td style="text-align:center">[bp+si]</td>
<td style="text-align:center">EA=(bp)+(si),SA=(ss)</td>
</tr>
<tr>
<td style="text-align:center">[bp+di]</td>
<td style="text-align:center">EA=(bp)+(di),SA=(ss)</td>
</tr>
</tbody>
</table>
<p>常用格式：</p>
<p>用于二维数组：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[bx][si]</span><br></pre></td></tr></tbody></table></figure>
<p>5、相对基址变址寻址</p>
<table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[bx+si+idata]</td>
<td style="text-align:center">EA=(bx)+(si)+idata,SA=(ds)</td>
</tr>
<tr>
<td style="text-align:center">[bx+di+idata]</td>
<td style="text-align:center">EA=(bx)+(di)+idata,SA=(ds)</td>
</tr>
<tr>
<td style="text-align:center">[bp+si+idata]</td>
<td style="text-align:center">EA=(bp)+(si)+idata,SA=(ss)</td>
</tr>
<tr>
<td style="text-align:center">[bp+di+idata]</td>
<td style="text-align:center">EA=(bp)+(di)+idata,SA=(ss)</td>
</tr>
</tbody>
</table>
<p>常用格式：</p>
<p>用于表格(结构)中的数组项：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[bx].idata[si]</span><br></pre></td></tr></tbody></table></figure>
<p>用于二维数组：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idata[bx][si]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="指令处理的数据"><a class="markdownIt-Anchor" href="#指令处理的数据"></a> 指令处理的数据</h2>
<p>8086CPU的指令，可以处理两种尺寸的数据，byte和word，所以在机器指令中要指明，指令进行的是字操作还是字节操作。汇编语言用以下方法处理：</p>
<p>1、通过寄存器名指明要处理的数据的尺寸</p>
<p>2、没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X可以为word或者byte，例如：</p>
<p>● 用word ptr指明访问的内存单元是一个字单元，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]</span><br></pre></td></tr></tbody></table></figure>
<p>● 用byte ptr指明访问的内存单元是一个字节单元，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov byte ptr ds:[0],1</span><br><span class="line">inc byte ptr [bx]</span><br></pre></td></tr></tbody></table></figure>
<p>3、其他方法</p>
<p>有些指令默认了访问的是字单元还是字节单元，比如，push [1000H]就不用指明访问的是字单元还是字节单元，因为push指令只进行字操作</p>
<h2 id="dup"><a class="markdownIt-Anchor" href="#dup"></a> dup</h2>
<p>dup是一个操作符，在汇编语言中和db、dd、dw等数据定义伪指令配合使用，用来进行数据的重复，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0)</span><br><span class="line">db 0,0,0</span><br></pre></td></tr></tbody></table></figure>
<p>定义3个字节，这两个是等价的；又如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0,1,2)</span><br><span class="line">db 0,1,2,0,1,2,0,1,2</span><br></pre></td></tr></tbody></table></figure>
<p>定义了9个字节</p>
<blockquote>
<p>dup的使用格式如下：</p>
<p>db 重复的次数 dup （重复的字节型数据）</p>
<p>dw 重复的次数 dup（重复的字型数据）</p>
<p>dd 重复的次数 dup（重复的双字型数据）</p>
</blockquote>
<h1 id="转移指令"><a class="markdownIt-Anchor" href="#转移指令"></a> 转移指令</h1>
<p>8086CPU的转移行为有以下几类</p>
<p>● 只修改IP时，称为段内转移，比如：jmp ax</p>
<p>● 同时修改CS和IP时，称为段间转移，比如：jmp 1000:0</p>
<p>由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移</p>
<p>● 短转移IP的修改范围为-128~127</p>
<p>● 近转移IP的修改范围为-32768~32767</p>
<p>8086CPU的转移指令分为以下几类：</p>
<p>● 无条件转移指令（如：jmp）</p>
<p>● 条件转移指令</p>
<p>● 循环指令（如：loop）</p>
<p>● 过程</p>
<p>● 中断</p>
<h2 id="操作符offset"><a class="markdownIt-Anchor" href="#操作符offset"></a> 操作符offset</h2>
<p>操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">    start: mov ax,offset start ;相当于mov ax,0</span><br><span class="line">    </span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>
<p>说明：</p>
<p>上面的程序中，offset操作符取得了标号start的偏移地址，start是代码段的标号，所标记的指令时代码段的第一条指令，偏移地址为0。</p>
<h2 id="jmp指令"><a class="markdownIt-Anchor" href="#jmp指令"></a> jmp指令</h2>
<p>jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP。</p>
<p>jmp指令要给出两种信息：</p>
<p>1、转移的目的地址</p>
<p>2、转移的距离（段间转移、段内短转移、段内近转移）</p>
<p>格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp short 标号     ;段内短转移</span><br><span class="line">jmp far ptr 标号   ;段间转移(远转移)</span><br><span class="line">jmp 16位reg        ;(IP)=(16位reg)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="转移地址在内存中的jmp指令"><a class="markdownIt-Anchor" href="#转移地址在内存中的jmp指令"></a> 转移地址在内存中的jmp指令</h2>
<p>转移地址在内存中的jmp指令有2中格式：</p>
<p>1、jmp word ptr 内存单元地址(段内转移)</p>
<p>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</p>
<p>2、jmp dword ptr 内存单元地址(段间转移)</p>
<p>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</p>
<h2 id="jcxz指令"><a class="markdownIt-Anchor" href="#jcxz指令"></a> jcxz指令</h2>
<p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。</p>
<p>指令格式： jcxz 标号 (如果(cx)=0，转移到标号处执行)</p>
<p>操作：</p>
<p>1、当(cx)=0时，(IP)=(IP)+8位位移</p>
<blockquote>
<p>8位位移=标号处的地址-jcxz指令后的第一个字节的地址</p>
<p>8位位移的范围为-128~127，用补码表示</p>
<p>8位位移由编译程序在编译时算出</p>
</blockquote>
<p>2、当(cx)≠0时，什么也不做，程序向下执行</p>
<p>我们从jcxz的功能中可以看出，jcxz功能相当于：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if((cx)==0) jmp short 标号;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="loop指令-2"><a class="markdownIt-Anchor" href="#loop指令-2"></a> loop指令</h2>
<p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。</p>
<p>指令格式：loop 标号 ((cx)=(cx)-1，如果(cx)≠0，转移到标号处执行)</p>
<p>操作：</p>
<p>1、(cx)=(cx)-1</p>
<p>2、</p>
<p>● 如果(cx)≠0，(IP)=(IP)+8位位移</p>
<blockquote>
<p>8位位移=标号处的地址-loop指令后的第一个字节的地址</p>
<p>8位位移的范围为-128~127，用补码表示</p>
<p>8位位移由编译程序在编译时算出</p>
</blockquote>
<p>● 如果(cx)=0，什么也不做，程序向下执行</p>
<p>我们从loop的功能中可以看出，loop功能相当于：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(cx)--;</span><br><span class="line">if((cx)≠0) jmp short 标号;</span><br></pre></td></tr></tbody></table></figure>
<h1 id="call和ret指令"><a class="markdownIt-Anchor" href="#call和ret指令"></a> CALL和RET指令</h1>
<h2 id="ret和retf"><a class="markdownIt-Anchor" href="#ret和retf"></a> ret和retf</h2>
<p>ret指令用栈中的数据，修改IP的内容，从而实现近转移</p>
<p>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移</p>
<p>1、CPU执行ret指令时，进行下面2步操作：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、(IP)=((ss)*16+(sp))</span><br><span class="line">2、(sp)=(sp)+2</span><br></pre></td></tr></tbody></table></figure>
<p>2、CPU执行retf指令时，进行下面4步操作：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、(IP)=((ss)*16+sp)</span><br><span class="line">2、(sp)=(sp)+2</span><br><span class="line">3、(CS)=((ss)*16+sp)</span><br><span class="line">4、(sp)=(sp)+2</span><br></pre></td></tr></tbody></table></figure>
<p>可以看出，如果我们用汇编语法来解释ret和retf指令，则：</p>
<p>● CPU执行ret指令时，相当于进行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br></pre></td></tr></tbody></table></figure>
<p>● CPU执行retf指令时，相当于进行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br></pre></td></tr></tbody></table></figure>
<h2 id="call"><a class="markdownIt-Anchor" href="#call"></a> call</h2>
<p>CPU执行call指令时，进行两步操作：</p>
<p>1、将当前的IP或CS和IP压入栈中</p>
<p>2、转移</p>
<blockquote>
<p>call指令不能实现短转移，call指令实现转移的方法和jmp指令的原理相同。</p>
</blockquote>
<h2 id="call指令的主要应用格式"><a class="markdownIt-Anchor" href="#call指令的主要应用格式"></a> call指令的主要应用格式</h2>
<h3 id="依据位移进行转移的call指令"><a class="markdownIt-Anchor" href="#依据位移进行转移的call指令"></a> 依据位移进行转移的call指令</h3>
<p>call 标号（将当前的IP压入栈中，转到标号处执行指令）</p>
<p>CPU执行call指令，进行以下操作：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、(sp)=(sp)-2</span><br><span class="line">   ((ss)*16+(sp)=(IP))</span><br><span class="line">2、(IP)=(IP)+16位位移</span><br></pre></td></tr></tbody></table></figure>
<p>CPU执行"call 标号"时，相当于进行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></tbody></table></figure>
<h3 id="转移目的地址在指令中的call指令"><a class="markdownIt-Anchor" href="#转移目的地址在指令中的call指令"></a> 转移目的地址在指令中的call指令</h3>
<p>call far ptr 标号 （段间转移）</p>
<p>CPU执行这种格式的cal指令时，进行以下操作：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、(sp)=(sp)-2</span><br><span class="line">   ((ss)*16+(sp))=(CS)</span><br><span class="line">   (sp)=(sp)-2</span><br><span class="line">   ((ss)*16+(sp))=(IP)</span><br><span class="line">2、(CS)=标号所在段的段地址</span><br><span class="line">   (IP)=标号在段中的偏移地址</span><br></pre></td></tr></tbody></table></figure>
<p>CPU执行"call far ptr 标号"时，相当于进行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></tbody></table></figure>
<h3 id="转移地址在寄存器中的call指令"><a class="markdownIt-Anchor" href="#转移地址在寄存器中的call指令"></a> 转移地址在寄存器中的call指令</h3>
<p>指令格式：call 16位reg</p>
<p>功能：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(sp)=(sp)-2</span><br><span class="line">((ss)*16+(sp))=(IP)</span><br><span class="line">(IP)=(16位reg)</span><br></pre></td></tr></tbody></table></figure>
<p>CPU执行"call 16位reg"时，相当于进行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp 16位reg</span><br></pre></td></tr></tbody></table></figure>
<h3 id="转移地址在内存中的call指令"><a class="markdownIt-Anchor" href="#转移地址在内存中的call指令"></a> 转移地址在内存中的call指令</h3>
<p>转移地址在内存中的call指令有2种格式</p>
<p>1、call word ptr 内存单元地址</p>
<p>CPU执行"call word ptr 内存单元地址"时，相当于进行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></tbody></table></figure>
<p>2、call dword ptr 内存单元地址</p>
<p>CPU执行"call dword ptr 内存单元地址"时，相当于进行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></tbody></table></figure>
<h2 id="mul和div指令"><a class="markdownIt-Anchor" href="#mul和div指令"></a> mul和div指令</h2>
<h3 id="mul"><a class="markdownIt-Anchor" href="#mul"></a> mul</h3>
<p>mul是乘法指令，使用mul做乘法得到时候，需要注意：</p>
<p>1、两个相乘的数，要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认放在AX中，另一个放在16位reg或内存单元中。</p>
<p>2、如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在DX中存放，低位在AX中存放。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul 内存单元</span><br></pre></td></tr></tbody></table></figure>
<h3 id="div"><a class="markdownIt-Anchor" href="#div"></a> div</h3>
<p>这里的div指令可不是html里面的div，这里div是除法指令，使用的时候需要注意：</p>
<p>1、除数：有8位和16位两种，在一个reg或内存单元中。</p>
<p>2、被除数：默认放在AX或DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。</p>
<p>3、结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数，如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数，</p>
<p>格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div reg(除数)</span><br><span class="line">div 内存单元(除数)</span><br></pre></td></tr></tbody></table></figure>
<h1 id="标志寄存器"><a class="markdownIt-Anchor" href="#标志寄存器"></a> 标志寄存器</h1>
<p>CPU内部的寄存器中，有一种有特殊的寄存器，称为<strong>标志寄存器</strong>，具有以下3中作用：</p>
<p>1、用来存储相关指令的某些执行结果</p>
<p>2、用来为CPU执行相关指令提供行为依据</p>
<p>3、用来控制CPU的相关工作方式</p>
<p>标志寄存器是按位起作用，每一位都有专门的含义。记录特定的信息。</p>
<p>8086CPU的标志寄存器结构如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>15</strong></th>
<th style="text-align:center"><strong>14</strong></th>
<th style="text-align:center"><strong>13</strong></th>
<th style="text-align:center"><strong>12</strong></th>
<th style="text-align:center"><strong>11</strong></th>
<th style="text-align:center"><strong>10</strong></th>
<th style="text-align:center"><strong>9</strong></th>
<th style="text-align:center"><strong>8</strong></th>
<th style="text-align:center"><strong>7</strong></th>
<th style="text-align:center"><strong>6</strong></th>
<th style="text-align:center"><strong>5</strong></th>
<th style="text-align:center"><strong>4</strong></th>
<th style="text-align:center"><strong>3</strong></th>
<th style="text-align:center"><strong>2</strong></th>
<th style="text-align:center"><strong>1</strong></th>
<th style="text-align:center"><strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><strong>OF</strong></td>
<td style="text-align:center"><strong>DF</strong></td>
<td style="text-align:center"><strong>IF</strong></td>
<td style="text-align:center"><strong>TF</strong></td>
<td style="text-align:center"><strong>SF</strong></td>
<td style="text-align:center"><strong>ZF</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><strong>PF</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"><strong>CF</strong></td>
</tr>
</tbody>
</table>
<h2 id="zf标志"><a class="markdownIt-Anchor" href="#zf标志"></a> ZF标志</h2>
<p>ZF为零标志位，它记录相关指令执行后，其结果是否为0。若结果为0，zf=1，结果不为0，zf=0。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br></pre></td></tr></tbody></table></figure>
<p>执行后结果为0，则zf=1</p>
<blockquote>
<p>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如：add、sub、div等；有的指令对标志寄存器没有影响，比如：mov、push、pop等。</p>
</blockquote>
<h2 id="pf标志"><a class="markdownIt-Anchor" href="#pf标志"></a> PF标志</h2>
<p>PF为奇偶标志位，它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数，若1的个数为偶数，pf=1，不为偶数，pf=1。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">add al,10</span><br></pre></td></tr></tbody></table></figure>
<p>执行后，(al)=00001011B，其中有3个1（奇数个），pf=0</p>
<h2 id="sf标志"><a class="markdownIt-Anchor" href="#sf标志"></a> SF标志</h2>
<p>SF为符号标志位，它记录相关指令执行后，其结果是否为负，若结果为负，sf=1，若不为负，sf=1</p>
<blockquote>
<p>在我们将数据当做有符号数来运算的时候，可以通过它来得知结果的正负，如果当做无符号来运算的时候，SF则无意义，虽然相关指令影响了它的值。</p>
</blockquote>
<h2 id="cf标志"><a class="markdownIt-Anchor" href="#cf标志"></a> CF标志</h2>
<p>CF为进位标志位，一般情况下进行<strong>无符号数</strong>运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p>
<blockquote>
<p>对于位数为N的无符号数来说，其对应的二进制信息的最高位，即N-1位，就是它的最高有效位，而假想存在的第N位，就是相对于最高有效位的更高位</p>
</blockquote>
<h2 id="of标志"><a class="markdownIt-Anchor" href="#of标志"></a> OF标志</h2>
<p>OF为溢出标志位，一般情况下，OF记录了<strong>有符号数</strong>运算的结果是否发生溢出，如果发生溢出，则OF=1，如果没有，OF=0</p>
<blockquote>
<p>需要注意的是，OF记录的是有符号数，CF记录的是无符号数</p>
</blockquote>
<h2 id="adc指令"><a class="markdownIt-Anchor" href="#adc指令"></a> adc指令</h2>
<p>adc是带进位加法指令，它利用了CF位上记录的进位值。</p>
<p>格式：adc 操作对象1，操作对象2</p>
<p>功能：操作对象1=操作对象1+操作对象2+CF</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc ax,bx</span><br></pre></td></tr></tbody></table></figure>
<p>实现的功能是：(ax)=(ax)+(bx)+CF</p>
<p>由此可见，adc指令比add指令多加了一个CF的值</p>
<h2 id="sbb指令"><a class="markdownIt-Anchor" href="#sbb指令"></a> sbb指令</h2>
<p>sbb是带借位减法指令，它利用了CF位上记录的借位值</p>
<p>格式：sbb 操作对象1，操作对象2</p>
<p>功能：操作对象1=操作对象1-操作对象2-CF</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbb ax,bx</span><br></pre></td></tr></tbody></table></figure>
<p>实现的功能是：(ax)=(ax)-(bx)-CF</p>
<h2 id="cmp指令"><a class="markdownIt-Anchor" href="#cmp指令"></a> cmp指令</h2>
<p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果，cmp指令执行后，将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。</p>
<p>格式：cmp 操作对象1，操作对象2</p>
<p>功能：计算操作对象1-操作对象2，但不保存结果</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp ax,ax</span><br></pre></td></tr></tbody></table></figure>
<p>这行指令执行后，结果为0，但是不在ax中保存，执行后，zf=1，pf=1，sf=0，cf=0，of=0</p>
<p>指令cmp ax,bx含义是比较ax和bx中的值，如果执行后：</p>
<p>zf=1，说明(ax)=(bx)</p>
<p>zf=0，说明(ax)≠(bx)</p>
<p>cf=1，说明(ax)&lt;(bx)</p>
<p>cf=0，说明(ax)≥(bx)</p>
<p>cf=0且zf=0，说明(ax)&gt;(bx)</p>
<p>cf=1或zf=1，说明(ax)≤(bx)</p>
<blockquote>
<p>有些时候，也可以用sf(得知实际结果的正负)的同时考察of(得知有没有溢出)，就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果</p>
</blockquote>
<p>例如：cmp ah,bh：</p>
<p>1、如果sf=1，of=0</p>
<p>of=0，说明没有溢出，逻辑上结果的正负=实际结果的正负</p>
<p>因sf=1，实际结果为负，所以真正的结果也为负，(ah)&lt;(bh)</p>
<p>2、如果sf=1，of=1</p>
<p>of=1，说明有溢出，逻辑上结果的正负≠实际结果的正负</p>
<p>因sf=1，实际结果为负，所以真正的结果为正，(ah)&gt;(bh)</p>
<p>3、如果sf=0，of=1</p>
<p>of=1，说明有溢出，逻辑上结果的正负≠实际结果的正负</p>
<p>因sf=1，实际结果为非负，所以真正的结果为负，(ah)&lt;(bh)</p>
<p>4、如果sf=0，of=0</p>
<p>of=0，说明没有溢出，逻辑上结果的正负=实际结果的正负</p>
<p>因sf=0，实际结果为非负，所以真正的结果为非负，(ah)≥(bh)</p>
<h2 id="df-标志"><a class="markdownIt-Anchor" href="#df-标志"></a> DF 标志</h2>
<p>DF是方向标志位。在串处理指令中，控制每次操作后si、di的增减：</p>
<p>df=0 每次操作后si、di递增</p>
<p>df=1 每次操作后si、di递减</p>
<h2 id="pushf和popf"><a class="markdownIt-Anchor" href="#pushf和popf"></a> pushf和popf</h2>
<p>pushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据，送入标志寄存器中。</p>
<h1 id="内中断"><a class="markdownIt-Anchor" href="#内中断"></a> 内中断</h1>
<p>任何一个通用的CPU，比如8086，都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊的信息，并且可以立即对所接收到的信息进行处理。这种特殊的信息，我们可以称其为：中断信息。中断的意思是指，CPU不再接着向下执行，而是转去处理这个特殊信息。</p>
<p>中断信息可以来自CPU内部和外部，这一张主要是内部的中断信息，也就是内中断。</p>
<h2 id="内中断的产生"><a class="markdownIt-Anchor" href="#内中断的产生"></a> 内中断的产生</h2>
<p>当CPU内部有以下情况发生时，将产生相应的中断信息：</p>
<p>1、除法错误（比如执行div时，除法溢出）</p>
<p>2、单步执行</p>
<p>3、执行into指令</p>
<p>4、执行int指令</p>
<blockquote>
<p>CPU首先要知道，所接收到的中断信息的来源，所以中断信息中必须包含识别来源的编码，8086CPU将这种编码称为中断类型码。</p>
</blockquote>
<p>上述4种中断源在8086CPU中的中断码如下所示：</p>
<p>1、除法错误：0</p>
<p>2、单步执行：1</p>
<p>3、执行into指令：4</p>
<p>4、执行int指令，该指令格式为int n，n为字节型立即数，是提供给CPU的中断类型码。</p>
<h2 id="中断向量表"><a class="markdownIt-Anchor" href="#中断向量表"></a> 中断向量表</h2>
<p>先来了解两个个概念：</p>
<p><strong>1、中断向量：中断处理程序的入口地址。</strong></p>
<p><strong>2、中断向量表：中断处理程序入口地址的列表。</strong></p>
<blockquote>
<p>中断向量表在内存中存放，对于8086PC机，中断向量表指定放在内存地址0处。从内存0000:0000到0000:03FF的1024个单元中存放着中断向量表，只要使用8086CPU，中断向量表就必须放在0000:0000~0000:03FF单元中，这是规定，因为8086CPU就从这个地方读取中断向量表。</p>
</blockquote>
<h2 id="中断过程"><a class="markdownIt-Anchor" href="#中断过程"></a> 中断过程</h2>
<p>8086CPU在收到中断信息后，所引发的中断过程：</p>
<p>1、取得中断类型码</p>
<p>2、标志寄存器的值入栈</p>
<p>3、设置标志寄存器的第8位TF和第9位IF的值为0</p>
<p>4、CS的内容入栈</p>
<p>5、IP的内容入栈</p>
<p>6、从内存地址为中断类型码 * 4和中断类型码 * 4+2的两个字单元中读取中断处理程序的入口地址设置CS和IP</p>
<p>可以更简洁地描述中断过程：</p>
<p>1、取得中断类型码</p>
<p>2、pushf</p>
<p>3、TF=0，IF=0</p>
<p>4、push CS</p>
<p>5、push IP</p>
<p>6、(IP)=(N * 4)，(CS)=(N * 4+2)</p>
<p>最后一步完成后，CPU开始执行由程序员编写的中断处理程序。</p>
<h2 id="中断处理程序和iret指令"><a class="markdownIt-Anchor" href="#中断处理程序和iret指令"></a> 中断处理程序和iret指令</h2>
<p>中断处理程序的编写方法和子程序的比较相似，下面是常规步骤：</p>
<p>1、保存用到的寄存器</p>
<p>2、处理中断</p>
<p>3、恢复用到的寄存器</p>
<p>4、用iret指令返回</p>
<p><strong>iret指令用汇编语法描述为：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></tbody></table></figure>
<h1 id="int指令"><a class="markdownIt-Anchor" href="#int指令"></a> int指令</h1>
<p>中断信息可以来自内部和外部，上一章是内中断，这一章还是内中断，不过是另一种内中断。</p>
<h2 id="int指令-2"><a class="markdownIt-Anchor" href="#int指令-2"></a> int指令</h2>
<p>int指令的格式为int n；n是中断类型码，它的功能是引发中断过程。</p>
<p>CPU执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下：</p>
<p>1、取得中断类型码n</p>
<p>2、标志寄存器入栈，TF=0，IF=0</p>
<p>3、CS、IP入栈</p>
<p>4、(IP)=(n * 4)，(CS)=(n * 4+2)</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Los-kos</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.los-kos.cn/posts/huibian/">https://www.los-kos.cn/posts/huibian/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.los-kos.cn" target="_blank">Los-Kos</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/featureimages/1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/w.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/z.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/posts/c/"><img class="prev_cover" src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/img/featureimages/20.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++一些常用语法</div></div></a></div><div class="next-post pull_right"><a href="/posts/educoder/"><img class="next_cover" src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/img/featureimages/18.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">educoder课设作业</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="/js/valine.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: '4eTTwcW4LbmtC9nSWqAbekph-gzGzoHsz',
  appKey: 'k1vFce20H7t5wsbsAY4xd1R7',
  notify: false,
  verify: false,
  placeholder: '(●ˇ∀ˇ●)ノ来都来了 留个脚印再走吧（昵称填写QQ有惊喜哦）',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Los-kos</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hello！ Welcome to los-kos's blog ！！</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="/js/third-party/click_heart.js"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script></body></html>