<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>汇编语言基础 | Los-Kos</title><meta name="description" content="汇编初识"><meta name="keywords" content="汇编"><meta name="author" content="Los-kos"><meta name="copyright" content="Los-kos"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/whloki/cdn@master/img/avatar.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="汇编语言基础"><meta name="twitter:description" content="汇编初识"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/img/featureimages/19.jpg"><meta property="og:type" content="article"><meta property="og:title" content="汇编语言基础"><meta property="og:url" content="https://www.los-kos.cn/posts/huibian/"><meta property="og:site_name" content="Los-Kos"><meta property="og:description" content="汇编初识"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/img/featureimages/19.jpg"><meta property="article:published_time" content="2020-07-10T02:05:34.000Z"><meta property="article:modified_time" content="2020-07-12T01:40:16.034Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://www.los-kos.cn/posts/huibian/"><link rel="prev" title="C++一些常用语法" href="https://www.los-kos.cn/posts/c/"><link rel="next" title="educoder课设作业" href="https://www.los-kos.cn/posts/educoder/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8156eb470c2d34104408dd52ad3f8182";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://www.los-kos.cn/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"I,Love,You,我喜欢你,很喜欢你,超级超级喜欢你","fontSize":"18px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Los-Kos" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="Los-Kos" type="application/rss+xml">
<link rel="stylesheet" href="/css/prism-shades-of-purple.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/whloki/cdn@master/img/avatar.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">21</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础知识"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#机器语言"><span class="toc-number">1.1.</span> <span class="toc-text">机器语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#汇编语言"><span class="toc-number">1.2.</span> <span class="toc-text">汇编语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#汇编语言的产生"><span class="toc-number">1.2.1.</span> <span class="toc-text">汇编语言的产生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#汇编语言的组成"><span class="toc-number">1.2.2.</span> <span class="toc-text">汇编语言的组成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#寄存器"><span class="toc-number">2.</span> <span class="toc-text">寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#通用寄存器"><span class="toc-number">2.1.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字"><span class="toc-number">2.2.</span> <span class="toc-text">字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#几条汇编指令"><span class="toc-number">2.3.</span> <span class="toc-text">几条汇编指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#物理地址"><span class="toc-number">2.4.</span> <span class="toc-text">物理地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段寄存器"><span class="toc-number">2.5.</span> <span class="toc-text">段寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CS和IP"><span class="toc-number">2.6.</span> <span class="toc-text">CS和IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#修改CS和IP得到指令"><span class="toc-number">2.7.</span> <span class="toc-text">修改CS和IP得到指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DOSBox的使用"><span class="toc-number">3.</span> <span class="toc-text">DOSBox的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Debug"><span class="toc-number">3.1.</span> <span class="toc-text">Debug</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Debug功能"><span class="toc-number">3.2.</span> <span class="toc-text">Debug功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOSBox使用方法"><span class="toc-number">3.3.</span> <span class="toc-text">DOSBox使用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#寄存器（内存访问）"><span class="toc-number">4.</span> <span class="toc-text">寄存器（内存访问）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DS和-address"><span class="toc-number">4.1.</span> <span class="toc-text">DS和[address]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mov、add、sub指令"><span class="toc-number">4.2.</span> <span class="toc-text">mov、add、sub指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU提供的栈机制"><span class="toc-number">4.3.</span> <span class="toc-text">CPU提供的栈机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#push过程"><span class="toc-number">4.3.1.</span> <span class="toc-text">push过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pop过程"><span class="toc-number">4.3.2.</span> <span class="toc-text">pop过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈顶超界问题"><span class="toc-number">4.4.</span> <span class="toc-text">栈顶超界问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第一个程序"><span class="toc-number">5.</span> <span class="toc-text">第一个程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个小程序"><span class="toc-number">5.1.</span> <span class="toc-text">一个小程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#各部分的含义"><span class="toc-number">5.2.</span> <span class="toc-text">各部分的含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序的执行"><span class="toc-number">5.3.</span> <span class="toc-text">程序的执行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BX-和loop指令"><span class="toc-number">6.</span> <span class="toc-text">[BX]和loop指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BX"><span class="toc-number">6.1.</span> <span class="toc-text">[BX]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loop指令"><span class="toc-number">6.2.</span> <span class="toc-text">loop指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编程举例"><span class="toc-number">6.2.1.</span> <span class="toc-text">编程举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段前缀"><span class="toc-number">6.3.</span> <span class="toc-text">段前缀</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#包含多个段的程序"><span class="toc-number">7.</span> <span class="toc-text">包含多个段的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#在代码段中使用数据"><span class="toc-number">7.1.</span> <span class="toc-text">在代码段中使用数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在代码段中使用栈"><span class="toc-number">7.2.</span> <span class="toc-text">在代码段中使用栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将数据、代码、栈放入不同的段"><span class="toc-number">7.3.</span> <span class="toc-text">将数据、代码、栈放入不同的段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#更灵活的定位内存地址的方法"><span class="toc-number">8.</span> <span class="toc-text">更灵活的定位内存地址的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#and和or指令"><span class="toc-number">8.1.</span> <span class="toc-text">and和or指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#and指令"><span class="toc-number">8.1.1.</span> <span class="toc-text">and指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#or指令"><span class="toc-number">8.1.2.</span> <span class="toc-text">or指令</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/img/featureimages/19.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Los-Kos</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">汇编语言基础</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-10 10:05:34"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-07-10</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-12 09:40:16"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-12</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%B1%87%E7%BC%96/">汇编</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">4.6k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 15 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"> <div class="post-content" id="article-container"><p>这篇文章，记录下学习汇编的过程，记录一些需要记忆的知识。</p>
<a id="more"></a>

<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h2><p>说汇编语言之前，先简单说说机器语言：机器语言是机器指令的集合。机器指令展开来讲就是一台机器执行的命令。像电子计算机，机器指令就是一列一列的二进制数字，计算机可以处理这些数据进行运算。</p>
<h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><h3 id="汇编语言的产生"><a href="#汇编语言的产生" class="headerlink" title="汇编语言的产生"></a>汇编语言的产生</h3><p>不难看出，机器语言无论是书写还是计算都很麻烦，也难于辨别和记忆，所以产生了汇编语言。</p>
<p>汇编语言的主体是汇编指令，这种指令有别于机器指令，在于它便于书写和记忆。</p>
<p><strong><em>例如：</em></strong></p>
<p><strong><em>操作：寄存器BX的内容送到AX中</em></strong></p>
<p><strong><em>机器指令：1000100111011000</em></strong></p>
<p><strong><em>汇编指令：mov ax,bx</em></strong></p>
<p>汇编语言的方便之处很容易看出了吧</p>
<h3 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h3><p>汇编语言有3类指令组成：</p>
<p>1、汇编指令：机器码的助记符，有相应的机器码。</p>
<p>2、伪指令：没有对应的机器码，由编译器执行，计算机并不执行。</p>
<p>3、其他符号：例如+、-、*、/等，由编译器识别，没有对应的机器码。</p>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>8086CPU的所有寄存器都是16位的，可以存放2个字节。</p>
<p>通用寄存器有4个：AX、BX、CX、DX，每一个又可以分为两个可以独立使用的8位寄存器来使用：</p>
<p>● AX可以分为AH和AL;</p>
<p>● BX可以分为BH和BL;</p>
<p>● CX可以分为CH和CL;</p>
<p>● DX可以分为DH和DL;</p>
<blockquote>
<p>H是高位，L是低位，AH寄存器存储的是AX的高8位，AL寄存器存储的是AX的低8位</p>
</blockquote>
<blockquote>
<p>寄存器的名称在编码的时候大小写均可以</p>
</blockquote>
<h2 id="字"><a href="#字" class="headerlink" title="字"></a>字</h2><p>● 字节： 记为byte，一个字节由8个bit组成，可以存在8位寄存器中。</p>
<p>● 字： 记为word，一个字由两个字节组成，分别称为这个字的高位字节和低位字节。</p>
<h2 id="几条汇编指令"><a href="#几条汇编指令" class="headerlink" title="几条汇编指令"></a>几条汇编指令</h2><table>
<thead>
<tr>
<th align="center">汇编指令</th>
<th align="center">控制CPU完成的操作</th>
<th align="center">高级语言语法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mov ax,1000H</td>
<td align="center">将1000H送入寄存器AX</td>
<td align="center">AX=1000H</td>
</tr>
<tr>
<td align="center">mov ax,bx</td>
<td align="center">将寄存器BX中的数据送入寄存器AX中</td>
<td align="center">AX=BX</td>
</tr>
<tr>
<td align="center">add ax,bx</td>
<td align="center">将AX和BX中的数值相加，结果存在AX</td>
<td align="center">AX=AX+BX</td>
</tr>
</tbody></table>
<h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>CPU中的相关部件有两个16位地址：一个称为段地址，另一个称为偏移地址；</p>
<p><strong>物理地址 = 段地址 x 16 + 偏移地址 ⇔ 物理地址 = 基础地址 + 偏移地址</strong></p>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><p>8086CPU有4个段寄存器：<strong>CS、DS、SS、ES</strong></p>
<h2 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h2><p>CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指针指令寄存器。</p>
<p>任意时刻，CPU将CS：IP中指向的内容当作指令执行。</p>
<h2 id="修改CS和IP得到指令"><a href="#修改CS和IP得到指令" class="headerlink" title="修改CS和IP得到指令"></a>修改CS和IP得到指令</h2><p>前面提到mov指令可以修改寄存器的值，但是CS和IP的值不能被修改，现在介绍一种新的指令：<strong>jmp指令</strong></p>
<p>用法：</p>
<p>● jmp 段地址：偏移地址。例如：jmp 1234：3，执行后CS=1234H，IP=0003H，CPU将从12343H处读取指令。</p>
<p>● jmp 某一合法寄存器，功能：用寄存器的值修改IP。例如：ax=1000H，IP=0001H，jmp ax，执行后IP=1000H</p>
<h1 id="DOSBox的使用"><a href="#DOSBox的使用" class="headerlink" title="DOSBox的使用"></a>DOSBox的使用</h1><p>DOSBox是一个模拟dos系统的软件，学习汇编可以使用它来完成编译、连接等过程。</p>
<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>Debug是调试工具，使用它可以查看CPU中各种寄存器中的内容、内存情况和在机器码级跟踪程序的运行</p>
<h2 id="Debug功能"><a href="#Debug功能" class="headerlink" title="Debug功能"></a>Debug功能</h2><p>● 用Debug的R命令查看、改变CPU寄存器的内容</p>
<p>● 用Debug的D命令查看内存中的内容</p>
<p>● 用Debug的E命令改写内存中的内容</p>
<p>● 用Debug的U命令将内存中的机器指令翻译成汇编指令</p>
<p>● 用Debug的T命令执行一条机器指令</p>
<p>● 用Debug的A命令以汇编指令的格式在内存中写入一条机器指令</p>
<h2 id="DOSBox使用方法"><a href="#DOSBox使用方法" class="headerlink" title="DOSBox使用方法"></a>DOSBox使用方法</h2><p>DOSBox使用方法不难，网上有很多教程，这里就不多讲解了</p>
<h1 id="寄存器（内存访问）"><a href="#寄存器（内存访问）" class="headerlink" title="寄存器（内存访问）"></a>寄存器（内存访问）</h1><h2 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h2><p>CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址，在8086CPU中，内存地址由段地址个偏移地址组成，8086CPU中有一个DS寄存器，存放段地址，而常见的“[]”这种格式，表示一个内存单元，里面存放的是偏移地址；</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov bx，1000H</span><br><span class="line"></span><br><span class="line">mov ds，bx</span><br><span class="line"></span><br><span class="line">mov ax，[0]</span><br></pre></td></tr></tbody></table></figure>



<p>这三步指令将10000H（1000：0）中的数据读到ax中</p>
<blockquote>
<p>这里不能直接用mov ds，1000H，8086CPU不支持直接将数据送入段寄存器中，必须通过其他寄存器进行中转才行。</p>
</blockquote>
<h2 id="mov、add、sub指令"><a href="#mov、add、sub指令" class="headerlink" title="mov、add、sub指令"></a>mov、add、sub指令</h2><p>前面说到过mov指令和add指令，那就简单说说sub指令：</p>
<table>
<thead>
<tr>
<th align="center">汇编指令</th>
<th align="center">控制CPU完成的操作</th>
<th align="center">高级语言语法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sub ax,bx</td>
<td align="center">将AX和BX中的数值相加，结果存在AX</td>
<td align="center">AX=AX-BX</td>
</tr>
</tbody></table>
<p>下面是一些常用的格式：</p>
<blockquote>
<p>mov/add/sub 寄存器，数据           例如：mov/add/sub ax,8</p>
<p>mov/add/sub 寄存器，寄存器       例如：mov/add/sub ax,bx</p>
<p>mov/add/sub 寄存器，内存单元   例如：mov/add/sub ax,[0]</p>
<p>mov/add/sub 内存单元，寄存器   例如：mov/add/sub [0],ax</p>
<p>mov 段寄存器，寄存器                   例如：mov ds,ax</p>
</blockquote>
<h2 id="CPU提供的栈机制"><a href="#CPU提供的栈机制" class="headerlink" title="CPU提供的栈机制"></a>CPU提供的栈机制</h2><p>8086CPU提供入栈和出栈的指令，最基本的是push(入栈)和pop(出栈)：</p>
<table>
<thead>
<tr>
<th align="center">汇编指令</th>
<th align="center">控制CPU完成的操作</th>
<th align="center">高级语言语法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">push ax</td>
<td align="center">将寄存器ax中的值送入栈中</td>
<td align="center">—</td>
</tr>
<tr>
<td align="center">pop ax</td>
<td align="center">从栈顶取出数据送入ax中</td>
<td align="center">—</td>
</tr>
</tbody></table>
<p>8086CPU在寻找当前栈顶位置时提供了一种方法：</p>
<p>8086CPU中有两个寄存器SS和SP，SS存放栈顶的段地址，SP存放栈顶元素的偏移地址。</p>
<p>任意时刻，SS：SP指向栈顶元素。当执行push和pop指令时，CPU就从SS和SP中获取栈顶的地址。</p>
<h3 id="push过程"><a href="#push过程" class="headerlink" title="push过程"></a>push过程</h3><p>push ax的执行，分为以下两部进行：</p>
<p>1、SP=SP-2，SS：SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶。</p>
<p>2、将ax中的内容送到SS：SP指向的内存单元处，SS：SP此时指向新的栈顶。</p>
<h3 id="pop过程"><a href="#pop过程" class="headerlink" title="pop过程"></a>pop过程</h3><p>pop ax的执行和push正好相反，也是分为两部执行：</p>
<p>1、将SS：SP指向的内存单元处的数据送入ax中。</p>
<p>2、SP=SP+2，SS：SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</p>
<h2 id="栈顶超界问题"><a href="#栈顶超界问题" class="headerlink" title="栈顶超界问题"></a>栈顶超界问题</h2><p>当一个栈满了之后，此时若执行push命令，则会发生栈满情况，这些栈空间很可能存放很多有用的数据，代码等，是很危险的情况。</p>
<p>当然，若栈为空，执行pop命令也会栈越界。</p>
<p>所以在实际工作中，一定要注意栈越界情况，尽可能的用到最大的栈空间。</p>
<h1 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h1><h2 id="一个小程序"><a href="#一个小程序" class="headerlink" title="一个小程序"></a>一个小程序</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    mov ax,0123H</span><br><span class="line">    mov bx,0456H</span><br><span class="line">    add ax,bx</span><br><span class="line">    add ax,ax</span><br><span class="line">    </span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>

<p>这是一段简单的汇编程序，先说明下各部分的含义：</p>
<h2 id="各部分的含义"><a href="#各部分的含义" class="headerlink" title="各部分的含义"></a>各部分的含义</h2><p><strong>1、伪指令</strong></p>
<p>在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。</p>
<p>汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终被CPU所执行；而伪指令没有对应的机器指令，最终不被CPU所执行而被编译器执行。</p>
<p>上面程序中有3中伪指令：</p>
<p>● <strong>segment</strong>和<strong>ends</strong>是一对成对使用的伪指令，这是在可被编译器编译的汇编程序中必须用到的伪指令。功能是定义一个段，<strong>segment</strong>和<strong>ends</strong>分别说明一个段的开始和结束。</p>
<p>一个程序中通常会有多个段，代码段只是其中一种。</p>
<p>● <strong>end</strong>是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，碰到<strong>end</strong>就会结束。</p>
<p>一定要记得在结尾加上<strong>end</strong>，否则，编译器无法知道程序在何处结束</p>
<p>● <strong>assume</strong>含义是“假设”，它假设某一段寄存器和程序中的某一个用<strong>segment…ends</strong>定义的段相关联，通过assume说明这种关联。</p>
<p><strong>2、标号</strong></p>
<p>汇编源程序中，除了汇编指令和伪指令外，还有一些标号，例如“codesg”。一个标号指代了一个地址。比如codesg在segment的前面，作为一个段的名称，这个段的名称最终被编译、连接程序处理为一个段的段地址。</p>
<p><strong>3、程序的结构</strong></p>
<p>(1) 我们要定义一个段，名称为abc</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">abc ends</span><br></pre></td></tr></tbody></table></figure>

<p>(2) 在这个段中写入汇编指令，来实现我们的任务</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    add ax,ax</span><br><span class="line">abc ends</span><br></pre></td></tr></tbody></table></figure>

<p>(3) 指出程序在何处结束</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>

<p>(4) abc被当做代码段来用，所以，应该将abc和cs联系起来</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>

<p><strong>4、程序返回</strong></p>
<p>一个程序结束后，CPU的控制权交还给使它得以运行的程序，我们称这个过程为：<strong>程序返回</strong></p>
<p>返回方法：在程序的末尾添加返回的程序段：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax 4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></tbody></table></figure>



<p>与结束相关的概念：</p>
<table>
<thead>
<tr>
<th align="center">目的</th>
<th align="center">相关指令</th>
<th align="center">指令性质</th>
<th align="center">指令执行者</th>
</tr>
</thead>
<tbody><tr>
<td align="center">通知编译器一个段结束</td>
<td align="center">段名 ends</td>
<td align="center">伪指令</td>
<td align="center">编译时，由编译器执行</td>
</tr>
<tr>
<td align="center">通知编译器程序结束</td>
<td align="center">end</td>
<td align="center">伪指令</td>
<td align="center">编译时，由编译器执行</td>
</tr>
<tr>
<td align="center">程序返回</td>
<td align="center">mov ax,4c00H  int 21H</td>
<td align="center">汇编指令</td>
<td align="center">执行时，由CPU执行</td>
</tr>
</tbody></table>
<h2 id="程序的执行"><a href="#程序的执行" class="headerlink" title="程序的执行"></a>程序的执行</h2><p>一个程序从开始到执行分为以下几步：</p>
<p>● 编辑源程序</p>
<p>● 编译</p>
<p>● 连接</p>
<p>● .exe的执行</p>
<p>这些步骤可以用<strong>DOSBox</strong>进行，具体方法就不多说了</p>
<h1 id="BX-和loop指令"><a href="#BX-和loop指令" class="headerlink" title="[BX]和loop指令"></a>[BX]和loop指令</h1><p>1、[bx]</p>
<p>[bx]和[0]类似，都表示一个内存单元，[bx]的偏移地址在bx中，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br></pre></td></tr></tbody></table></figure>

<p>将一个内存单元的内容送入ax，这个内存单元偏移地址在bx，段地址在ds中。</p>
<p>2、loop</p>
<p><strong>loop</strong>有循环的意思，显然这个指令和循环有关。</p>
<p>3、描述性符号”()”</p>
<p>“()”表示一个寄存器或者一个内存单元的内容，例如：</p>
<p>(ax)表示ax中的内容；(20000H)表示内存20000H单元的内容</p>
<p>4、约定符号idata表示常量</p>
<p>用idata表示一个常量，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[idata]</span><br><span class="line"></span><br><span class="line">mov bx,idata</span><br></pre></td></tr></tbody></table></figure>

<p>第一句就代表mov ax,[1]、mov ax,[2]、mov ax,[3]…</p>
<p>第二句就代表mov bx,1、mov bx,2、mov bx,3</p>
<h2 id="BX"><a href="#BX" class="headerlink" title="[BX]"></a>[BX]</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br></pre></td></tr></tbody></table></figure>

<p>功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入ax中，即：(ax)=((ds)*16+(bx))</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [bx],ax</span><br></pre></td></tr></tbody></table></figure>

<p>功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA：EA处，即：((ds)*16+(bx)=(ax))</p>
<p><strong>inc指令：</strong></p>
<table>
<thead>
<tr>
<th align="center">汇编指令</th>
<th align="center">控制CPU完成的操作</th>
<th align="center">高级语言语法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">inc ax</td>
<td align="center">ax中的内容加一</td>
<td align="center">ax++</td>
</tr>
</tbody></table>
<h2 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h2><p>loop指令的格式是：loop 标号，需要进行两部操作：</p>
<p>● (cx)=(cx)-1</p>
<p>● 判断cx的值，不为0则转至标号处执行程序，如果为0则向下执行</p>
<h3 id="编程举例"><a href="#编程举例" class="headerlink" title="编程举例"></a>编程举例</h3><p>若要计算2^3的值，你可能想到2×2×2，在汇编语言中我们知道没有’×’这个符号，那要怎么解决呢？前面讲过的add指令就派上用场了：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br></pre></td></tr></tbody></table></figure>

<p>通过这样的加法运算，可以把乘方问题转化成加法来实现。</p>
<p>但是有一点注意的是，2^3次方还好说，如果2^100,1000次方，再用add指令就麻烦了，所以，我们引入了loop指令可以轻松解决这个问题：</p>
<p>例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    mov cx,100</span><br><span class="line">S:  add ax,ax</span><br><span class="line">    loop s</span><br><span class="line">    </span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>

<p><strong>一、分析：</strong></p>
<p>1、标号</p>
<p>汇编语言中，标号代表一个地址，上面程序中s就是一个标号，它实际上是标识了一个地址，这个地址有一条指令：add ax,ax</p>
<p>2、loop s</p>
<p>CPU执行loop s的时候进行两步操作：</p>
<p>● (cx)=(cx)-1</p>
<p>● 判断cx的值，不为0则转至标号处执行程序，如果为0则向下执行</p>
<p>3、上面程序执行了100次，实际上是计算2^101次方</p>
<p><strong>二、总结：</strong></p>
<p>cx和loop指令配合实现循环功能的3个要点：</p>
<p>● 在cx中存放循环次数</p>
<p>● loop指令中的标号所标识地址要在前面</p>
<p>● 要循环执行的程序段，要写在标号和loop指令的中间，框架如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    mov cx,循环次数</span><br><span class="line">s:  </span><br><span class="line">    循环执行程序段</span><br><span class="line">    loop s</span><br></pre></td></tr></tbody></table></figure>

<h2 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h2><p>用于显式地指明内存单元的段地址的ds:，cs:，ss:，es:称为段前缀。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds/cs/ss/es:[bx]</span><br></pre></td></tr></tbody></table></figure>

<p>这行代码含义是：</p>
<p>将一个内存单元的内容送入ax，这个内存单元的长度为2个字节(字单元)，存放一个字，偏移地址在bx/cs/ss/es中，段地址在ds中</p>
<h1 id="包含多个段的程序"><a href="#包含多个段的程序" class="headerlink" title="包含多个段的程序"></a>包含多个段的程序</h1><p>前面我们只接触到了代码段，如果程序需要用其他空间来存放数据，就得使用其他的段。这一章，我们学习数据段、栈段、代码段</p>
<h2 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h2><p>考虑这样一个问题，编程计算一下8个数据的和，结果存在ax寄存器中：</p>
<p>1,2,3,4,5,6,7,8，</p>
<p>在前面已经学习过了loop指令，因此肯定是希望用循环的方式进行数据的相加，所以，我们可以将数据存储在一组地址连续的内存单元中，通过指令送入。</p>
<p>具体方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    dw 1,2,3,4,5,6,7,8</span><br><span class="line">    </span><br><span class="line">    mov bx,0</span><br><span class="line">    mov ax,0</span><br><span class="line">    mov cx,8</span><br><span class="line">  s:add ax,cs:[bx]</span><br><span class="line">    add bx,2</span><br><span class="line">    loop s</span><br><span class="line">    </span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">    </span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>

<p>说明：</p>
<p>程序中的”dw”的含义是定义字型数据，”dw”即”define word”，dw定义8个字型数据，占16个字节的内存空间。</p>
<p>程序在运行的时候CS中存放的是代码段的段地址，所以段地址是已知的了，那么，偏移地址是多少呢？dw定义的数据处于代码段的一开始，所以偏移地址为0。</p>
<p> 程序中用bx存放加2递增的偏移地址，每次循环(bx)=(bx)+2，cs：bx指向下一个数据所在的字单元。</p>
<p>这样就完成了一系列的操作。</p>
<p><strong>在这里有个小问题：</strong></p>
<blockquote>
<p>程序运行的过程中，有时候会找不到程序的”入口”，这样一来，程序的逻辑就会混乱，运行也会出错。</p>
</blockquote>
<p>为了解决上面的问题，引入了新的模板：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">        ...</span><br><span class="line">        数据</span><br><span class="line">        ...</span><br><span class="line">start:</span><br><span class="line">        ...</span><br><span class="line">        代码</span><br><span class="line">        ...</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>

<p><strong>end</strong>不仅仅可以通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。</p>
<p>上面的模板中，<strong>end</strong>后面接了一个<strong>start</strong>，指明了程序的入口为<strong>start</strong>，编译器就从此处开始执行。</p>
<h2 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h2><p>考虑这样一个问题，将下列一组数据逆序存放：</p>
<p>1,2,3,4,5,6,7,8</p>
<p>第一反应想到的是利用栈，因为入栈和出栈正好相反嘛。利用栈把定义的数据存放在cs:0~cs:F 单元中， 依次将这8个字单元中的数据入栈，再依次出栈到这8个字单元中，从而实现数据的逆序存放。</p>
<p>具体方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">    dw 1,2,3,4,5,6,7,8</span><br><span class="line">    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;用dw定义16个字型数据，在程序加载后，将取得16个字的内存空间，存放着                                        ;16个数据,后面将这段空间当做栈来使用</span><br><span class="line">    </span><br><span class="line">start: mov ax,cs</span><br><span class="line">       mov ss,ax</span><br><span class="line">       mov sp,30h  ;将栈顶ss:sp指向cs:30</span><br><span class="line">       </span><br><span class="line">       mov bx,0</span><br><span class="line">       mov cx,8</span><br><span class="line">   s1: push cs:[bx]</span><br><span class="line">       add bx,2</span><br><span class="line">       loop s1     ;将代码段0~15个单元中的8个字型数据依次入栈</span><br><span class="line">       </span><br><span class="line">       mov bx,0</span><br><span class="line">       mov cx,8</span><br><span class="line">   s2: pop cs:[bx]</span><br><span class="line">       add bx,2</span><br><span class="line">       loop s2     ;依次出栈8个字型数据到代码段0~15个单元中</span><br><span class="line">       </span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line">       </span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>

<p>这样就可以实现数据的逆序存放了</p>
<h2 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h2><p>定义多个段：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">    dw 1,2,3,4,5,6,7,8</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: mov ax,stack</span><br><span class="line">       mov ss,ax</span><br><span class="line">       mov sp,20h    ;设置栈顶ss:sp指向stack:20</span><br><span class="line">       </span><br><span class="line">       mov ax,data</span><br><span class="line">       mov ds,ax     ;ds指向data段</span><br><span class="line">code ends</span><br></pre></td></tr></tbody></table></figure>

<p>说明：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,data ;这行指令的含义是将名称为data的段的段地址送入ax</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>mov ds,data 这行指令时错误的，8086CPU不允许将一个数值直接送入段寄存器中，如果程序中出现这行指令，将被编译器处理为一个表示段地址的数值</p>
</blockquote>
<p><strong>db、dw、dd的区别：</strong></p>
<blockquote>
<p>db定义字节类型变量，1个字节数据占1个字节单元，读完1个，偏移量+1</p>
<p>dw定义字节类型变量，1个字节数据占2个字节单元，读完1个，偏移量+2</p>
<p>dd定义字节类型变量，1个字节数据占4个字节单元，读完1个，偏移量+4</p>
</blockquote>
<h1 id="更灵活的定位内存地址的方法"><a href="#更灵活的定位内存地址的方法" class="headerlink" title="更灵活的定位内存地址的方法"></a>更灵活的定位内存地址的方法</h1><h2 id="and和or指令"><a href="#and和or指令" class="headerlink" title="and和or指令"></a>and和or指令</h2><h3 id="and指令"><a href="#and指令" class="headerlink" title="and指令"></a>and指令</h3><p>and指令：逻辑与指令，按位进行与运算</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br></pre></td></tr></tbody></table></figure>

<p>执行后，al=00100011B</p>
<p>或运算的计算方法为：”一一得一，其余为零”</p>
<h3 id="or指令"><a href="#or指令" class="headerlink" title="or指令"></a>or指令</h3><p>or指令：逻辑或运算，按位进行或运算</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">or al,00111011B</span><br></pre></td></tr></tbody></table></figure>

<p>执行后，al=01111011B</p>
<p>或运算的计算方法为：”零零得零，其余为一”</p>
<blockquote>
<p>若要将一个操作对象的某一位设置成0，则用and指令，例如：将al第3位设置成0：and al,11110111B</p>
<p>若要将一个操作对象的某一位设置成1，则用or指令，例如：将al第5位设置成1：or al,00100000B</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Los-kos</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.los-kos.cn/posts/huibian/">https://www.los-kos.cn/posts/huibian/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.los-kos.cn" target="_blank">Los-Kos</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/img/featureimages/19.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/w.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/z.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/posts/c/"><img class="prev_cover" src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/img/featureimages/20.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++一些常用语法</div></div></a></div><div class="next-post pull_right"><a href="/posts/educoder/"><img class="next_cover" src="https://cdn.jsdelivr.net/gh/whloki/cdn@1.2/img/featureimages/18.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/whloki/cdn@1.1/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">educoder课设作业</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="/js/valine.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: '4eTTwcW4LbmtC9nSWqAbekph-gzGzoHsz',
  appKey: 'k1vFce20H7t5wsbsAY4xd1R7',
  notify: false,
  verify: false,
  placeholder: '(●ˇ∀ˇ●)ノ来都来了 留个脚印再走吧（昵称填写QQ有惊喜哦）',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Los-kos</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hello！ Welcome to los-kos's blog ！！</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="/js/third-party/click_heart.js"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script></body></html>